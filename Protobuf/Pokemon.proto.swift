// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file pokemon.proto

import Foundation
import ProtocolBuffers


public func == (lhs: RequestEnvelop, rhs: RequestEnvelop) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnknown1 == rhs.hasUnknown1) && (!lhs.hasUnknown1 || lhs.unknown1 == rhs.unknown1)
  fieldCheck = fieldCheck && (lhs.hasRpcId == rhs.hasRpcId) && (!lhs.hasRpcId || lhs.rpcId == rhs.rpcId)
  fieldCheck = fieldCheck && (lhs.requests == rhs.requests)
  fieldCheck = fieldCheck && (lhs.hasUnknown6 == rhs.hasUnknown6) && (!lhs.hasUnknown6 || lhs.unknown6 == rhs.unknown6)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasAltitude == rhs.hasAltitude) && (!lhs.hasAltitude || lhs.altitude == rhs.altitude)
  fieldCheck = fieldCheck && (lhs.hasAuth == rhs.hasAuth) && (!lhs.hasAuth || lhs.auth == rhs.auth)
  fieldCheck = fieldCheck && (lhs.hasUnknown12 == rhs.hasUnknown12) && (!lhs.hasUnknown12 || lhs.unknown12 == rhs.unknown12)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.Requests, rhs: RequestEnvelop.Requests) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasMessage_ == rhs.hasMessage_) && (!lhs.hasMessage_ || lhs.message_ == rhs.message_)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.Unknown3, rhs: RequestEnvelop.Unknown3) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnknown4 == rhs.hasUnknown4) && (!lhs.hasUnknown4 || lhs.unknown4 == rhs.unknown4)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.Unknown6, rhs: RequestEnvelop.Unknown6) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnknown1 == rhs.hasUnknown1) && (!lhs.hasUnknown1 || lhs.unknown1 == rhs.unknown1)
  fieldCheck = fieldCheck && (lhs.hasUnknown2 == rhs.hasUnknown2) && (!lhs.hasUnknown2 || lhs.unknown2 == rhs.unknown2)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.Unknown6.Unknown2, rhs: RequestEnvelop.Unknown6.Unknown2) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnknown1 == rhs.hasUnknown1) && (!lhs.hasUnknown1 || lhs.unknown1 == rhs.unknown1)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.AuthInfo, rhs: RequestEnvelop.AuthInfo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasProvider == rhs.hasProvider) && (!lhs.hasProvider || lhs.provider == rhs.provider)
  fieldCheck = fieldCheck && (lhs.hasToken == rhs.hasToken) && (!lhs.hasToken || lhs.token == rhs.token)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.AuthInfo.Jwt, rhs: RequestEnvelop.AuthInfo.Jwt) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasContents == rhs.hasContents) && (!lhs.hasContents || lhs.contents == rhs.contents)
  fieldCheck = fieldCheck && (lhs.hasUnknown13 == rhs.hasUnknown13) && (!lhs.hasUnknown13 || lhs.unknown13 == rhs.unknown13)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.MessageQuad, rhs: RequestEnvelop.MessageQuad) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.f1 == rhs.f1)
  fieldCheck = fieldCheck && (lhs.f2 == rhs.f2)
  fieldCheck = fieldCheck && (lhs.hasLat == rhs.hasLat) && (!lhs.hasLat || lhs.lat == rhs.lat)
  fieldCheck = fieldCheck && (lhs.hasLong == rhs.hasLong) && (!lhs.hasLong || lhs.long == rhs.long)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.CatchPokemonMessage, rhs: RequestEnvelop.CatchPokemonMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEncounterId == rhs.hasEncounterId) && (!lhs.hasEncounterId || lhs.encounterId == rhs.encounterId)
  fieldCheck = fieldCheck && (lhs.hasPokeball == rhs.hasPokeball) && (!lhs.hasPokeball || lhs.pokeball == rhs.pokeball)
  fieldCheck = fieldCheck && (lhs.hasNormalizedReticleSize == rhs.hasNormalizedReticleSize) && (!lhs.hasNormalizedReticleSize || lhs.normalizedReticleSize == rhs.normalizedReticleSize)
  fieldCheck = fieldCheck && (lhs.hasSpawnpointId == rhs.hasSpawnpointId) && (!lhs.hasSpawnpointId || lhs.spawnpointId == rhs.spawnpointId)
  fieldCheck = fieldCheck && (lhs.hasHitPokemon == rhs.hasHitPokemon) && (!lhs.hasHitPokemon || lhs.hitPokemon == rhs.hitPokemon)
  fieldCheck = fieldCheck && (lhs.hasSpinModifier == rhs.hasSpinModifier) && (!lhs.hasSpinModifier || lhs.spinModifier == rhs.spinModifier)
  fieldCheck = fieldCheck && (lhs.hasNormalizedHitPosition == rhs.hasNormalizedHitPosition) && (!lhs.hasNormalizedHitPosition || lhs.normalizedHitPosition == rhs.normalizedHitPosition)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.EvolvePokemonMessage, rhs: RequestEnvelop.EvolvePokemonMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPokemonId == rhs.hasPokemonId) && (!lhs.hasPokemonId || lhs.pokemonId == rhs.pokemonId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.TransferPokemonMessage, rhs: RequestEnvelop.TransferPokemonMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPokemonId == rhs.hasPokemonId) && (!lhs.hasPokemonId || lhs.pokemonId == rhs.pokemonId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.EncounterMessage, rhs: RequestEnvelop.EncounterMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.encounterId == rhs.encounterId)
  fieldCheck = fieldCheck && (lhs.hasSpawnpointId == rhs.hasSpawnpointId) && (!lhs.hasSpawnpointId || lhs.spawnpointId == rhs.spawnpointId)
  fieldCheck = fieldCheck && (lhs.hasPlayerLatitude == rhs.hasPlayerLatitude) && (!lhs.hasPlayerLatitude || lhs.playerLatitude == rhs.playerLatitude)
  fieldCheck = fieldCheck && (lhs.hasPlayerLongitude == rhs.hasPlayerLongitude) && (!lhs.hasPlayerLongitude || lhs.playerLongitude == rhs.playerLongitude)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.FortSearchMessage, rhs: RequestEnvelop.FortSearchMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFortId == rhs.hasFortId) && (!lhs.hasFortId || lhs.fortId == rhs.fortId)
  fieldCheck = fieldCheck && (lhs.hasPlayerLatitude == rhs.hasPlayerLatitude) && (!lhs.hasPlayerLatitude || lhs.playerLatitude == rhs.playerLatitude)
  fieldCheck = fieldCheck && (lhs.hasPlayerLongitude == rhs.hasPlayerLongitude) && (!lhs.hasPlayerLongitude || lhs.playerLongitude == rhs.playerLongitude)
  fieldCheck = fieldCheck && (lhs.hasFortLatitude == rhs.hasFortLatitude) && (!lhs.hasFortLatitude || lhs.fortLatitude == rhs.fortLatitude)
  fieldCheck = fieldCheck && (lhs.hasFortLongitude == rhs.hasFortLongitude) && (!lhs.hasFortLongitude || lhs.fortLongitude == rhs.fortLongitude)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.FortDetailsRequest, rhs: RequestEnvelop.FortDetailsRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFortId == rhs.hasFortId) && (!lhs.hasFortId || lhs.fortId == rhs.fortId)
  fieldCheck = fieldCheck && (lhs.hasFortLatitude == rhs.hasFortLatitude) && (!lhs.hasFortLatitude || lhs.fortLatitude == rhs.fortLatitude)
  fieldCheck = fieldCheck && (lhs.hasFortLongitude == rhs.hasFortLongitude) && (!lhs.hasFortLongitude || lhs.fortLongitude == rhs.fortLongitude)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.RecycleInventoryItemMessage, rhs: RequestEnvelop.RecycleInventoryItemMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItemId == rhs.hasItemId) && (!lhs.hasItemId || lhs.itemId == rhs.itemId)
  fieldCheck = fieldCheck && (lhs.hasCount == rhs.hasCount) && (!lhs.hasCount || lhs.count == rhs.count)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: RequestEnvelop.ReleasePokemonMessage, rhs: RequestEnvelop.ReleasePokemonMessage) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPokemonId == rhs.hasPokemonId) && (!lhs.hasPokemonId || lhs.pokemonId == rhs.pokemonId)
  fieldCheck = fieldCheck && (lhs.pokemonIds == rhs.pokemonIds)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop, rhs: ResponseEnvelop) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnknown1 == rhs.hasUnknown1) && (!lhs.hasUnknown1 || lhs.unknown1 == rhs.unknown1)
  fieldCheck = fieldCheck && (lhs.hasUnknown2 == rhs.hasUnknown2) && (!lhs.hasUnknown2 || lhs.unknown2 == rhs.unknown2)
  fieldCheck = fieldCheck && (lhs.hasApiUrl == rhs.hasApiUrl) && (!lhs.hasApiUrl || lhs.apiUrl == rhs.apiUrl)
  fieldCheck = fieldCheck && (lhs.hasUnknown6 == rhs.hasUnknown6) && (!lhs.hasUnknown6 || lhs.unknown6 == rhs.unknown6)
  fieldCheck = fieldCheck && (lhs.hasAuthTicket == rhs.hasAuthTicket) && (!lhs.hasAuthTicket || lhs.authTicket == rhs.authTicket)
  fieldCheck = fieldCheck && (lhs.payload == rhs.payload)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.Unknown6, rhs: ResponseEnvelop.Unknown6) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnknown1 == rhs.hasUnknown1) && (!lhs.hasUnknown1 || lhs.unknown1 == rhs.unknown1)
  fieldCheck = fieldCheck && (lhs.hasUnknown2 == rhs.hasUnknown2) && (!lhs.hasUnknown2 || lhs.unknown2 == rhs.unknown2)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.Unknown6.Unknown2, rhs: ResponseEnvelop.Unknown6.Unknown2) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasUnknown1 == rhs.hasUnknown1) && (!lhs.hasUnknown1 || lhs.unknown1 == rhs.unknown1)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.AuthTicket, rhs: ResponseEnvelop.AuthTicket) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStart == rhs.hasStart) && (!lhs.hasStart || lhs.start == rhs.start)
  fieldCheck = fieldCheck && (lhs.hasExpireTimestampMs == rhs.hasExpireTimestampMs) && (!lhs.hasExpireTimestampMs || lhs.expireTimestampMs == rhs.expireTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasEnd == rhs.hasEnd) && (!lhs.hasEnd || lhs.end == rhs.end)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.HeartbeatPayload, rhs: ResponseEnvelop.HeartbeatPayload) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.cells == rhs.cells)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.ClientMapCell, rhs: ResponseEnvelop.ClientMapCell) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasS2CellId == rhs.hasS2CellId) && (!lhs.hasS2CellId || lhs.s2CellId == rhs.s2CellId)
  fieldCheck = fieldCheck && (lhs.hasAsOfTimeMs == rhs.hasAsOfTimeMs) && (!lhs.hasAsOfTimeMs || lhs.asOfTimeMs == rhs.asOfTimeMs)
  fieldCheck = fieldCheck && (lhs.fort == rhs.fort)
  fieldCheck = fieldCheck && (lhs.spawnPoint == rhs.spawnPoint)
  fieldCheck = fieldCheck && (lhs.wildPokemon == rhs.wildPokemon)
  fieldCheck = fieldCheck && (lhs.hasIsTruncatedList == rhs.hasIsTruncatedList) && (!lhs.hasIsTruncatedList || lhs.isTruncatedList == rhs.isTruncatedList)
  fieldCheck = fieldCheck && (lhs.fortSummary == rhs.fortSummary)
  fieldCheck = fieldCheck && (lhs.decimatedSpawnPoint == rhs.decimatedSpawnPoint)
  fieldCheck = fieldCheck && (lhs.mapPokemon == rhs.mapPokemon)
  fieldCheck = fieldCheck && (lhs.nearbyPokemon == rhs.nearbyPokemon)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.MapPokemonProto, rhs: ResponseEnvelop.MapPokemonProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSpawnPointId == rhs.hasSpawnPointId) && (!lhs.hasSpawnPointId || lhs.spawnPointId == rhs.spawnPointId)
  fieldCheck = fieldCheck && (lhs.hasEncounterId == rhs.hasEncounterId) && (!lhs.hasEncounterId || lhs.encounterId == rhs.encounterId)
  fieldCheck = fieldCheck && (lhs.hasPokedexTypeId == rhs.hasPokedexTypeId) && (!lhs.hasPokedexTypeId || lhs.pokedexTypeId == rhs.pokedexTypeId)
  fieldCheck = fieldCheck && (lhs.hasExpirationTimeMs == rhs.hasExpirationTimeMs) && (!lhs.hasExpirationTimeMs || lhs.expirationTimeMs == rhs.expirationTimeMs)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.PokemonFortProto, rhs: ResponseEnvelop.PokemonFortProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFortId == rhs.hasFortId) && (!lhs.hasFortId || lhs.fortId == rhs.fortId)
  fieldCheck = fieldCheck && (lhs.hasLastModifiedMs == rhs.hasLastModifiedMs) && (!lhs.hasLastModifiedMs || lhs.lastModifiedMs == rhs.lastModifiedMs)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasTeam == rhs.hasTeam) && (!lhs.hasTeam || lhs.team == rhs.team)
  fieldCheck = fieldCheck && (lhs.hasGuardPokemonId == rhs.hasGuardPokemonId) && (!lhs.hasGuardPokemonId || lhs.guardPokemonId == rhs.guardPokemonId)
  fieldCheck = fieldCheck && (lhs.hasGuardPokemonLevel == rhs.hasGuardPokemonLevel) && (!lhs.hasGuardPokemonLevel || lhs.guardPokemonLevel == rhs.guardPokemonLevel)
  fieldCheck = fieldCheck && (lhs.hasEnabled == rhs.hasEnabled) && (!lhs.hasEnabled || lhs.enabled == rhs.enabled)
  fieldCheck = fieldCheck && (lhs.hasFortType == rhs.hasFortType) && (!lhs.hasFortType || lhs.fortType == rhs.fortType)
  fieldCheck = fieldCheck && (lhs.hasGymPoints == rhs.hasGymPoints) && (!lhs.hasGymPoints || lhs.gymPoints == rhs.gymPoints)
  fieldCheck = fieldCheck && (lhs.hasIsInBattle == rhs.hasIsInBattle) && (!lhs.hasIsInBattle || lhs.isInBattle == rhs.isInBattle)
  fieldCheck = fieldCheck && (lhs.hasActiveFortModifier == rhs.hasActiveFortModifier) && (!lhs.hasActiveFortModifier || lhs.activeFortModifier == rhs.activeFortModifier)
  fieldCheck = fieldCheck && (lhs.hasLureInfo == rhs.hasLureInfo) && (!lhs.hasLureInfo || lhs.lureInfo == rhs.lureInfo)
  fieldCheck = fieldCheck && (lhs.hasCooldownCompleteMs == rhs.hasCooldownCompleteMs) && (!lhs.hasCooldownCompleteMs || lhs.cooldownCompleteMs == rhs.cooldownCompleteMs)
  fieldCheck = fieldCheck && (lhs.hasSponsor == rhs.hasSponsor) && (!lhs.hasSponsor || lhs.sponsor == rhs.sponsor)
  fieldCheck = fieldCheck && (lhs.hasRenderingType == rhs.hasRenderingType) && (!lhs.hasRenderingType || lhs.renderingType == rhs.renderingType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.FortLureInfoProto, rhs: ResponseEnvelop.FortLureInfoProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFortId == rhs.hasFortId) && (!lhs.hasFortId || lhs.fortId == rhs.fortId)
  fieldCheck = fieldCheck && (lhs.hasUnknown2 == rhs.hasUnknown2) && (!lhs.hasUnknown2 || lhs.unknown2 == rhs.unknown2)
  fieldCheck = fieldCheck && (lhs.hasActivePokemonId == rhs.hasActivePokemonId) && (!lhs.hasActivePokemonId || lhs.activePokemonId == rhs.activePokemonId)
  fieldCheck = fieldCheck && (lhs.hasLureExpiresTimestampMs == rhs.hasLureExpiresTimestampMs) && (!lhs.hasLureExpiresTimestampMs || lhs.lureExpiresTimestampMs == rhs.lureExpiresTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasDeployerPlayerCodename == rhs.hasDeployerPlayerCodename) && (!lhs.hasDeployerPlayerCodename || lhs.deployerPlayerCodename == rhs.deployerPlayerCodename)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.PokemonSummaryFortProto, rhs: ResponseEnvelop.PokemonSummaryFortProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFortSummaryId == rhs.hasFortSummaryId) && (!lhs.hasFortSummaryId || lhs.fortSummaryId == rhs.fortSummaryId)
  fieldCheck = fieldCheck && (lhs.hasLastModifiedMs == rhs.hasLastModifiedMs) && (!lhs.hasLastModifiedMs || lhs.lastModifiedMs == rhs.lastModifiedMs)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.ClientSpawnPointProto, rhs: ResponseEnvelop.ClientSpawnPointProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.WildPokemonProto, rhs: ResponseEnvelop.WildPokemonProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEncounterId == rhs.hasEncounterId) && (!lhs.hasEncounterId || lhs.encounterId == rhs.encounterId)
  fieldCheck = fieldCheck && (lhs.hasLastModifiedMs == rhs.hasLastModifiedMs) && (!lhs.hasLastModifiedMs || lhs.lastModifiedMs == rhs.lastModifiedMs)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasSpawnPointId == rhs.hasSpawnPointId) && (!lhs.hasSpawnPointId || lhs.spawnPointId == rhs.spawnPointId)
  fieldCheck = fieldCheck && (lhs.hasPokemon == rhs.hasPokemon) && (!lhs.hasPokemon || lhs.pokemon == rhs.pokemon)
  fieldCheck = fieldCheck && (lhs.hasTimeTillHiddenMs == rhs.hasTimeTillHiddenMs) && (!lhs.hasTimeTillHiddenMs || lhs.timeTillHiddenMs == rhs.timeTillHiddenMs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.WildPokemonProto.Pokemon, rhs: ResponseEnvelop.WildPokemonProto.Pokemon) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasPokemonId == rhs.hasPokemonId) && (!lhs.hasPokemonId || lhs.pokemonId == rhs.pokemonId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.NearbyPokemonProto, rhs: ResponseEnvelop.NearbyPokemonProto) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPokedexNumber == rhs.hasPokedexNumber) && (!lhs.hasPokedexNumber || lhs.pokedexNumber == rhs.pokedexNumber)
  fieldCheck = fieldCheck && (lhs.hasDistanceMeters == rhs.hasDistanceMeters) && (!lhs.hasDistanceMeters || lhs.distanceMeters == rhs.distanceMeters)
  fieldCheck = fieldCheck && (lhs.hasEncounterId == rhs.hasEncounterId) && (!lhs.hasEncounterId || lhs.encounterId == rhs.encounterId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.ProfilePayload, rhs: ResponseEnvelop.ProfilePayload) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.unknown1 == rhs.unknown1)
  fieldCheck = fieldCheck && (lhs.hasProfile == rhs.hasProfile) && (!lhs.hasProfile || lhs.profile == rhs.profile)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.Profile, rhs: ResponseEnvelop.Profile) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCreationTime == rhs.hasCreationTime) && (!lhs.hasCreationTime || lhs.creationTime == rhs.creationTime)
  fieldCheck = fieldCheck && (lhs.hasUsername == rhs.hasUsername) && (!lhs.hasUsername || lhs.username == rhs.username)
  fieldCheck = fieldCheck && (lhs.hasTeam == rhs.hasTeam) && (!lhs.hasTeam || lhs.team == rhs.team)
  fieldCheck = fieldCheck && (lhs.hasTutorial == rhs.hasTutorial) && (!lhs.hasTutorial || lhs.tutorial == rhs.tutorial)
  fieldCheck = fieldCheck && (lhs.hasAvatar == rhs.hasAvatar) && (!lhs.hasAvatar || lhs.avatar == rhs.avatar)
  fieldCheck = fieldCheck && (lhs.hasPokeStorage == rhs.hasPokeStorage) && (!lhs.hasPokeStorage || lhs.pokeStorage == rhs.pokeStorage)
  fieldCheck = fieldCheck && (lhs.hasItemStorage == rhs.hasItemStorage) && (!lhs.hasItemStorage || lhs.itemStorage == rhs.itemStorage)
  fieldCheck = fieldCheck && (lhs.hasDailyBonus == rhs.hasDailyBonus) && (!lhs.hasDailyBonus || lhs.dailyBonus == rhs.dailyBonus)
  fieldCheck = fieldCheck && (lhs.hasUnknown12 == rhs.hasUnknown12) && (!lhs.hasUnknown12 || lhs.unknown12 == rhs.unknown12)
  fieldCheck = fieldCheck && (lhs.hasUnknown13 == rhs.hasUnknown13) && (!lhs.hasUnknown13 || lhs.unknown13 == rhs.unknown13)
  fieldCheck = fieldCheck && (lhs.currency == rhs.currency)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.Profile.AvatarDetails, rhs: ResponseEnvelop.Profile.AvatarDetails) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSkin == rhs.hasSkin) && (!lhs.hasSkin || lhs.skin == rhs.skin)
  fieldCheck = fieldCheck && (lhs.hasHair == rhs.hasHair) && (!lhs.hasHair || lhs.hair == rhs.hair)
  fieldCheck = fieldCheck && (lhs.hasTshirt == rhs.hasTshirt) && (!lhs.hasTshirt || lhs.tshirt == rhs.tshirt)
  fieldCheck = fieldCheck && (lhs.hasTrousers == rhs.hasTrousers) && (!lhs.hasTrousers || lhs.trousers == rhs.trousers)
  fieldCheck = fieldCheck && (lhs.hasCap == rhs.hasCap) && (!lhs.hasCap || lhs.cap == rhs.cap)
  fieldCheck = fieldCheck && (lhs.hasBoots == rhs.hasBoots) && (!lhs.hasBoots || lhs.boots == rhs.boots)
  fieldCheck = fieldCheck && (lhs.hasGender == rhs.hasGender) && (!lhs.hasGender || lhs.gender == rhs.gender)
  fieldCheck = fieldCheck && (lhs.hasEyes == rhs.hasEyes) && (!lhs.hasEyes || lhs.eyes == rhs.eyes)
  fieldCheck = fieldCheck && (lhs.hasBackpack == rhs.hasBackpack) && (!lhs.hasBackpack || lhs.backpack == rhs.backpack)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.Profile.DailyBonus, rhs: ResponseEnvelop.Profile.DailyBonus) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNextCollectTimestampMs == rhs.hasNextCollectTimestampMs) && (!lhs.hasNextCollectTimestampMs || lhs.nextCollectTimestampMs == rhs.nextCollectTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasNextDefenderBonusCollectTimestampMs == rhs.hasNextDefenderBonusCollectTimestampMs) && (!lhs.hasNextDefenderBonusCollectTimestampMs || lhs.nextDefenderBonusCollectTimestampMs == rhs.nextDefenderBonusCollectTimestampMs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.Profile.Currency, rhs: ResponseEnvelop.Profile.Currency) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasAmount == rhs.hasAmount) && (!lhs.hasAmount || lhs.amount == rhs.amount)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.GetInventoryResponse, rhs: ResponseEnvelop.GetInventoryResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasInventoryDelta == rhs.hasInventoryDelta) && (!lhs.hasInventoryDelta || lhs.inventoryDelta == rhs.inventoryDelta)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.InventoryDelta, rhs: ResponseEnvelop.InventoryDelta) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasOriginalTimestampMs == rhs.hasOriginalTimestampMs) && (!lhs.hasOriginalTimestampMs || lhs.originalTimestampMs == rhs.originalTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasNewTimestampMs == rhs.hasNewTimestampMs) && (!lhs.hasNewTimestampMs || lhs.newTimestampMs == rhs.newTimestampMs)
  fieldCheck = fieldCheck && (lhs.inventoryItems == rhs.inventoryItems)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.InventoryItem, rhs: ResponseEnvelop.InventoryItem) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasModifiedTimestampMs == rhs.hasModifiedTimestampMs) && (!lhs.hasModifiedTimestampMs || lhs.modifiedTimestampMs == rhs.modifiedTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasDeletedItemKey == rhs.hasDeletedItemKey) && (!lhs.hasDeletedItemKey || lhs.deletedItemKey == rhs.deletedItemKey)
  fieldCheck = fieldCheck && (lhs.hasInventoryItemData == rhs.hasInventoryItemData) && (!lhs.hasInventoryItemData || lhs.inventoryItemData == rhs.inventoryItemData)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.InventoryItemData, rhs: ResponseEnvelop.InventoryItemData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPokemon == rhs.hasPokemon) && (!lhs.hasPokemon || lhs.pokemon == rhs.pokemon)
  fieldCheck = fieldCheck && (lhs.hasItem == rhs.hasItem) && (!lhs.hasItem || lhs.item == rhs.item)
  fieldCheck = fieldCheck && (lhs.hasPokedexEntry == rhs.hasPokedexEntry) && (!lhs.hasPokedexEntry || lhs.pokedexEntry == rhs.pokedexEntry)
  fieldCheck = fieldCheck && (lhs.hasPlayerStats == rhs.hasPlayerStats) && (!lhs.hasPlayerStats || lhs.playerStats == rhs.playerStats)
  fieldCheck = fieldCheck && (lhs.hasPlayerCurrency == rhs.hasPlayerCurrency) && (!lhs.hasPlayerCurrency || lhs.playerCurrency == rhs.playerCurrency)
  fieldCheck = fieldCheck && (lhs.hasPlayerCamera == rhs.hasPlayerCamera) && (!lhs.hasPlayerCamera || lhs.playerCamera == rhs.playerCamera)
  fieldCheck = fieldCheck && (lhs.hasInventoryUpgrades == rhs.hasInventoryUpgrades) && (!lhs.hasInventoryUpgrades || lhs.inventoryUpgrades == rhs.inventoryUpgrades)
  fieldCheck = fieldCheck && (lhs.hasAppliedItems == rhs.hasAppliedItems) && (!lhs.hasAppliedItems || lhs.appliedItems == rhs.appliedItems)
  fieldCheck = fieldCheck && (lhs.hasEggIncubators == rhs.hasEggIncubators) && (!lhs.hasEggIncubators || lhs.eggIncubators == rhs.eggIncubators)
  fieldCheck = fieldCheck && (lhs.hasPokemonFamily == rhs.hasPokemonFamily) && (!lhs.hasPokemonFamily || lhs.pokemonFamily == rhs.pokemonFamily)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.PokemonData, rhs: ResponseEnvelop.PokemonData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasPokemonId == rhs.hasPokemonId) && (!lhs.hasPokemonId || lhs.pokemonId == rhs.pokemonId)
  fieldCheck = fieldCheck && (lhs.hasCp == rhs.hasCp) && (!lhs.hasCp || lhs.cp == rhs.cp)
  fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
  fieldCheck = fieldCheck && (lhs.hasStaminaMax == rhs.hasStaminaMax) && (!lhs.hasStaminaMax || lhs.staminaMax == rhs.staminaMax)
  fieldCheck = fieldCheck && (lhs.hasMove1 == rhs.hasMove1) && (!lhs.hasMove1 || lhs.move1 == rhs.move1)
  fieldCheck = fieldCheck && (lhs.hasMove2 == rhs.hasMove2) && (!lhs.hasMove2 || lhs.move2 == rhs.move2)
  fieldCheck = fieldCheck && (lhs.hasDeployedFortId == rhs.hasDeployedFortId) && (!lhs.hasDeployedFortId || lhs.deployedFortId == rhs.deployedFortId)
  fieldCheck = fieldCheck && (lhs.hasOwnerName == rhs.hasOwnerName) && (!lhs.hasOwnerName || lhs.ownerName == rhs.ownerName)
  fieldCheck = fieldCheck && (lhs.hasIsEgg == rhs.hasIsEgg) && (!lhs.hasIsEgg || lhs.isEgg == rhs.isEgg)
  fieldCheck = fieldCheck && (lhs.hasEggKmWalkedTarget == rhs.hasEggKmWalkedTarget) && (!lhs.hasEggKmWalkedTarget || lhs.eggKmWalkedTarget == rhs.eggKmWalkedTarget)
  fieldCheck = fieldCheck && (lhs.hasEggKmWalkedStart == rhs.hasEggKmWalkedStart) && (!lhs.hasEggKmWalkedStart || lhs.eggKmWalkedStart == rhs.eggKmWalkedStart)
  fieldCheck = fieldCheck && (lhs.hasOrigin == rhs.hasOrigin) && (!lhs.hasOrigin || lhs.origin == rhs.origin)
  fieldCheck = fieldCheck && (lhs.hasHeightM == rhs.hasHeightM) && (!lhs.hasHeightM || lhs.heightM == rhs.heightM)
  fieldCheck = fieldCheck && (lhs.hasWeightKg == rhs.hasWeightKg) && (!lhs.hasWeightKg || lhs.weightKg == rhs.weightKg)
  fieldCheck = fieldCheck && (lhs.hasIndividualAttack == rhs.hasIndividualAttack) && (!lhs.hasIndividualAttack || lhs.individualAttack == rhs.individualAttack)
  fieldCheck = fieldCheck && (lhs.hasIndividualDefense == rhs.hasIndividualDefense) && (!lhs.hasIndividualDefense || lhs.individualDefense == rhs.individualDefense)
  fieldCheck = fieldCheck && (lhs.hasIndividualStamina == rhs.hasIndividualStamina) && (!lhs.hasIndividualStamina || lhs.individualStamina == rhs.individualStamina)
  fieldCheck = fieldCheck && (lhs.hasCpMultiplier == rhs.hasCpMultiplier) && (!lhs.hasCpMultiplier || lhs.cpMultiplier == rhs.cpMultiplier)
  fieldCheck = fieldCheck && (lhs.hasPokeball == rhs.hasPokeball) && (!lhs.hasPokeball || lhs.pokeball == rhs.pokeball)
  fieldCheck = fieldCheck && (lhs.hasCapturedCellId == rhs.hasCapturedCellId) && (!lhs.hasCapturedCellId || lhs.capturedCellId == rhs.capturedCellId)
  fieldCheck = fieldCheck && (lhs.hasBattlesAttacked == rhs.hasBattlesAttacked) && (!lhs.hasBattlesAttacked || lhs.battlesAttacked == rhs.battlesAttacked)
  fieldCheck = fieldCheck && (lhs.hasBattlesDefended == rhs.hasBattlesDefended) && (!lhs.hasBattlesDefended || lhs.battlesDefended == rhs.battlesDefended)
  fieldCheck = fieldCheck && (lhs.hasEggIncubatorId == rhs.hasEggIncubatorId) && (!lhs.hasEggIncubatorId || lhs.eggIncubatorId == rhs.eggIncubatorId)
  fieldCheck = fieldCheck && (lhs.hasCreationTimeMs == rhs.hasCreationTimeMs) && (!lhs.hasCreationTimeMs || lhs.creationTimeMs == rhs.creationTimeMs)
  fieldCheck = fieldCheck && (lhs.hasNumUpgrades == rhs.hasNumUpgrades) && (!lhs.hasNumUpgrades || lhs.numUpgrades == rhs.numUpgrades)
  fieldCheck = fieldCheck && (lhs.hasAdditionalCpMultiplier == rhs.hasAdditionalCpMultiplier) && (!lhs.hasAdditionalCpMultiplier || lhs.additionalCpMultiplier == rhs.additionalCpMultiplier)
  fieldCheck = fieldCheck && (lhs.hasFavorite == rhs.hasFavorite) && (!lhs.hasFavorite || lhs.favorite == rhs.favorite)
  fieldCheck = fieldCheck && (lhs.hasNickname == rhs.hasNickname) && (!lhs.hasNickname || lhs.nickname == rhs.nickname)
  fieldCheck = fieldCheck && (lhs.hasFromFort == rhs.hasFromFort) && (!lhs.hasFromFort || lhs.fromFort == rhs.fromFort)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.Pokemon, rhs: ResponseEnvelop.Pokemon) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasPokemonType == rhs.hasPokemonType) && (!lhs.hasPokemonType || lhs.pokemonType == rhs.pokemonType)
  fieldCheck = fieldCheck && (lhs.hasCp == rhs.hasCp) && (!lhs.hasCp || lhs.cp == rhs.cp)
  fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
  fieldCheck = fieldCheck && (lhs.hasStaminaMax == rhs.hasStaminaMax) && (!lhs.hasStaminaMax || lhs.staminaMax == rhs.staminaMax)
  fieldCheck = fieldCheck && (lhs.hasMove1 == rhs.hasMove1) && (!lhs.hasMove1 || lhs.move1 == rhs.move1)
  fieldCheck = fieldCheck && (lhs.hasMove2 == rhs.hasMove2) && (!lhs.hasMove2 || lhs.move2 == rhs.move2)
  fieldCheck = fieldCheck && (lhs.hasDeployedFortId == rhs.hasDeployedFortId) && (!lhs.hasDeployedFortId || lhs.deployedFortId == rhs.deployedFortId)
  fieldCheck = fieldCheck && (lhs.hasOwnerName == rhs.hasOwnerName) && (!lhs.hasOwnerName || lhs.ownerName == rhs.ownerName)
  fieldCheck = fieldCheck && (lhs.hasIsEgg == rhs.hasIsEgg) && (!lhs.hasIsEgg || lhs.isEgg == rhs.isEgg)
  fieldCheck = fieldCheck && (lhs.hasEggKmWalkedTarget == rhs.hasEggKmWalkedTarget) && (!lhs.hasEggKmWalkedTarget || lhs.eggKmWalkedTarget == rhs.eggKmWalkedTarget)
  fieldCheck = fieldCheck && (lhs.hasEggKmWalkedStart == rhs.hasEggKmWalkedStart) && (!lhs.hasEggKmWalkedStart || lhs.eggKmWalkedStart == rhs.eggKmWalkedStart)
  fieldCheck = fieldCheck && (lhs.hasOrigin == rhs.hasOrigin) && (!lhs.hasOrigin || lhs.origin == rhs.origin)
  fieldCheck = fieldCheck && (lhs.hasHeightM == rhs.hasHeightM) && (!lhs.hasHeightM || lhs.heightM == rhs.heightM)
  fieldCheck = fieldCheck && (lhs.hasWeightKg == rhs.hasWeightKg) && (!lhs.hasWeightKg || lhs.weightKg == rhs.weightKg)
  fieldCheck = fieldCheck && (lhs.hasIndividualAttack == rhs.hasIndividualAttack) && (!lhs.hasIndividualAttack || lhs.individualAttack == rhs.individualAttack)
  fieldCheck = fieldCheck && (lhs.hasIndividualDefense == rhs.hasIndividualDefense) && (!lhs.hasIndividualDefense || lhs.individualDefense == rhs.individualDefense)
  fieldCheck = fieldCheck && (lhs.hasIndividualStamina == rhs.hasIndividualStamina) && (!lhs.hasIndividualStamina || lhs.individualStamina == rhs.individualStamina)
  fieldCheck = fieldCheck && (lhs.hasCpMultiplier == rhs.hasCpMultiplier) && (!lhs.hasCpMultiplier || lhs.cpMultiplier == rhs.cpMultiplier)
  fieldCheck = fieldCheck && (lhs.hasPokeball == rhs.hasPokeball) && (!lhs.hasPokeball || lhs.pokeball == rhs.pokeball)
  fieldCheck = fieldCheck && (lhs.hasCapturedCellId == rhs.hasCapturedCellId) && (!lhs.hasCapturedCellId || lhs.capturedCellId == rhs.capturedCellId)
  fieldCheck = fieldCheck && (lhs.hasBattlesAttacked == rhs.hasBattlesAttacked) && (!lhs.hasBattlesAttacked || lhs.battlesAttacked == rhs.battlesAttacked)
  fieldCheck = fieldCheck && (lhs.hasBattlesDefended == rhs.hasBattlesDefended) && (!lhs.hasBattlesDefended || lhs.battlesDefended == rhs.battlesDefended)
  fieldCheck = fieldCheck && (lhs.hasEggIncubatorId == rhs.hasEggIncubatorId) && (!lhs.hasEggIncubatorId || lhs.eggIncubatorId == rhs.eggIncubatorId)
  fieldCheck = fieldCheck && (lhs.hasCreationTimeMs == rhs.hasCreationTimeMs) && (!lhs.hasCreationTimeMs || lhs.creationTimeMs == rhs.creationTimeMs)
  fieldCheck = fieldCheck && (lhs.hasNumUpgrades == rhs.hasNumUpgrades) && (!lhs.hasNumUpgrades || lhs.numUpgrades == rhs.numUpgrades)
  fieldCheck = fieldCheck && (lhs.hasAdditionalCpMultiplier == rhs.hasAdditionalCpMultiplier) && (!lhs.hasAdditionalCpMultiplier || lhs.additionalCpMultiplier == rhs.additionalCpMultiplier)
  fieldCheck = fieldCheck && (lhs.hasFavorite == rhs.hasFavorite) && (!lhs.hasFavorite || lhs.favorite == rhs.favorite)
  fieldCheck = fieldCheck && (lhs.hasNickname == rhs.hasNickname) && (!lhs.hasNickname || lhs.nickname == rhs.nickname)
  fieldCheck = fieldCheck && (lhs.hasFromFort == rhs.hasFromFort) && (!lhs.hasFromFort || lhs.fromFort == rhs.fromFort)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.Item, rhs: ResponseEnvelop.Item) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItem == rhs.hasItem) && (!lhs.hasItem || lhs.item == rhs.item)
  fieldCheck = fieldCheck && (lhs.hasCount == rhs.hasCount) && (!lhs.hasCount || lhs.count == rhs.count)
  fieldCheck = fieldCheck && (lhs.hasUnseen == rhs.hasUnseen) && (!lhs.hasUnseen || lhs.unseen == rhs.unseen)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.PokedexEntry, rhs: ResponseEnvelop.PokedexEntry) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPokedexEntryNumber == rhs.hasPokedexEntryNumber) && (!lhs.hasPokedexEntryNumber || lhs.pokedexEntryNumber == rhs.pokedexEntryNumber)
  fieldCheck = fieldCheck && (lhs.hasTimesEncountered == rhs.hasTimesEncountered) && (!lhs.hasTimesEncountered || lhs.timesEncountered == rhs.timesEncountered)
  fieldCheck = fieldCheck && (lhs.hasTimesCaptured == rhs.hasTimesCaptured) && (!lhs.hasTimesCaptured || lhs.timesCaptured == rhs.timesCaptured)
  fieldCheck = fieldCheck && (lhs.hasEvolutionStonePieces == rhs.hasEvolutionStonePieces) && (!lhs.hasEvolutionStonePieces || lhs.evolutionStonePieces == rhs.evolutionStonePieces)
  fieldCheck = fieldCheck && (lhs.hasEvolutionStones == rhs.hasEvolutionStones) && (!lhs.hasEvolutionStones || lhs.evolutionStones == rhs.evolutionStones)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.PlayerStats, rhs: ResponseEnvelop.PlayerStats) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasLevel == rhs.hasLevel) && (!lhs.hasLevel || lhs.level == rhs.level)
  fieldCheck = fieldCheck && (lhs.hasExperience == rhs.hasExperience) && (!lhs.hasExperience || lhs.experience == rhs.experience)
  fieldCheck = fieldCheck && (lhs.hasPrevLevelXp == rhs.hasPrevLevelXp) && (!lhs.hasPrevLevelXp || lhs.prevLevelXp == rhs.prevLevelXp)
  fieldCheck = fieldCheck && (lhs.hasNextLevelXp == rhs.hasNextLevelXp) && (!lhs.hasNextLevelXp || lhs.nextLevelXp == rhs.nextLevelXp)
  fieldCheck = fieldCheck && (lhs.hasKmWalked == rhs.hasKmWalked) && (!lhs.hasKmWalked || lhs.kmWalked == rhs.kmWalked)
  fieldCheck = fieldCheck && (lhs.hasPokemonsEncountered == rhs.hasPokemonsEncountered) && (!lhs.hasPokemonsEncountered || lhs.pokemonsEncountered == rhs.pokemonsEncountered)
  fieldCheck = fieldCheck && (lhs.hasUniquePokedexEntries == rhs.hasUniquePokedexEntries) && (!lhs.hasUniquePokedexEntries || lhs.uniquePokedexEntries == rhs.uniquePokedexEntries)
  fieldCheck = fieldCheck && (lhs.hasPokemonsCaptured == rhs.hasPokemonsCaptured) && (!lhs.hasPokemonsCaptured || lhs.pokemonsCaptured == rhs.pokemonsCaptured)
  fieldCheck = fieldCheck && (lhs.hasEvolutions == rhs.hasEvolutions) && (!lhs.hasEvolutions || lhs.evolutions == rhs.evolutions)
  fieldCheck = fieldCheck && (lhs.hasPokeStopVisits == rhs.hasPokeStopVisits) && (!lhs.hasPokeStopVisits || lhs.pokeStopVisits == rhs.pokeStopVisits)
  fieldCheck = fieldCheck && (lhs.hasPokeballsThrown == rhs.hasPokeballsThrown) && (!lhs.hasPokeballsThrown || lhs.pokeballsThrown == rhs.pokeballsThrown)
  fieldCheck = fieldCheck && (lhs.hasEggsHatched == rhs.hasEggsHatched) && (!lhs.hasEggsHatched || lhs.eggsHatched == rhs.eggsHatched)
  fieldCheck = fieldCheck && (lhs.hasBigMagikarpCaught == rhs.hasBigMagikarpCaught) && (!lhs.hasBigMagikarpCaught || lhs.bigMagikarpCaught == rhs.bigMagikarpCaught)
  fieldCheck = fieldCheck && (lhs.hasBattleAttackWon == rhs.hasBattleAttackWon) && (!lhs.hasBattleAttackWon || lhs.battleAttackWon == rhs.battleAttackWon)
  fieldCheck = fieldCheck && (lhs.hasBattleAttackTotal == rhs.hasBattleAttackTotal) && (!lhs.hasBattleAttackTotal || lhs.battleAttackTotal == rhs.battleAttackTotal)
  fieldCheck = fieldCheck && (lhs.hasBattleDefendedWon == rhs.hasBattleDefendedWon) && (!lhs.hasBattleDefendedWon || lhs.battleDefendedWon == rhs.battleDefendedWon)
  fieldCheck = fieldCheck && (lhs.hasBattleTrainingWon == rhs.hasBattleTrainingWon) && (!lhs.hasBattleTrainingWon || lhs.battleTrainingWon == rhs.battleTrainingWon)
  fieldCheck = fieldCheck && (lhs.hasBattleTrainingTotal == rhs.hasBattleTrainingTotal) && (!lhs.hasBattleTrainingTotal || lhs.battleTrainingTotal == rhs.battleTrainingTotal)
  fieldCheck = fieldCheck && (lhs.hasPrestigeRaisedTotal == rhs.hasPrestigeRaisedTotal) && (!lhs.hasPrestigeRaisedTotal || lhs.prestigeRaisedTotal == rhs.prestigeRaisedTotal)
  fieldCheck = fieldCheck && (lhs.hasPrestigeDroppedTotal == rhs.hasPrestigeDroppedTotal) && (!lhs.hasPrestigeDroppedTotal || lhs.prestigeDroppedTotal == rhs.prestigeDroppedTotal)
  fieldCheck = fieldCheck && (lhs.hasPokemonDeployed == rhs.hasPokemonDeployed) && (!lhs.hasPokemonDeployed || lhs.pokemonDeployed == rhs.pokemonDeployed)
  fieldCheck = fieldCheck && (lhs.hasPokemonCaughtByType == rhs.hasPokemonCaughtByType) && (!lhs.hasPokemonCaughtByType || lhs.pokemonCaughtByType == rhs.pokemonCaughtByType)
  fieldCheck = fieldCheck && (lhs.hasSmallRattataCaught == rhs.hasSmallRattataCaught) && (!lhs.hasSmallRattataCaught || lhs.smallRattataCaught == rhs.smallRattataCaught)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.PlayerCurrency, rhs: ResponseEnvelop.PlayerCurrency) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGems == rhs.hasGems) && (!lhs.hasGems || lhs.gems == rhs.gems)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.PlayerCamera, rhs: ResponseEnvelop.PlayerCamera) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasIsDefaultCamera == rhs.hasIsDefaultCamera) && (!lhs.hasIsDefaultCamera || lhs.isDefaultCamera == rhs.isDefaultCamera)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.InventoryUpgrades, rhs: ResponseEnvelop.InventoryUpgrades) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.inventoryUpgrades == rhs.inventoryUpgrades)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.InventoryUpgrade, rhs: ResponseEnvelop.InventoryUpgrade) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItem == rhs.hasItem) && (!lhs.hasItem || lhs.item == rhs.item)
  fieldCheck = fieldCheck && (lhs.hasUpgradeType == rhs.hasUpgradeType) && (!lhs.hasUpgradeType || lhs.upgradeType == rhs.upgradeType)
  fieldCheck = fieldCheck && (lhs.hasAdditionalStorage == rhs.hasAdditionalStorage) && (!lhs.hasAdditionalStorage || lhs.additionalStorage == rhs.additionalStorage)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.AppliedItems, rhs: ResponseEnvelop.AppliedItems) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItem == rhs.hasItem) && (!lhs.hasItem || lhs.item == rhs.item)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.AppliedItem, rhs: ResponseEnvelop.AppliedItem) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItemType == rhs.hasItemType) && (!lhs.hasItemType || lhs.itemType == rhs.itemType)
  fieldCheck = fieldCheck && (lhs.hasItemTypeCategory == rhs.hasItemTypeCategory) && (!lhs.hasItemTypeCategory || lhs.itemTypeCategory == rhs.itemTypeCategory)
  fieldCheck = fieldCheck && (lhs.hasExpireMs == rhs.hasExpireMs) && (!lhs.hasExpireMs || lhs.expireMs == rhs.expireMs)
  fieldCheck = fieldCheck && (lhs.hasAppliedMs == rhs.hasAppliedMs) && (!lhs.hasAppliedMs || lhs.appliedMs == rhs.appliedMs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.EggIncubators, rhs: ResponseEnvelop.EggIncubators) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEggIncubator == rhs.hasEggIncubator) && (!lhs.hasEggIncubator || lhs.eggIncubator == rhs.eggIncubator)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.EggIncubator, rhs: ResponseEnvelop.EggIncubator) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItemId == rhs.hasItemId) && (!lhs.hasItemId || lhs.itemId == rhs.itemId)
  fieldCheck = fieldCheck && (lhs.hasItemType == rhs.hasItemType) && (!lhs.hasItemType || lhs.itemType == rhs.itemType)
  fieldCheck = fieldCheck && (lhs.hasIncubatorType == rhs.hasIncubatorType) && (!lhs.hasIncubatorType || lhs.incubatorType == rhs.incubatorType)
  fieldCheck = fieldCheck && (lhs.hasUsesRemaining == rhs.hasUsesRemaining) && (!lhs.hasUsesRemaining || lhs.usesRemaining == rhs.usesRemaining)
  fieldCheck = fieldCheck && (lhs.hasPokemonId == rhs.hasPokemonId) && (!lhs.hasPokemonId || lhs.pokemonId == rhs.pokemonId)
  fieldCheck = fieldCheck && (lhs.hasStartKmWalked == rhs.hasStartKmWalked) && (!lhs.hasStartKmWalked || lhs.startKmWalked == rhs.startKmWalked)
  fieldCheck = fieldCheck && (lhs.hasTargetKmWalked == rhs.hasTargetKmWalked) && (!lhs.hasTargetKmWalked || lhs.targetKmWalked == rhs.targetKmWalked)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.PokemonFamily, rhs: ResponseEnvelop.PokemonFamily) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFamilyId == rhs.hasFamilyId) && (!lhs.hasFamilyId || lhs.familyId == rhs.familyId)
  fieldCheck = fieldCheck && (lhs.hasCandy == rhs.hasCandy) && (!lhs.hasCandy || lhs.candy == rhs.candy)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.CatchPokemonResponse, rhs: ResponseEnvelop.CatchPokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasMissPercent == rhs.hasMissPercent) && (!lhs.hasMissPercent || lhs.missPercent == rhs.missPercent)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.CaptureAward, rhs: ResponseEnvelop.CaptureAward) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.activityType == rhs.activityType)
  fieldCheck = fieldCheck && (lhs.xp == rhs.xp)
  fieldCheck = fieldCheck && (lhs.candy == rhs.candy)
  fieldCheck = fieldCheck && (lhs.stardust == rhs.stardust)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.CaptureProbability, rhs: ResponseEnvelop.CaptureProbability) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.pokeballType == rhs.pokeballType)
  fieldCheck = fieldCheck && (lhs.captureProbability == rhs.captureProbability)
  fieldCheck = fieldCheck && (lhs.hasReticleDifficultySize == rhs.hasReticleDifficultySize) && (!lhs.hasReticleDifficultySize || lhs.reticleDifficultySize == rhs.reticleDifficultySize)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.EncounterResponse, rhs: ResponseEnvelop.EncounterResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasWildPokemon == rhs.hasWildPokemon) && (!lhs.hasWildPokemon || lhs.wildPokemon == rhs.wildPokemon)
  fieldCheck = fieldCheck && (lhs.hasEncounterBackground == rhs.hasEncounterBackground) && (!lhs.hasEncounterBackground || lhs.encounterBackground == rhs.encounterBackground)
  fieldCheck = fieldCheck && (lhs.hasEncounterStatus == rhs.hasEncounterStatus) && (!lhs.hasEncounterStatus || lhs.encounterStatus == rhs.encounterStatus)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.FortSearchResponse, rhs: ResponseEnvelop.FortSearchResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.itemsAwarded == rhs.itemsAwarded)
  fieldCheck = fieldCheck && (lhs.hasGemsAwarded == rhs.hasGemsAwarded) && (!lhs.hasGemsAwarded || lhs.gemsAwarded == rhs.gemsAwarded)
  fieldCheck = fieldCheck && (lhs.hasPokemonDataEgg == rhs.hasPokemonDataEgg) && (!lhs.hasPokemonDataEgg || lhs.pokemonDataEgg == rhs.pokemonDataEgg)
  fieldCheck = fieldCheck && (lhs.hasExperienceAwarded == rhs.hasExperienceAwarded) && (!lhs.hasExperienceAwarded || lhs.experienceAwarded == rhs.experienceAwarded)
  fieldCheck = fieldCheck && (lhs.hasCooldownCompleteTimestampMs == rhs.hasCooldownCompleteTimestampMs) && (!lhs.hasCooldownCompleteTimestampMs || lhs.cooldownCompleteTimestampMs == rhs.cooldownCompleteTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasChainHackSequenceNumber == rhs.hasChainHackSequenceNumber) && (!lhs.hasChainHackSequenceNumber || lhs.chainHackSequenceNumber == rhs.chainHackSequenceNumber)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.FortDetailsResponse, rhs: ResponseEnvelop.FortDetailsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFortId == rhs.hasFortId) && (!lhs.hasFortId || lhs.fortId == rhs.fortId)
  fieldCheck = fieldCheck && (lhs.hasTeamColor == rhs.hasTeamColor) && (!lhs.hasTeamColor || lhs.teamColor == rhs.teamColor)
  fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.imageUrls == rhs.imageUrls)
  fieldCheck = fieldCheck && (lhs.hasFp == rhs.hasFp) && (!lhs.hasFp || lhs.fp == rhs.fp)
  fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
  fieldCheck = fieldCheck && (lhs.hasMaxStamina == rhs.hasMaxStamina) && (!lhs.hasMaxStamina || lhs.maxStamina == rhs.maxStamina)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
  fieldCheck = fieldCheck && (lhs.modifiers == rhs.modifiers)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.FortModifier, rhs: ResponseEnvelop.FortModifier) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItemId == rhs.hasItemId) && (!lhs.hasItemId || lhs.itemId == rhs.itemId)
  fieldCheck = fieldCheck && (lhs.hasExpirationTimestampMs == rhs.hasExpirationTimestampMs) && (!lhs.hasExpirationTimestampMs || lhs.expirationTimestampMs == rhs.expirationTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasDeployerPlayerCodename == rhs.hasDeployerPlayerCodename) && (!lhs.hasDeployerPlayerCodename || lhs.deployerPlayerCodename == rhs.deployerPlayerCodename)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.RecycleInventoryItemResponse, rhs: ResponseEnvelop.RecycleInventoryItemResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasNewCount == rhs.hasNewCount) && (!lhs.hasNewCount || lhs.newCount == rhs.newCount)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.ItemAward, rhs: ResponseEnvelop.ItemAward) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItemId == rhs.hasItemId) && (!lhs.hasItemId || lhs.itemId == rhs.itemId)
  fieldCheck = fieldCheck && (lhs.hasItemCount == rhs.hasItemCount) && (!lhs.hasItemCount || lhs.itemCount == rhs.itemCount)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.ReleasePokemonResponse, rhs: ResponseEnvelop.ReleasePokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasCandyAwarded == rhs.hasCandyAwarded) && (!lhs.hasCandyAwarded || lhs.candyAwarded == rhs.candyAwarded)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.EvolvePokemonResponse, rhs: ResponseEnvelop.EvolvePokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasEvolvedPokemon == rhs.hasEvolvedPokemon) && (!lhs.hasEvolvedPokemon || lhs.evolvedPokemon == rhs.evolvedPokemon)
  fieldCheck = fieldCheck && (lhs.hasExpAwarded == rhs.hasExpAwarded) && (!lhs.hasExpAwarded || lhs.expAwarded == rhs.expAwarded)
  fieldCheck = fieldCheck && (lhs.hasCandyAwarded == rhs.hasCandyAwarded) && (!lhs.hasCandyAwarded || lhs.candyAwarded == rhs.candyAwarded)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResponseEnvelop.TransferPokemonResponse, rhs: ResponseEnvelop.TransferPokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasCandyAwarded == rhs.hasCandyAwarded) && (!lhs.hasCandyAwarded || lhs.candyAwarded == rhs.candyAwarded)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct PokemonRoot {
  public static var sharedInstance : PokemonRoot {
   struct Static {
       static let instance : PokemonRoot = PokemonRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final public class RequestEnvelop : GeneratedMessage, GeneratedMessageProtocol {


  //Nested type declaration start

    final public class Requests : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var types:Int32 = Int32(0)

      public private(set) var hasTypes:Bool = false
      public private(set) var message_:NSData = NSData()

      public private(set) var hasMessage_:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasTypes {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasTypes {
          try output.writeInt32(1, value:types)
        }
        if hasMessage_ {
          try output.writeData(2, value:message_)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasTypes {
          serialize_size += types.computeInt32Size(1)
        }
        if hasMessage_ {
          serialize_size += message_.computeDataSize(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.Requests> {
        var mergedArray = Array<RequestEnvelop.Requests>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.Requests? {
        return try RequestEnvelop.Requests.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.Requests {
        return try RequestEnvelop.Requests.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Requests {
        return try RequestEnvelop.Requests.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.Requests {
        return try RequestEnvelop.Requests.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Requests {
        return try RequestEnvelop.Requests.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Requests {
        return try RequestEnvelop.Requests.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Requests {
        return try RequestEnvelop.Requests.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.Requests.Builder {
        return RequestEnvelop.Requests.classBuilder() as! RequestEnvelop.Requests.Builder
      }
      public func getBuilder() -> RequestEnvelop.Requests.Builder {
        return classBuilder() as! RequestEnvelop.Requests.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.Requests.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.Requests.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.Requests.Builder {
        return try RequestEnvelop.Requests.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.Requests) throws -> RequestEnvelop.Requests.Builder {
        return try RequestEnvelop.Requests.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasTypes {
          output += "\(indent) types: \(types) \n"
        }
        if hasMessage_ {
          output += "\(indent) message_: \(message_) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasTypes {
                 hashCode = (hashCode &* 31) &+ types.hashValue
              }
              if hasMessage_ {
                 hashCode = (hashCode &* 31) &+ message_.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.Requests"
      }
      override public func className() -> String {
          return "RequestEnvelop.Requests"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.Requests.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.Requests = RequestEnvelop.Requests()
        public func getMessage() -> RequestEnvelop.Requests {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasTypes:Bool {
             get {
                  return builderResult.hasTypes
             }
        }
        public var types:Int32 {
             get {
                  return builderResult.types
             }
             set (value) {
                 builderResult.hasTypes = true
                 builderResult.types = value
             }
        }
        public func setTypes(value:Int32) -> RequestEnvelop.Requests.Builder {
          self.types = value
          return self
        }
        public func clearTypes() -> RequestEnvelop.Requests.Builder{
             builderResult.hasTypes = false
             builderResult.types = Int32(0)
             return self
        }
        public var hasMessage_:Bool {
             get {
                  return builderResult.hasMessage_
             }
        }
        public var message_:NSData {
             get {
                  return builderResult.message_
             }
             set (value) {
                 builderResult.hasMessage_ = true
                 builderResult.message_ = value
             }
        }
        public func setMessage_(value:NSData) -> RequestEnvelop.Requests.Builder {
          self.message_ = value
          return self
        }
        public func clearMessage_() -> RequestEnvelop.Requests.Builder{
             builderResult.hasMessage_ = false
             builderResult.message_ = NSData()
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.Requests.Builder {
          builderResult = RequestEnvelop.Requests()
          return self
        }
        public override func clone() throws -> RequestEnvelop.Requests.Builder {
          return try RequestEnvelop.Requests.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.Requests {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.Requests {
          let returnMe:RequestEnvelop.Requests = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.Requests) throws -> RequestEnvelop.Requests.Builder {
          if other == RequestEnvelop.Requests() {
           return self
          }
          if other.hasTypes {
               types = other.types
          }
          if other.hasMessage_ {
               message_ = other.message_
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Requests.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Requests.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              types = try input.readInt32()

            case 18 :
              message_ = try input.readData()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class Unknown3 : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var unknown4:String = ""

      public private(set) var hasUnknown4:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasUnknown4 {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasUnknown4 {
          try output.writeString(1, value:unknown4)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUnknown4 {
          serialize_size += unknown4.computeStringSize(1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.Unknown3> {
        var mergedArray = Array<RequestEnvelop.Unknown3>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.Unknown3? {
        return try RequestEnvelop.Unknown3.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.Unknown3 {
        return try RequestEnvelop.Unknown3.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown3 {
        return try RequestEnvelop.Unknown3.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.Unknown3 {
        return try RequestEnvelop.Unknown3.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown3 {
        return try RequestEnvelop.Unknown3.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Unknown3 {
        return try RequestEnvelop.Unknown3.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown3 {
        return try RequestEnvelop.Unknown3.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.Unknown3.Builder {
        return RequestEnvelop.Unknown3.classBuilder() as! RequestEnvelop.Unknown3.Builder
      }
      public func getBuilder() -> RequestEnvelop.Unknown3.Builder {
        return classBuilder() as! RequestEnvelop.Unknown3.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.Unknown3.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.Unknown3.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.Unknown3.Builder {
        return try RequestEnvelop.Unknown3.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.Unknown3) throws -> RequestEnvelop.Unknown3.Builder {
        return try RequestEnvelop.Unknown3.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasUnknown4 {
          output += "\(indent) unknown4: \(unknown4) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasUnknown4 {
                 hashCode = (hashCode &* 31) &+ unknown4.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.Unknown3"
      }
      override public func className() -> String {
          return "RequestEnvelop.Unknown3"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.Unknown3.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.Unknown3 = RequestEnvelop.Unknown3()
        public func getMessage() -> RequestEnvelop.Unknown3 {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasUnknown4:Bool {
             get {
                  return builderResult.hasUnknown4
             }
        }
        public var unknown4:String {
             get {
                  return builderResult.unknown4
             }
             set (value) {
                 builderResult.hasUnknown4 = true
                 builderResult.unknown4 = value
             }
        }
        public func setUnknown4(value:String) -> RequestEnvelop.Unknown3.Builder {
          self.unknown4 = value
          return self
        }
        public func clearUnknown4() -> RequestEnvelop.Unknown3.Builder{
             builderResult.hasUnknown4 = false
             builderResult.unknown4 = ""
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.Unknown3.Builder {
          builderResult = RequestEnvelop.Unknown3()
          return self
        }
        public override func clone() throws -> RequestEnvelop.Unknown3.Builder {
          return try RequestEnvelop.Unknown3.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.Unknown3 {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.Unknown3 {
          let returnMe:RequestEnvelop.Unknown3 = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.Unknown3) throws -> RequestEnvelop.Unknown3.Builder {
          if other == RequestEnvelop.Unknown3() {
           return self
          }
          if other.hasUnknown4 {
               unknown4 = other.unknown4
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Unknown3.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown3.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              unknown4 = try input.readString()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class Unknown6 : GeneratedMessage, GeneratedMessageProtocol {


      //Nested type declaration start

        final public class Unknown2 : GeneratedMessage, GeneratedMessageProtocol {
          public private(set) var unknown1:NSData = NSData()

          public private(set) var hasUnknown1:Bool = false
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
            if !hasUnknown1 {
              return false
            }
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
            if hasUnknown1 {
              try output.writeData(1, value:unknown1)
            }
            try unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUnknown1 {
              serialize_size += unknown1.computeDataSize(1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
          }
          public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.Unknown6.Unknown2> {
            var mergedArray = Array<RequestEnvelop.Unknown6.Unknown2>()
            while let value = try parseFromDelimitedFromInputStream(input) {
              mergedArray += [value]
            }
            return mergedArray
          }
          public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.Unknown6.Unknown2? {
            return try RequestEnvelop.Unknown6.Unknown2.Builder().mergeDelimitedFromInputStream(input)?.build()
          }
          public class func parseFromData(data:NSData) throws -> RequestEnvelop.Unknown6.Unknown2 {
            return try RequestEnvelop.Unknown6.Unknown2.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
          }
          public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown6.Unknown2 {
            return try RequestEnvelop.Unknown6.Unknown2.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.Unknown6.Unknown2 {
            return try RequestEnvelop.Unknown6.Unknown2.Builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown6.Unknown2 {
            return try RequestEnvelop.Unknown6.Unknown2.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Unknown6.Unknown2 {
            return try RequestEnvelop.Unknown6.Unknown2.Builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown6.Unknown2 {
            return try RequestEnvelop.Unknown6.Unknown2.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func getBuilder() -> RequestEnvelop.Unknown6.Unknown2.Builder {
            return RequestEnvelop.Unknown6.Unknown2.classBuilder() as! RequestEnvelop.Unknown6.Unknown2.Builder
          }
          public func getBuilder() -> RequestEnvelop.Unknown6.Unknown2.Builder {
            return classBuilder() as! RequestEnvelop.Unknown6.Unknown2.Builder
          }
          public override class func classBuilder() -> MessageBuilder {
            return RequestEnvelop.Unknown6.Unknown2.Builder()
          }
          public override func classBuilder() -> MessageBuilder {
            return RequestEnvelop.Unknown6.Unknown2.Builder()
          }
          public func toBuilder() throws -> RequestEnvelop.Unknown6.Unknown2.Builder {
            return try RequestEnvelop.Unknown6.Unknown2.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:RequestEnvelop.Unknown6.Unknown2) throws -> RequestEnvelop.Unknown6.Unknown2.Builder {
            return try RequestEnvelop.Unknown6.Unknown2.Builder().mergeFrom(prototype)
          }
          override public func getDescription(indent:String) throws -> String {
            var output:String = ""
            if hasUnknown1 {
              output += "\(indent) unknown1: \(unknown1) \n"
            }
            output += unknownFields.getDescription(indent)
            return output
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasUnknown1 {
                     hashCode = (hashCode &* 31) &+ unknown1.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "RequestEnvelop.Unknown6.Unknown2"
          }
          override public func className() -> String {
              return "RequestEnvelop.Unknown6.Unknown2"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return RequestEnvelop.Unknown6.Unknown2.self
          }
          //Meta information declaration end

          final public class Builder : GeneratedMessageBuilder {
            private var builderResult:RequestEnvelop.Unknown6.Unknown2 = RequestEnvelop.Unknown6.Unknown2()
            public func getMessage() -> RequestEnvelop.Unknown6.Unknown2 {
                return builderResult
            }

            required override public init () {
               super.init()
            }
            public var hasUnknown1:Bool {
                 get {
                      return builderResult.hasUnknown1
                 }
            }
            public var unknown1:NSData {
                 get {
                      return builderResult.unknown1
                 }
                 set (value) {
                     builderResult.hasUnknown1 = true
                     builderResult.unknown1 = value
                 }
            }
            public func setUnknown1(value:NSData) -> RequestEnvelop.Unknown6.Unknown2.Builder {
              self.unknown1 = value
              return self
            }
            public func clearUnknown1() -> RequestEnvelop.Unknown6.Unknown2.Builder{
                 builderResult.hasUnknown1 = false
                 builderResult.unknown1 = NSData()
                 return self
            }
            override public var internalGetResult:GeneratedMessage {
                 get {
                    return builderResult
                 }
            }
            public override func clear() -> RequestEnvelop.Unknown6.Unknown2.Builder {
              builderResult = RequestEnvelop.Unknown6.Unknown2()
              return self
            }
            public override func clone() throws -> RequestEnvelop.Unknown6.Unknown2.Builder {
              return try RequestEnvelop.Unknown6.Unknown2.builderWithPrototype(builderResult)
            }
            public override func build() throws -> RequestEnvelop.Unknown6.Unknown2 {
                 try checkInitialized()
                 return buildPartial()
            }
            public func buildPartial() -> RequestEnvelop.Unknown6.Unknown2 {
              let returnMe:RequestEnvelop.Unknown6.Unknown2 = builderResult
              return returnMe
            }
            public func mergeFrom(other:RequestEnvelop.Unknown6.Unknown2) throws -> RequestEnvelop.Unknown6.Unknown2.Builder {
              if other == RequestEnvelop.Unknown6.Unknown2() {
               return self
              }
              if other.hasUnknown1 {
                   unknown1 = other.unknown1
              }
              try mergeUnknownFields(other.unknownFields)
              return self
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Unknown6.Unknown2.Builder {
                 return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown6.Unknown2.Builder {
              let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
              while (true) {
                let protobufTag = try input.readTag()
                switch protobufTag {
                case 0: 
                  self.unknownFields = try unknownFieldsBuilder.build()
                  return self

                case 10 :
                  unknown1 = try input.readData()

                default:
                  if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                     unknownFields = try unknownFieldsBuilder.build()
                     return self
                  }
                }
              }
            }
          }

        }

      //Nested type declaration end

      public private(set) var unknown1:Int32 = Int32(0)

      public private(set) var hasUnknown1:Bool = false
      public private(set) var unknown2:RequestEnvelop.Unknown6.Unknown2!
      public private(set) var hasUnknown2:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasUnknown1 {
          return false
        }
        if !hasUnknown2 {
          return false
        }
        if !unknown2.isInitialized() {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasUnknown1 {
          try output.writeInt32(1, value:unknown1)
        }
        if hasUnknown2 {
          try output.writeMessage(2, value:unknown2)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUnknown1 {
          serialize_size += unknown1.computeInt32Size(1)
        }
        if hasUnknown2 {
            if let varSizeunknown2 = unknown2?.computeMessageSize(2) {
                serialize_size += varSizeunknown2
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.Unknown6> {
        var mergedArray = Array<RequestEnvelop.Unknown6>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.Unknown6? {
        return try RequestEnvelop.Unknown6.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.Unknown6 {
        return try RequestEnvelop.Unknown6.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown6 {
        return try RequestEnvelop.Unknown6.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.Unknown6 {
        return try RequestEnvelop.Unknown6.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown6 {
        return try RequestEnvelop.Unknown6.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Unknown6 {
        return try RequestEnvelop.Unknown6.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown6 {
        return try RequestEnvelop.Unknown6.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.Unknown6.Builder {
        return RequestEnvelop.Unknown6.classBuilder() as! RequestEnvelop.Unknown6.Builder
      }
      public func getBuilder() -> RequestEnvelop.Unknown6.Builder {
        return classBuilder() as! RequestEnvelop.Unknown6.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.Unknown6.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.Unknown6.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.Unknown6.Builder {
        return try RequestEnvelop.Unknown6.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.Unknown6) throws -> RequestEnvelop.Unknown6.Builder {
        return try RequestEnvelop.Unknown6.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasUnknown1 {
          output += "\(indent) unknown1: \(unknown1) \n"
        }
        if hasUnknown2 {
          output += "\(indent) unknown2 {\n"
          if let outDescUnknown2 = unknown2 {
            output += try outDescUnknown2.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasUnknown1 {
                 hashCode = (hashCode &* 31) &+ unknown1.hashValue
              }
              if hasUnknown2 {
                  if let hashValueunknown2 = unknown2?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueunknown2
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.Unknown6"
      }
      override public func className() -> String {
          return "RequestEnvelop.Unknown6"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.Unknown6.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.Unknown6 = RequestEnvelop.Unknown6()
        public func getMessage() -> RequestEnvelop.Unknown6 {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasUnknown1:Bool {
             get {
                  return builderResult.hasUnknown1
             }
        }
        public var unknown1:Int32 {
             get {
                  return builderResult.unknown1
             }
             set (value) {
                 builderResult.hasUnknown1 = true
                 builderResult.unknown1 = value
             }
        }
        public func setUnknown1(value:Int32) -> RequestEnvelop.Unknown6.Builder {
          self.unknown1 = value
          return self
        }
        public func clearUnknown1() -> RequestEnvelop.Unknown6.Builder{
             builderResult.hasUnknown1 = false
             builderResult.unknown1 = Int32(0)
             return self
        }
        public var hasUnknown2:Bool {
             get {
                 return builderResult.hasUnknown2
             }
        }
        public var unknown2:RequestEnvelop.Unknown6.Unknown2! {
             get {
                 if unknown2Builder_ != nil {
                    builderResult.unknown2 = unknown2Builder_.getMessage()
                 }
                 return builderResult.unknown2
             }
             set (value) {
                 builderResult.hasUnknown2 = true
                 builderResult.unknown2 = value
             }
        }
        private var unknown2Builder_:RequestEnvelop.Unknown6.Unknown2.Builder! {
             didSet {
                builderResult.hasUnknown2 = true
             }
        }
        public func getUnknown2Builder() -> RequestEnvelop.Unknown6.Unknown2.Builder {
          if unknown2Builder_ == nil {
             unknown2Builder_ = RequestEnvelop.Unknown6.Unknown2.Builder()
             builderResult.unknown2 = unknown2Builder_.getMessage()
             if unknown2 != nil {
                try! unknown2Builder_.mergeFrom(unknown2)
             }
          }
          return unknown2Builder_
        }
        public func setUnknown2(value:RequestEnvelop.Unknown6.Unknown2!) -> RequestEnvelop.Unknown6.Builder {
          self.unknown2 = value
          return self
        }
        public func mergeUnknown2(value:RequestEnvelop.Unknown6.Unknown2) throws -> RequestEnvelop.Unknown6.Builder {
          if builderResult.hasUnknown2 {
            builderResult.unknown2 = try RequestEnvelop.Unknown6.Unknown2.builderWithPrototype(builderResult.unknown2).mergeFrom(value).buildPartial()
          } else {
            builderResult.unknown2 = value
          }
          builderResult.hasUnknown2 = true
          return self
        }
        public func clearUnknown2() -> RequestEnvelop.Unknown6.Builder {
          unknown2Builder_ = nil
          builderResult.hasUnknown2 = false
          builderResult.unknown2 = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.Unknown6.Builder {
          builderResult = RequestEnvelop.Unknown6()
          return self
        }
        public override func clone() throws -> RequestEnvelop.Unknown6.Builder {
          return try RequestEnvelop.Unknown6.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.Unknown6 {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.Unknown6 {
          let returnMe:RequestEnvelop.Unknown6 = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.Unknown6) throws -> RequestEnvelop.Unknown6.Builder {
          if other == RequestEnvelop.Unknown6() {
           return self
          }
          if other.hasUnknown1 {
               unknown1 = other.unknown1
          }
          if (other.hasUnknown2) {
              try mergeUnknown2(other.unknown2)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Unknown6.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Unknown6.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              unknown1 = try input.readInt32()

            case 18 :
              let subBuilder:RequestEnvelop.Unknown6.Unknown2.Builder = RequestEnvelop.Unknown6.Unknown2.Builder()
              if hasUnknown2 {
                try subBuilder.mergeFrom(unknown2)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              unknown2 = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class AuthInfo : GeneratedMessage, GeneratedMessageProtocol {


      //Nested type declaration start

        final public class Jwt : GeneratedMessage, GeneratedMessageProtocol {
          public private(set) var contents:String = ""

          public private(set) var hasContents:Bool = false
          public private(set) var unknown13:Int32 = Int32(0)

          public private(set) var hasUnknown13:Bool = false
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
            if !hasContents {
              return false
            }
            if !hasUnknown13 {
              return false
            }
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
            if hasContents {
              try output.writeString(1, value:contents)
            }
            if hasUnknown13 {
              try output.writeInt32(2, value:unknown13)
            }
            try unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasContents {
              serialize_size += contents.computeStringSize(1)
            }
            if hasUnknown13 {
              serialize_size += unknown13.computeInt32Size(2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
          }
          public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.AuthInfo.Jwt> {
            var mergedArray = Array<RequestEnvelop.AuthInfo.Jwt>()
            while let value = try parseFromDelimitedFromInputStream(input) {
              mergedArray += [value]
            }
            return mergedArray
          }
          public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.AuthInfo.Jwt? {
            return try RequestEnvelop.AuthInfo.Jwt.Builder().mergeDelimitedFromInputStream(input)?.build()
          }
          public class func parseFromData(data:NSData) throws -> RequestEnvelop.AuthInfo.Jwt {
            return try RequestEnvelop.AuthInfo.Jwt.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
          }
          public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.AuthInfo.Jwt {
            return try RequestEnvelop.AuthInfo.Jwt.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.AuthInfo.Jwt {
            return try RequestEnvelop.AuthInfo.Jwt.Builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.AuthInfo.Jwt {
            return try RequestEnvelop.AuthInfo.Jwt.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.AuthInfo.Jwt {
            return try RequestEnvelop.AuthInfo.Jwt.Builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.AuthInfo.Jwt {
            return try RequestEnvelop.AuthInfo.Jwt.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func getBuilder() -> RequestEnvelop.AuthInfo.Jwt.Builder {
            return RequestEnvelop.AuthInfo.Jwt.classBuilder() as! RequestEnvelop.AuthInfo.Jwt.Builder
          }
          public func getBuilder() -> RequestEnvelop.AuthInfo.Jwt.Builder {
            return classBuilder() as! RequestEnvelop.AuthInfo.Jwt.Builder
          }
          public override class func classBuilder() -> MessageBuilder {
            return RequestEnvelop.AuthInfo.Jwt.Builder()
          }
          public override func classBuilder() -> MessageBuilder {
            return RequestEnvelop.AuthInfo.Jwt.Builder()
          }
          public func toBuilder() throws -> RequestEnvelop.AuthInfo.Jwt.Builder {
            return try RequestEnvelop.AuthInfo.Jwt.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:RequestEnvelop.AuthInfo.Jwt) throws -> RequestEnvelop.AuthInfo.Jwt.Builder {
            return try RequestEnvelop.AuthInfo.Jwt.Builder().mergeFrom(prototype)
          }
          override public func getDescription(indent:String) throws -> String {
            var output:String = ""
            if hasContents {
              output += "\(indent) contents: \(contents) \n"
            }
            if hasUnknown13 {
              output += "\(indent) unknown13: \(unknown13) \n"
            }
            output += unknownFields.getDescription(indent)
            return output
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasContents {
                     hashCode = (hashCode &* 31) &+ contents.hashValue
                  }
                  if hasUnknown13 {
                     hashCode = (hashCode &* 31) &+ unknown13.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "RequestEnvelop.AuthInfo.Jwt"
          }
          override public func className() -> String {
              return "RequestEnvelop.AuthInfo.Jwt"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return RequestEnvelop.AuthInfo.Jwt.self
          }
          //Meta information declaration end

          final public class Builder : GeneratedMessageBuilder {
            private var builderResult:RequestEnvelop.AuthInfo.Jwt = RequestEnvelop.AuthInfo.Jwt()
            public func getMessage() -> RequestEnvelop.AuthInfo.Jwt {
                return builderResult
            }

            required override public init () {
               super.init()
            }
            public var hasContents:Bool {
                 get {
                      return builderResult.hasContents
                 }
            }
            public var contents:String {
                 get {
                      return builderResult.contents
                 }
                 set (value) {
                     builderResult.hasContents = true
                     builderResult.contents = value
                 }
            }
            public func setContents(value:String) -> RequestEnvelop.AuthInfo.Jwt.Builder {
              self.contents = value
              return self
            }
            public func clearContents() -> RequestEnvelop.AuthInfo.Jwt.Builder{
                 builderResult.hasContents = false
                 builderResult.contents = ""
                 return self
            }
            public var hasUnknown13:Bool {
                 get {
                      return builderResult.hasUnknown13
                 }
            }
            public var unknown13:Int32 {
                 get {
                      return builderResult.unknown13
                 }
                 set (value) {
                     builderResult.hasUnknown13 = true
                     builderResult.unknown13 = value
                 }
            }
            public func setUnknown13(value:Int32) -> RequestEnvelop.AuthInfo.Jwt.Builder {
              self.unknown13 = value
              return self
            }
            public func clearUnknown13() -> RequestEnvelop.AuthInfo.Jwt.Builder{
                 builderResult.hasUnknown13 = false
                 builderResult.unknown13 = Int32(0)
                 return self
            }
            override public var internalGetResult:GeneratedMessage {
                 get {
                    return builderResult
                 }
            }
            public override func clear() -> RequestEnvelop.AuthInfo.Jwt.Builder {
              builderResult = RequestEnvelop.AuthInfo.Jwt()
              return self
            }
            public override func clone() throws -> RequestEnvelop.AuthInfo.Jwt.Builder {
              return try RequestEnvelop.AuthInfo.Jwt.builderWithPrototype(builderResult)
            }
            public override func build() throws -> RequestEnvelop.AuthInfo.Jwt {
                 try checkInitialized()
                 return buildPartial()
            }
            public func buildPartial() -> RequestEnvelop.AuthInfo.Jwt {
              let returnMe:RequestEnvelop.AuthInfo.Jwt = builderResult
              return returnMe
            }
            public func mergeFrom(other:RequestEnvelop.AuthInfo.Jwt) throws -> RequestEnvelop.AuthInfo.Jwt.Builder {
              if other == RequestEnvelop.AuthInfo.Jwt() {
               return self
              }
              if other.hasContents {
                   contents = other.contents
              }
              if other.hasUnknown13 {
                   unknown13 = other.unknown13
              }
              try mergeUnknownFields(other.unknownFields)
              return self
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.AuthInfo.Jwt.Builder {
                 return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.AuthInfo.Jwt.Builder {
              let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
              while (true) {
                let protobufTag = try input.readTag()
                switch protobufTag {
                case 0: 
                  self.unknownFields = try unknownFieldsBuilder.build()
                  return self

                case 10 :
                  contents = try input.readString()

                case 16 :
                  unknown13 = try input.readInt32()

                default:
                  if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                     unknownFields = try unknownFieldsBuilder.build()
                     return self
                  }
                }
              }
            }
          }

        }

      //Nested type declaration end

      public private(set) var provider:String = ""

      public private(set) var hasProvider:Bool = false
      public private(set) var token:RequestEnvelop.AuthInfo.Jwt!
      public private(set) var hasToken:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasProvider {
          return false
        }
        if !hasToken {
          return false
        }
        if !token.isInitialized() {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasProvider {
          try output.writeString(1, value:provider)
        }
        if hasToken {
          try output.writeMessage(2, value:token)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasProvider {
          serialize_size += provider.computeStringSize(1)
        }
        if hasToken {
            if let varSizetoken = token?.computeMessageSize(2) {
                serialize_size += varSizetoken
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.AuthInfo> {
        var mergedArray = Array<RequestEnvelop.AuthInfo>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.AuthInfo? {
        return try RequestEnvelop.AuthInfo.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.AuthInfo {
        return try RequestEnvelop.AuthInfo.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.AuthInfo {
        return try RequestEnvelop.AuthInfo.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.AuthInfo {
        return try RequestEnvelop.AuthInfo.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.AuthInfo {
        return try RequestEnvelop.AuthInfo.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.AuthInfo {
        return try RequestEnvelop.AuthInfo.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.AuthInfo {
        return try RequestEnvelop.AuthInfo.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.AuthInfo.Builder {
        return RequestEnvelop.AuthInfo.classBuilder() as! RequestEnvelop.AuthInfo.Builder
      }
      public func getBuilder() -> RequestEnvelop.AuthInfo.Builder {
        return classBuilder() as! RequestEnvelop.AuthInfo.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.AuthInfo.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.AuthInfo.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.AuthInfo.Builder {
        return try RequestEnvelop.AuthInfo.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.AuthInfo) throws -> RequestEnvelop.AuthInfo.Builder {
        return try RequestEnvelop.AuthInfo.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasProvider {
          output += "\(indent) provider: \(provider) \n"
        }
        if hasToken {
          output += "\(indent) token {\n"
          if let outDescToken = token {
            output += try outDescToken.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasProvider {
                 hashCode = (hashCode &* 31) &+ provider.hashValue
              }
              if hasToken {
                  if let hashValuetoken = token?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuetoken
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.AuthInfo"
      }
      override public func className() -> String {
          return "RequestEnvelop.AuthInfo"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.AuthInfo.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.AuthInfo = RequestEnvelop.AuthInfo()
        public func getMessage() -> RequestEnvelop.AuthInfo {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasProvider:Bool {
             get {
                  return builderResult.hasProvider
             }
        }
        public var provider:String {
             get {
                  return builderResult.provider
             }
             set (value) {
                 builderResult.hasProvider = true
                 builderResult.provider = value
             }
        }
        public func setProvider(value:String) -> RequestEnvelop.AuthInfo.Builder {
          self.provider = value
          return self
        }
        public func clearProvider() -> RequestEnvelop.AuthInfo.Builder{
             builderResult.hasProvider = false
             builderResult.provider = ""
             return self
        }
        public var hasToken:Bool {
             get {
                 return builderResult.hasToken
             }
        }
        public var token:RequestEnvelop.AuthInfo.Jwt! {
             get {
                 if tokenBuilder_ != nil {
                    builderResult.token = tokenBuilder_.getMessage()
                 }
                 return builderResult.token
             }
             set (value) {
                 builderResult.hasToken = true
                 builderResult.token = value
             }
        }
        private var tokenBuilder_:RequestEnvelop.AuthInfo.Jwt.Builder! {
             didSet {
                builderResult.hasToken = true
             }
        }
        public func getTokenBuilder() -> RequestEnvelop.AuthInfo.Jwt.Builder {
          if tokenBuilder_ == nil {
             tokenBuilder_ = RequestEnvelop.AuthInfo.Jwt.Builder()
             builderResult.token = tokenBuilder_.getMessage()
             if token != nil {
                try! tokenBuilder_.mergeFrom(token)
             }
          }
          return tokenBuilder_
        }
        public func setToken(value:RequestEnvelop.AuthInfo.Jwt!) -> RequestEnvelop.AuthInfo.Builder {
          self.token = value
          return self
        }
        public func mergeToken(value:RequestEnvelop.AuthInfo.Jwt) throws -> RequestEnvelop.AuthInfo.Builder {
          if builderResult.hasToken {
            builderResult.token = try RequestEnvelop.AuthInfo.Jwt.builderWithPrototype(builderResult.token).mergeFrom(value).buildPartial()
          } else {
            builderResult.token = value
          }
          builderResult.hasToken = true
          return self
        }
        public func clearToken() -> RequestEnvelop.AuthInfo.Builder {
          tokenBuilder_ = nil
          builderResult.hasToken = false
          builderResult.token = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.AuthInfo.Builder {
          builderResult = RequestEnvelop.AuthInfo()
          return self
        }
        public override func clone() throws -> RequestEnvelop.AuthInfo.Builder {
          return try RequestEnvelop.AuthInfo.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.AuthInfo {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.AuthInfo {
          let returnMe:RequestEnvelop.AuthInfo = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.AuthInfo) throws -> RequestEnvelop.AuthInfo.Builder {
          if other == RequestEnvelop.AuthInfo() {
           return self
          }
          if other.hasProvider {
               provider = other.provider
          }
          if (other.hasToken) {
              try mergeToken(other.token)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.AuthInfo.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.AuthInfo.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              provider = try input.readString()

            case 18 :
              let subBuilder:RequestEnvelop.AuthInfo.Jwt.Builder = RequestEnvelop.AuthInfo.Jwt.Builder()
              if hasToken {
                try subBuilder.mergeFrom(token)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              token = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class MessageQuad : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var f1:Array<UInt64> = Array<UInt64>()
      private var f1MemoizedSerializedSize:Int32 = -1
      public private(set) var f2:Array<Int64> = Array<Int64>()
      private var f2MemoizedSerializedSize:Int32 = -1
      public private(set) var lat:Double = Double(0)

      public private(set) var hasLat:Bool = false
      public private(set) var long:Double = Double(0)

      public private(set) var hasLong:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasLat {
          return false
        }
        if !hasLong {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if !f1.isEmpty {
          try output.writeRawVarint32(10)
          try output.writeRawVarint32(f1MemoizedSerializedSize)
          for oneValuef1 in f1 {
            try output.writeUInt64NoTag(oneValuef1)
          }
        }
        if !f2.isEmpty {
          try output.writeRawVarint32(18)
          try output.writeRawVarint32(f2MemoizedSerializedSize)
          for oneValuef2 in f2 {
            try output.writeInt64NoTag(oneValuef2)
          }
        }
        if hasLat {
          try output.writeDouble(3, value:lat)
        }
        if hasLong {
          try output.writeDouble(4, value:long)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        var dataSizeF1:Int32 = 0
        for oneValuef1 in f1 {
            dataSizeF1 += oneValuef1.computeUInt64SizeNoTag()
        }
        serialize_size += dataSizeF1
        if !f1.isEmpty {
          serialize_size += 1
          serialize_size += dataSizeF1.computeInt32SizeNoTag()
        }
        f1MemoizedSerializedSize = dataSizeF1
        var dataSizeF2:Int32 = 0
        for oneValuef2 in f2 {
            dataSizeF2 += oneValuef2.computeInt64SizeNoTag()
        }
        serialize_size += dataSizeF2
        if !f2.isEmpty {
          serialize_size += 1
          serialize_size += dataSizeF2.computeInt32SizeNoTag()
        }
        f2MemoizedSerializedSize = dataSizeF2
        if hasLat {
          serialize_size += lat.computeDoubleSize(3)
        }
        if hasLong {
          serialize_size += long.computeDoubleSize(4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.MessageQuad> {
        var mergedArray = Array<RequestEnvelop.MessageQuad>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.MessageQuad? {
        return try RequestEnvelop.MessageQuad.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.MessageQuad {
        return try RequestEnvelop.MessageQuad.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.MessageQuad {
        return try RequestEnvelop.MessageQuad.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.MessageQuad {
        return try RequestEnvelop.MessageQuad.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.MessageQuad {
        return try RequestEnvelop.MessageQuad.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.MessageQuad {
        return try RequestEnvelop.MessageQuad.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.MessageQuad {
        return try RequestEnvelop.MessageQuad.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.MessageQuad.Builder {
        return RequestEnvelop.MessageQuad.classBuilder() as! RequestEnvelop.MessageQuad.Builder
      }
      public func getBuilder() -> RequestEnvelop.MessageQuad.Builder {
        return classBuilder() as! RequestEnvelop.MessageQuad.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.MessageQuad.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.MessageQuad.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.MessageQuad.Builder {
        return try RequestEnvelop.MessageQuad.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.MessageQuad) throws -> RequestEnvelop.MessageQuad.Builder {
        return try RequestEnvelop.MessageQuad.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        var f1ElementIndex:Int = 0
        for oneValuef1 in f1  {
            output += "\(indent) f1[\(f1ElementIndex)]: \(oneValuef1)\n"
            f1ElementIndex += 1
        }
        var f2ElementIndex:Int = 0
        for oneValuef2 in f2  {
            output += "\(indent) f2[\(f2ElementIndex)]: \(oneValuef2)\n"
            f2ElementIndex += 1
        }
        if hasLat {
          output += "\(indent) lat: \(lat) \n"
        }
        if hasLong {
          output += "\(indent) long: \(long) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for oneValuef1 in f1 {
                  hashCode = (hashCode &* 31) &+ oneValuef1.hashValue
              }
              for oneValuef2 in f2 {
                  hashCode = (hashCode &* 31) &+ oneValuef2.hashValue
              }
              if hasLat {
                 hashCode = (hashCode &* 31) &+ lat.hashValue
              }
              if hasLong {
                 hashCode = (hashCode &* 31) &+ long.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.MessageQuad"
      }
      override public func className() -> String {
          return "RequestEnvelop.MessageQuad"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.MessageQuad.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.MessageQuad = RequestEnvelop.MessageQuad()
        public func getMessage() -> RequestEnvelop.MessageQuad {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var f1:Array<UInt64> {
             get {
                 return builderResult.f1
             }
             set (array) {
                 builderResult.f1 = array
             }
        }
        public func setF1(value:Array<UInt64>) -> RequestEnvelop.MessageQuad.Builder {
          self.f1 = value
          return self
        }
        public func clearF1() -> RequestEnvelop.MessageQuad.Builder {
           builderResult.f1.removeAll(keepCapacity: false)
           return self
        }
        public var f2:Array<Int64> {
             get {
                 return builderResult.f2
             }
             set (array) {
                 builderResult.f2 = array
             }
        }
        public func setF2(value:Array<Int64>) -> RequestEnvelop.MessageQuad.Builder {
          self.f2 = value
          return self
        }
        public func clearF2() -> RequestEnvelop.MessageQuad.Builder {
           builderResult.f2.removeAll(keepCapacity: false)
           return self
        }
        public var hasLat:Bool {
             get {
                  return builderResult.hasLat
             }
        }
        public var lat:Double {
             get {
                  return builderResult.lat
             }
             set (value) {
                 builderResult.hasLat = true
                 builderResult.lat = value
             }
        }
        public func setLat(value:Double) -> RequestEnvelop.MessageQuad.Builder {
          self.lat = value
          return self
        }
        public func clearLat() -> RequestEnvelop.MessageQuad.Builder{
             builderResult.hasLat = false
             builderResult.lat = Double(0)
             return self
        }
        public var hasLong:Bool {
             get {
                  return builderResult.hasLong
             }
        }
        public var long:Double {
             get {
                  return builderResult.long
             }
             set (value) {
                 builderResult.hasLong = true
                 builderResult.long = value
             }
        }
        public func setLong(value:Double) -> RequestEnvelop.MessageQuad.Builder {
          self.long = value
          return self
        }
        public func clearLong() -> RequestEnvelop.MessageQuad.Builder{
             builderResult.hasLong = false
             builderResult.long = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.MessageQuad.Builder {
          builderResult = RequestEnvelop.MessageQuad()
          return self
        }
        public override func clone() throws -> RequestEnvelop.MessageQuad.Builder {
          return try RequestEnvelop.MessageQuad.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.MessageQuad {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.MessageQuad {
          let returnMe:RequestEnvelop.MessageQuad = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.MessageQuad) throws -> RequestEnvelop.MessageQuad.Builder {
          if other == RequestEnvelop.MessageQuad() {
           return self
          }
          if !other.f1.isEmpty {
              builderResult.f1 += other.f1
          }
          if !other.f2.isEmpty {
              builderResult.f2 += other.f2
          }
          if other.hasLat {
               lat = other.lat
          }
          if other.hasLong {
               long = other.long
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.MessageQuad.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.MessageQuad.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              let length:Int32 = try input.readRawVarint32()
              let limit:Int32 = try input.pushLimit(length)
              while (input.bytesUntilLimit() > 0) {
                builderResult.f1 += [try input.readUInt64()]
              }
              input.popLimit(limit)

            case 18 :
              let length:Int32 = try input.readRawVarint32()
              let limit:Int32 = try input.pushLimit(length)
              while (input.bytesUntilLimit() > 0) {
                builderResult.f2 += [try input.readInt64()]
              }
              input.popLimit(limit)

            case 25 :
              lat = try input.readDouble()

            case 33 :
              long = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class CatchPokemonMessage : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var encounterId:UInt64 = UInt64(0)

      public private(set) var hasEncounterId:Bool = false
      public private(set) var pokeball:Int32 = Int32(0)

      public private(set) var hasPokeball:Bool = false
      public private(set) var normalizedReticleSize:Double = Double(0)

      public private(set) var hasNormalizedReticleSize:Bool = false
      public private(set) var spawnpointId:String = ""

      public private(set) var hasSpawnpointId:Bool = false
      public private(set) var hitPokemon:Bool = false

      public private(set) var hasHitPokemon:Bool = false
      public private(set) var spinModifier:Double = Double(0)

      public private(set) var hasSpinModifier:Bool = false
      public private(set) var normalizedHitPosition:Double = Double(0)

      public private(set) var hasNormalizedHitPosition:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasEncounterId {
          return false
        }
        if !hasPokeball {
          return false
        }
        if !hasNormalizedReticleSize {
          return false
        }
        if !hasSpawnpointId {
          return false
        }
        if !hasHitPokemon {
          return false
        }
        if !hasSpinModifier {
          return false
        }
        if !hasNormalizedHitPosition {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasEncounterId {
          try output.writeFixed64(1, value:encounterId)
        }
        if hasPokeball {
          try output.writeInt32(2, value:pokeball)
        }
        if hasNormalizedReticleSize {
          try output.writeDouble(3, value:normalizedReticleSize)
        }
        if hasSpawnpointId {
          try output.writeString(4, value:spawnpointId)
        }
        if hasHitPokemon {
          try output.writeBool(5, value:hitPokemon)
        }
        if hasSpinModifier {
          try output.writeDouble(6, value:spinModifier)
        }
        if hasNormalizedHitPosition {
          try output.writeDouble(7, value:normalizedHitPosition)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasEncounterId {
          serialize_size += encounterId.computeFixed64Size(1)
        }
        if hasPokeball {
          serialize_size += pokeball.computeInt32Size(2)
        }
        if hasNormalizedReticleSize {
          serialize_size += normalizedReticleSize.computeDoubleSize(3)
        }
        if hasSpawnpointId {
          serialize_size += spawnpointId.computeStringSize(4)
        }
        if hasHitPokemon {
          serialize_size += hitPokemon.computeBoolSize(5)
        }
        if hasSpinModifier {
          serialize_size += spinModifier.computeDoubleSize(6)
        }
        if hasNormalizedHitPosition {
          serialize_size += normalizedHitPosition.computeDoubleSize(7)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.CatchPokemonMessage> {
        var mergedArray = Array<RequestEnvelop.CatchPokemonMessage>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.CatchPokemonMessage? {
        return try RequestEnvelop.CatchPokemonMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.CatchPokemonMessage {
        return try RequestEnvelop.CatchPokemonMessage.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.CatchPokemonMessage {
        return try RequestEnvelop.CatchPokemonMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.CatchPokemonMessage {
        return try RequestEnvelop.CatchPokemonMessage.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.CatchPokemonMessage {
        return try RequestEnvelop.CatchPokemonMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.CatchPokemonMessage {
        return try RequestEnvelop.CatchPokemonMessage.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.CatchPokemonMessage {
        return try RequestEnvelop.CatchPokemonMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.CatchPokemonMessage.Builder {
        return RequestEnvelop.CatchPokemonMessage.classBuilder() as! RequestEnvelop.CatchPokemonMessage.Builder
      }
      public func getBuilder() -> RequestEnvelop.CatchPokemonMessage.Builder {
        return classBuilder() as! RequestEnvelop.CatchPokemonMessage.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.CatchPokemonMessage.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.CatchPokemonMessage.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.CatchPokemonMessage.Builder {
        return try RequestEnvelop.CatchPokemonMessage.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.CatchPokemonMessage) throws -> RequestEnvelop.CatchPokemonMessage.Builder {
        return try RequestEnvelop.CatchPokemonMessage.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasEncounterId {
          output += "\(indent) encounterId: \(encounterId) \n"
        }
        if hasPokeball {
          output += "\(indent) pokeball: \(pokeball) \n"
        }
        if hasNormalizedReticleSize {
          output += "\(indent) normalizedReticleSize: \(normalizedReticleSize) \n"
        }
        if hasSpawnpointId {
          output += "\(indent) spawnpointId: \(spawnpointId) \n"
        }
        if hasHitPokemon {
          output += "\(indent) hitPokemon: \(hitPokemon) \n"
        }
        if hasSpinModifier {
          output += "\(indent) spinModifier: \(spinModifier) \n"
        }
        if hasNormalizedHitPosition {
          output += "\(indent) normalizedHitPosition: \(normalizedHitPosition) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasEncounterId {
                 hashCode = (hashCode &* 31) &+ encounterId.hashValue
              }
              if hasPokeball {
                 hashCode = (hashCode &* 31) &+ pokeball.hashValue
              }
              if hasNormalizedReticleSize {
                 hashCode = (hashCode &* 31) &+ normalizedReticleSize.hashValue
              }
              if hasSpawnpointId {
                 hashCode = (hashCode &* 31) &+ spawnpointId.hashValue
              }
              if hasHitPokemon {
                 hashCode = (hashCode &* 31) &+ hitPokemon.hashValue
              }
              if hasSpinModifier {
                 hashCode = (hashCode &* 31) &+ spinModifier.hashValue
              }
              if hasNormalizedHitPosition {
                 hashCode = (hashCode &* 31) &+ normalizedHitPosition.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.CatchPokemonMessage"
      }
      override public func className() -> String {
          return "RequestEnvelop.CatchPokemonMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.CatchPokemonMessage.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.CatchPokemonMessage = RequestEnvelop.CatchPokemonMessage()
        public func getMessage() -> RequestEnvelop.CatchPokemonMessage {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasEncounterId:Bool {
             get {
                  return builderResult.hasEncounterId
             }
        }
        public var encounterId:UInt64 {
             get {
                  return builderResult.encounterId
             }
             set (value) {
                 builderResult.hasEncounterId = true
                 builderResult.encounterId = value
             }
        }
        public func setEncounterId(value:UInt64) -> RequestEnvelop.CatchPokemonMessage.Builder {
          self.encounterId = value
          return self
        }
        public func clearEncounterId() -> RequestEnvelop.CatchPokemonMessage.Builder{
             builderResult.hasEncounterId = false
             builderResult.encounterId = UInt64(0)
             return self
        }
        public var hasPokeball:Bool {
             get {
                  return builderResult.hasPokeball
             }
        }
        public var pokeball:Int32 {
             get {
                  return builderResult.pokeball
             }
             set (value) {
                 builderResult.hasPokeball = true
                 builderResult.pokeball = value
             }
        }
        public func setPokeball(value:Int32) -> RequestEnvelop.CatchPokemonMessage.Builder {
          self.pokeball = value
          return self
        }
        public func clearPokeball() -> RequestEnvelop.CatchPokemonMessage.Builder{
             builderResult.hasPokeball = false
             builderResult.pokeball = Int32(0)
             return self
        }
        public var hasNormalizedReticleSize:Bool {
             get {
                  return builderResult.hasNormalizedReticleSize
             }
        }
        public var normalizedReticleSize:Double {
             get {
                  return builderResult.normalizedReticleSize
             }
             set (value) {
                 builderResult.hasNormalizedReticleSize = true
                 builderResult.normalizedReticleSize = value
             }
        }
        public func setNormalizedReticleSize(value:Double) -> RequestEnvelop.CatchPokemonMessage.Builder {
          self.normalizedReticleSize = value
          return self
        }
        public func clearNormalizedReticleSize() -> RequestEnvelop.CatchPokemonMessage.Builder{
             builderResult.hasNormalizedReticleSize = false
             builderResult.normalizedReticleSize = Double(0)
             return self
        }
        public var hasSpawnpointId:Bool {
             get {
                  return builderResult.hasSpawnpointId
             }
        }
        public var spawnpointId:String {
             get {
                  return builderResult.spawnpointId
             }
             set (value) {
                 builderResult.hasSpawnpointId = true
                 builderResult.spawnpointId = value
             }
        }
        public func setSpawnpointId(value:String) -> RequestEnvelop.CatchPokemonMessage.Builder {
          self.spawnpointId = value
          return self
        }
        public func clearSpawnpointId() -> RequestEnvelop.CatchPokemonMessage.Builder{
             builderResult.hasSpawnpointId = false
             builderResult.spawnpointId = ""
             return self
        }
        public var hasHitPokemon:Bool {
             get {
                  return builderResult.hasHitPokemon
             }
        }
        public var hitPokemon:Bool {
             get {
                  return builderResult.hitPokemon
             }
             set (value) {
                 builderResult.hasHitPokemon = true
                 builderResult.hitPokemon = value
             }
        }
        public func setHitPokemon(value:Bool) -> RequestEnvelop.CatchPokemonMessage.Builder {
          self.hitPokemon = value
          return self
        }
        public func clearHitPokemon() -> RequestEnvelop.CatchPokemonMessage.Builder{
             builderResult.hasHitPokemon = false
             builderResult.hitPokemon = false
             return self
        }
        public var hasSpinModifier:Bool {
             get {
                  return builderResult.hasSpinModifier
             }
        }
        public var spinModifier:Double {
             get {
                  return builderResult.spinModifier
             }
             set (value) {
                 builderResult.hasSpinModifier = true
                 builderResult.spinModifier = value
             }
        }
        public func setSpinModifier(value:Double) -> RequestEnvelop.CatchPokemonMessage.Builder {
          self.spinModifier = value
          return self
        }
        public func clearSpinModifier() -> RequestEnvelop.CatchPokemonMessage.Builder{
             builderResult.hasSpinModifier = false
             builderResult.spinModifier = Double(0)
             return self
        }
        public var hasNormalizedHitPosition:Bool {
             get {
                  return builderResult.hasNormalizedHitPosition
             }
        }
        public var normalizedHitPosition:Double {
             get {
                  return builderResult.normalizedHitPosition
             }
             set (value) {
                 builderResult.hasNormalizedHitPosition = true
                 builderResult.normalizedHitPosition = value
             }
        }
        public func setNormalizedHitPosition(value:Double) -> RequestEnvelop.CatchPokemonMessage.Builder {
          self.normalizedHitPosition = value
          return self
        }
        public func clearNormalizedHitPosition() -> RequestEnvelop.CatchPokemonMessage.Builder{
             builderResult.hasNormalizedHitPosition = false
             builderResult.normalizedHitPosition = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.CatchPokemonMessage.Builder {
          builderResult = RequestEnvelop.CatchPokemonMessage()
          return self
        }
        public override func clone() throws -> RequestEnvelop.CatchPokemonMessage.Builder {
          return try RequestEnvelop.CatchPokemonMessage.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.CatchPokemonMessage {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.CatchPokemonMessage {
          let returnMe:RequestEnvelop.CatchPokemonMessage = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.CatchPokemonMessage) throws -> RequestEnvelop.CatchPokemonMessage.Builder {
          if other == RequestEnvelop.CatchPokemonMessage() {
           return self
          }
          if other.hasEncounterId {
               encounterId = other.encounterId
          }
          if other.hasPokeball {
               pokeball = other.pokeball
          }
          if other.hasNormalizedReticleSize {
               normalizedReticleSize = other.normalizedReticleSize
          }
          if other.hasSpawnpointId {
               spawnpointId = other.spawnpointId
          }
          if other.hasHitPokemon {
               hitPokemon = other.hitPokemon
          }
          if other.hasSpinModifier {
               spinModifier = other.spinModifier
          }
          if other.hasNormalizedHitPosition {
               normalizedHitPosition = other.normalizedHitPosition
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.CatchPokemonMessage.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.CatchPokemonMessage.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 9 :
              encounterId = try input.readFixed64()

            case 16 :
              pokeball = try input.readInt32()

            case 25 :
              normalizedReticleSize = try input.readDouble()

            case 34 :
              spawnpointId = try input.readString()

            case 40 :
              hitPokemon = try input.readBool()

            case 49 :
              spinModifier = try input.readDouble()

            case 57 :
              normalizedHitPosition = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class EvolvePokemonMessage : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var pokemonId:UInt64 = UInt64(0)

      public private(set) var hasPokemonId:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasPokemonId {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasPokemonId {
          try output.writeFixed64(1, value:pokemonId)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPokemonId {
          serialize_size += pokemonId.computeFixed64Size(1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.EvolvePokemonMessage> {
        var mergedArray = Array<RequestEnvelop.EvolvePokemonMessage>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.EvolvePokemonMessage? {
        return try RequestEnvelop.EvolvePokemonMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.EvolvePokemonMessage {
        return try RequestEnvelop.EvolvePokemonMessage.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.EvolvePokemonMessage {
        return try RequestEnvelop.EvolvePokemonMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.EvolvePokemonMessage {
        return try RequestEnvelop.EvolvePokemonMessage.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.EvolvePokemonMessage {
        return try RequestEnvelop.EvolvePokemonMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.EvolvePokemonMessage {
        return try RequestEnvelop.EvolvePokemonMessage.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.EvolvePokemonMessage {
        return try RequestEnvelop.EvolvePokemonMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.EvolvePokemonMessage.Builder {
        return RequestEnvelop.EvolvePokemonMessage.classBuilder() as! RequestEnvelop.EvolvePokemonMessage.Builder
      }
      public func getBuilder() -> RequestEnvelop.EvolvePokemonMessage.Builder {
        return classBuilder() as! RequestEnvelop.EvolvePokemonMessage.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.EvolvePokemonMessage.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.EvolvePokemonMessage.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.EvolvePokemonMessage.Builder {
        return try RequestEnvelop.EvolvePokemonMessage.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.EvolvePokemonMessage) throws -> RequestEnvelop.EvolvePokemonMessage.Builder {
        return try RequestEnvelop.EvolvePokemonMessage.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasPokemonId {
          output += "\(indent) pokemonId: \(pokemonId) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasPokemonId {
                 hashCode = (hashCode &* 31) &+ pokemonId.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.EvolvePokemonMessage"
      }
      override public func className() -> String {
          return "RequestEnvelop.EvolvePokemonMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.EvolvePokemonMessage.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.EvolvePokemonMessage = RequestEnvelop.EvolvePokemonMessage()
        public func getMessage() -> RequestEnvelop.EvolvePokemonMessage {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasPokemonId:Bool {
             get {
                  return builderResult.hasPokemonId
             }
        }
        public var pokemonId:UInt64 {
             get {
                  return builderResult.pokemonId
             }
             set (value) {
                 builderResult.hasPokemonId = true
                 builderResult.pokemonId = value
             }
        }
        public func setPokemonId(value:UInt64) -> RequestEnvelop.EvolvePokemonMessage.Builder {
          self.pokemonId = value
          return self
        }
        public func clearPokemonId() -> RequestEnvelop.EvolvePokemonMessage.Builder{
             builderResult.hasPokemonId = false
             builderResult.pokemonId = UInt64(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.EvolvePokemonMessage.Builder {
          builderResult = RequestEnvelop.EvolvePokemonMessage()
          return self
        }
        public override func clone() throws -> RequestEnvelop.EvolvePokemonMessage.Builder {
          return try RequestEnvelop.EvolvePokemonMessage.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.EvolvePokemonMessage {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.EvolvePokemonMessage {
          let returnMe:RequestEnvelop.EvolvePokemonMessage = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.EvolvePokemonMessage) throws -> RequestEnvelop.EvolvePokemonMessage.Builder {
          if other == RequestEnvelop.EvolvePokemonMessage() {
           return self
          }
          if other.hasPokemonId {
               pokemonId = other.pokemonId
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.EvolvePokemonMessage.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.EvolvePokemonMessage.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 9 :
              pokemonId = try input.readFixed64()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class TransferPokemonMessage : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var pokemonId:UInt64 = UInt64(0)

      public private(set) var hasPokemonId:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasPokemonId {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasPokemonId {
          try output.writeFixed64(1, value:pokemonId)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPokemonId {
          serialize_size += pokemonId.computeFixed64Size(1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.TransferPokemonMessage> {
        var mergedArray = Array<RequestEnvelop.TransferPokemonMessage>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.TransferPokemonMessage? {
        return try RequestEnvelop.TransferPokemonMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.TransferPokemonMessage {
        return try RequestEnvelop.TransferPokemonMessage.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.TransferPokemonMessage {
        return try RequestEnvelop.TransferPokemonMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.TransferPokemonMessage {
        return try RequestEnvelop.TransferPokemonMessage.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.TransferPokemonMessage {
        return try RequestEnvelop.TransferPokemonMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.TransferPokemonMessage {
        return try RequestEnvelop.TransferPokemonMessage.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.TransferPokemonMessage {
        return try RequestEnvelop.TransferPokemonMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.TransferPokemonMessage.Builder {
        return RequestEnvelop.TransferPokemonMessage.classBuilder() as! RequestEnvelop.TransferPokemonMessage.Builder
      }
      public func getBuilder() -> RequestEnvelop.TransferPokemonMessage.Builder {
        return classBuilder() as! RequestEnvelop.TransferPokemonMessage.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.TransferPokemonMessage.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.TransferPokemonMessage.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.TransferPokemonMessage.Builder {
        return try RequestEnvelop.TransferPokemonMessage.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.TransferPokemonMessage) throws -> RequestEnvelop.TransferPokemonMessage.Builder {
        return try RequestEnvelop.TransferPokemonMessage.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasPokemonId {
          output += "\(indent) pokemonId: \(pokemonId) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasPokemonId {
                 hashCode = (hashCode &* 31) &+ pokemonId.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.TransferPokemonMessage"
      }
      override public func className() -> String {
          return "RequestEnvelop.TransferPokemonMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.TransferPokemonMessage.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.TransferPokemonMessage = RequestEnvelop.TransferPokemonMessage()
        public func getMessage() -> RequestEnvelop.TransferPokemonMessage {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasPokemonId:Bool {
             get {
                  return builderResult.hasPokemonId
             }
        }
        public var pokemonId:UInt64 {
             get {
                  return builderResult.pokemonId
             }
             set (value) {
                 builderResult.hasPokemonId = true
                 builderResult.pokemonId = value
             }
        }
        public func setPokemonId(value:UInt64) -> RequestEnvelop.TransferPokemonMessage.Builder {
          self.pokemonId = value
          return self
        }
        public func clearPokemonId() -> RequestEnvelop.TransferPokemonMessage.Builder{
             builderResult.hasPokemonId = false
             builderResult.pokemonId = UInt64(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.TransferPokemonMessage.Builder {
          builderResult = RequestEnvelop.TransferPokemonMessage()
          return self
        }
        public override func clone() throws -> RequestEnvelop.TransferPokemonMessage.Builder {
          return try RequestEnvelop.TransferPokemonMessage.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.TransferPokemonMessage {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.TransferPokemonMessage {
          let returnMe:RequestEnvelop.TransferPokemonMessage = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.TransferPokemonMessage) throws -> RequestEnvelop.TransferPokemonMessage.Builder {
          if other == RequestEnvelop.TransferPokemonMessage() {
           return self
          }
          if other.hasPokemonId {
               pokemonId = other.pokemonId
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.TransferPokemonMessage.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.TransferPokemonMessage.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 9 :
              pokemonId = try input.readFixed64()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class EncounterMessage : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var encounterId:Array<UInt64> = Array<UInt64>()
      public private(set) var spawnpointId:String = ""

      public private(set) var hasSpawnpointId:Bool = false
      public private(set) var playerLatitude:Double = Double(0)

      public private(set) var hasPlayerLatitude:Bool = false
      public private(set) var playerLongitude:Double = Double(0)

      public private(set) var hasPlayerLongitude:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasSpawnpointId {
          return false
        }
        if !hasPlayerLatitude {
          return false
        }
        if !hasPlayerLongitude {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if !encounterId.isEmpty {
          for oneValueencounterId in encounterId {
            try output.writeFixed64(1, value:oneValueencounterId)
          }
        }
        if hasSpawnpointId {
          try output.writeString(2, value:spawnpointId)
        }
        if hasPlayerLatitude {
          try output.writeDouble(3, value:playerLatitude)
        }
        if hasPlayerLongitude {
          try output.writeDouble(4, value:playerLongitude)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        var dataSizeEncounterId:Int32 = 0
        dataSizeEncounterId = 8 * Int32(encounterId.count)
        serialize_size += dataSizeEncounterId
        serialize_size += 1 * Int32(encounterId.count)
        if hasSpawnpointId {
          serialize_size += spawnpointId.computeStringSize(2)
        }
        if hasPlayerLatitude {
          serialize_size += playerLatitude.computeDoubleSize(3)
        }
        if hasPlayerLongitude {
          serialize_size += playerLongitude.computeDoubleSize(4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.EncounterMessage> {
        var mergedArray = Array<RequestEnvelop.EncounterMessage>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.EncounterMessage? {
        return try RequestEnvelop.EncounterMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.EncounterMessage {
        return try RequestEnvelop.EncounterMessage.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.EncounterMessage {
        return try RequestEnvelop.EncounterMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.EncounterMessage {
        return try RequestEnvelop.EncounterMessage.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.EncounterMessage {
        return try RequestEnvelop.EncounterMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.EncounterMessage {
        return try RequestEnvelop.EncounterMessage.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.EncounterMessage {
        return try RequestEnvelop.EncounterMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.EncounterMessage.Builder {
        return RequestEnvelop.EncounterMessage.classBuilder() as! RequestEnvelop.EncounterMessage.Builder
      }
      public func getBuilder() -> RequestEnvelop.EncounterMessage.Builder {
        return classBuilder() as! RequestEnvelop.EncounterMessage.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.EncounterMessage.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.EncounterMessage.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.EncounterMessage.Builder {
        return try RequestEnvelop.EncounterMessage.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.EncounterMessage) throws -> RequestEnvelop.EncounterMessage.Builder {
        return try RequestEnvelop.EncounterMessage.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        var encounterIdElementIndex:Int = 0
        for oneValueencounterId in encounterId  {
            output += "\(indent) encounterId[\(encounterIdElementIndex)]: \(oneValueencounterId)\n"
            encounterIdElementIndex += 1
        }
        if hasSpawnpointId {
          output += "\(indent) spawnpointId: \(spawnpointId) \n"
        }
        if hasPlayerLatitude {
          output += "\(indent) playerLatitude: \(playerLatitude) \n"
        }
        if hasPlayerLongitude {
          output += "\(indent) playerLongitude: \(playerLongitude) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for oneValueencounterId in encounterId {
                  hashCode = (hashCode &* 31) &+ oneValueencounterId.hashValue
              }
              if hasSpawnpointId {
                 hashCode = (hashCode &* 31) &+ spawnpointId.hashValue
              }
              if hasPlayerLatitude {
                 hashCode = (hashCode &* 31) &+ playerLatitude.hashValue
              }
              if hasPlayerLongitude {
                 hashCode = (hashCode &* 31) &+ playerLongitude.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.EncounterMessage"
      }
      override public func className() -> String {
          return "RequestEnvelop.EncounterMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.EncounterMessage.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.EncounterMessage = RequestEnvelop.EncounterMessage()
        public func getMessage() -> RequestEnvelop.EncounterMessage {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var encounterId:Array<UInt64> {
             get {
                 return builderResult.encounterId
             }
             set (array) {
                 builderResult.encounterId = array
             }
        }
        public func setEncounterId(value:Array<UInt64>) -> RequestEnvelop.EncounterMessage.Builder {
          self.encounterId = value
          return self
        }
        public func clearEncounterId() -> RequestEnvelop.EncounterMessage.Builder {
           builderResult.encounterId.removeAll(keepCapacity: false)
           return self
        }
        public var hasSpawnpointId:Bool {
             get {
                  return builderResult.hasSpawnpointId
             }
        }
        public var spawnpointId:String {
             get {
                  return builderResult.spawnpointId
             }
             set (value) {
                 builderResult.hasSpawnpointId = true
                 builderResult.spawnpointId = value
             }
        }
        public func setSpawnpointId(value:String) -> RequestEnvelop.EncounterMessage.Builder {
          self.spawnpointId = value
          return self
        }
        public func clearSpawnpointId() -> RequestEnvelop.EncounterMessage.Builder{
             builderResult.hasSpawnpointId = false
             builderResult.spawnpointId = ""
             return self
        }
        public var hasPlayerLatitude:Bool {
             get {
                  return builderResult.hasPlayerLatitude
             }
        }
        public var playerLatitude:Double {
             get {
                  return builderResult.playerLatitude
             }
             set (value) {
                 builderResult.hasPlayerLatitude = true
                 builderResult.playerLatitude = value
             }
        }
        public func setPlayerLatitude(value:Double) -> RequestEnvelop.EncounterMessage.Builder {
          self.playerLatitude = value
          return self
        }
        public func clearPlayerLatitude() -> RequestEnvelop.EncounterMessage.Builder{
             builderResult.hasPlayerLatitude = false
             builderResult.playerLatitude = Double(0)
             return self
        }
        public var hasPlayerLongitude:Bool {
             get {
                  return builderResult.hasPlayerLongitude
             }
        }
        public var playerLongitude:Double {
             get {
                  return builderResult.playerLongitude
             }
             set (value) {
                 builderResult.hasPlayerLongitude = true
                 builderResult.playerLongitude = value
             }
        }
        public func setPlayerLongitude(value:Double) -> RequestEnvelop.EncounterMessage.Builder {
          self.playerLongitude = value
          return self
        }
        public func clearPlayerLongitude() -> RequestEnvelop.EncounterMessage.Builder{
             builderResult.hasPlayerLongitude = false
             builderResult.playerLongitude = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.EncounterMessage.Builder {
          builderResult = RequestEnvelop.EncounterMessage()
          return self
        }
        public override func clone() throws -> RequestEnvelop.EncounterMessage.Builder {
          return try RequestEnvelop.EncounterMessage.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.EncounterMessage {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.EncounterMessage {
          let returnMe:RequestEnvelop.EncounterMessage = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.EncounterMessage) throws -> RequestEnvelop.EncounterMessage.Builder {
          if other == RequestEnvelop.EncounterMessage() {
           return self
          }
          if !other.encounterId.isEmpty {
              builderResult.encounterId += other.encounterId
          }
          if other.hasSpawnpointId {
               spawnpointId = other.spawnpointId
          }
          if other.hasPlayerLatitude {
               playerLatitude = other.playerLatitude
          }
          if other.hasPlayerLongitude {
               playerLongitude = other.playerLongitude
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.EncounterMessage.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.EncounterMessage.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 9 :
              encounterId += [try input.readFixed64()]

            case 18 :
              spawnpointId = try input.readString()

            case 25 :
              playerLatitude = try input.readDouble()

            case 33 :
              playerLongitude = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class FortSearchMessage : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var fortId:String = ""

      public private(set) var hasFortId:Bool = false
      public private(set) var playerLatitude:Double = Double(0)

      public private(set) var hasPlayerLatitude:Bool = false
      public private(set) var playerLongitude:Double = Double(0)

      public private(set) var hasPlayerLongitude:Bool = false
      public private(set) var fortLatitude:Double = Double(0)

      public private(set) var hasFortLatitude:Bool = false
      public private(set) var fortLongitude:Double = Double(0)

      public private(set) var hasFortLongitude:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasFortId {
          return false
        }
        if !hasPlayerLatitude {
          return false
        }
        if !hasPlayerLongitude {
          return false
        }
        if !hasFortLatitude {
          return false
        }
        if !hasFortLongitude {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasFortId {
          try output.writeString(1, value:fortId)
        }
        if hasPlayerLatitude {
          try output.writeDouble(2, value:playerLatitude)
        }
        if hasPlayerLongitude {
          try output.writeDouble(3, value:playerLongitude)
        }
        if hasFortLatitude {
          try output.writeDouble(4, value:fortLatitude)
        }
        if hasFortLongitude {
          try output.writeDouble(5, value:fortLongitude)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFortId {
          serialize_size += fortId.computeStringSize(1)
        }
        if hasPlayerLatitude {
          serialize_size += playerLatitude.computeDoubleSize(2)
        }
        if hasPlayerLongitude {
          serialize_size += playerLongitude.computeDoubleSize(3)
        }
        if hasFortLatitude {
          serialize_size += fortLatitude.computeDoubleSize(4)
        }
        if hasFortLongitude {
          serialize_size += fortLongitude.computeDoubleSize(5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.FortSearchMessage> {
        var mergedArray = Array<RequestEnvelop.FortSearchMessage>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.FortSearchMessage? {
        return try RequestEnvelop.FortSearchMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.FortSearchMessage {
        return try RequestEnvelop.FortSearchMessage.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.FortSearchMessage {
        return try RequestEnvelop.FortSearchMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.FortSearchMessage {
        return try RequestEnvelop.FortSearchMessage.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.FortSearchMessage {
        return try RequestEnvelop.FortSearchMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.FortSearchMessage {
        return try RequestEnvelop.FortSearchMessage.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.FortSearchMessage {
        return try RequestEnvelop.FortSearchMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.FortSearchMessage.Builder {
        return RequestEnvelop.FortSearchMessage.classBuilder() as! RequestEnvelop.FortSearchMessage.Builder
      }
      public func getBuilder() -> RequestEnvelop.FortSearchMessage.Builder {
        return classBuilder() as! RequestEnvelop.FortSearchMessage.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.FortSearchMessage.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.FortSearchMessage.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.FortSearchMessage.Builder {
        return try RequestEnvelop.FortSearchMessage.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.FortSearchMessage) throws -> RequestEnvelop.FortSearchMessage.Builder {
        return try RequestEnvelop.FortSearchMessage.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasFortId {
          output += "\(indent) fortId: \(fortId) \n"
        }
        if hasPlayerLatitude {
          output += "\(indent) playerLatitude: \(playerLatitude) \n"
        }
        if hasPlayerLongitude {
          output += "\(indent) playerLongitude: \(playerLongitude) \n"
        }
        if hasFortLatitude {
          output += "\(indent) fortLatitude: \(fortLatitude) \n"
        }
        if hasFortLongitude {
          output += "\(indent) fortLongitude: \(fortLongitude) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasFortId {
                 hashCode = (hashCode &* 31) &+ fortId.hashValue
              }
              if hasPlayerLatitude {
                 hashCode = (hashCode &* 31) &+ playerLatitude.hashValue
              }
              if hasPlayerLongitude {
                 hashCode = (hashCode &* 31) &+ playerLongitude.hashValue
              }
              if hasFortLatitude {
                 hashCode = (hashCode &* 31) &+ fortLatitude.hashValue
              }
              if hasFortLongitude {
                 hashCode = (hashCode &* 31) &+ fortLongitude.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.FortSearchMessage"
      }
      override public func className() -> String {
          return "RequestEnvelop.FortSearchMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.FortSearchMessage.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.FortSearchMessage = RequestEnvelop.FortSearchMessage()
        public func getMessage() -> RequestEnvelop.FortSearchMessage {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasFortId:Bool {
             get {
                  return builderResult.hasFortId
             }
        }
        public var fortId:String {
             get {
                  return builderResult.fortId
             }
             set (value) {
                 builderResult.hasFortId = true
                 builderResult.fortId = value
             }
        }
        public func setFortId(value:String) -> RequestEnvelop.FortSearchMessage.Builder {
          self.fortId = value
          return self
        }
        public func clearFortId() -> RequestEnvelop.FortSearchMessage.Builder{
             builderResult.hasFortId = false
             builderResult.fortId = ""
             return self
        }
        public var hasPlayerLatitude:Bool {
             get {
                  return builderResult.hasPlayerLatitude
             }
        }
        public var playerLatitude:Double {
             get {
                  return builderResult.playerLatitude
             }
             set (value) {
                 builderResult.hasPlayerLatitude = true
                 builderResult.playerLatitude = value
             }
        }
        public func setPlayerLatitude(value:Double) -> RequestEnvelop.FortSearchMessage.Builder {
          self.playerLatitude = value
          return self
        }
        public func clearPlayerLatitude() -> RequestEnvelop.FortSearchMessage.Builder{
             builderResult.hasPlayerLatitude = false
             builderResult.playerLatitude = Double(0)
             return self
        }
        public var hasPlayerLongitude:Bool {
             get {
                  return builderResult.hasPlayerLongitude
             }
        }
        public var playerLongitude:Double {
             get {
                  return builderResult.playerLongitude
             }
             set (value) {
                 builderResult.hasPlayerLongitude = true
                 builderResult.playerLongitude = value
             }
        }
        public func setPlayerLongitude(value:Double) -> RequestEnvelop.FortSearchMessage.Builder {
          self.playerLongitude = value
          return self
        }
        public func clearPlayerLongitude() -> RequestEnvelop.FortSearchMessage.Builder{
             builderResult.hasPlayerLongitude = false
             builderResult.playerLongitude = Double(0)
             return self
        }
        public var hasFortLatitude:Bool {
             get {
                  return builderResult.hasFortLatitude
             }
        }
        public var fortLatitude:Double {
             get {
                  return builderResult.fortLatitude
             }
             set (value) {
                 builderResult.hasFortLatitude = true
                 builderResult.fortLatitude = value
             }
        }
        public func setFortLatitude(value:Double) -> RequestEnvelop.FortSearchMessage.Builder {
          self.fortLatitude = value
          return self
        }
        public func clearFortLatitude() -> RequestEnvelop.FortSearchMessage.Builder{
             builderResult.hasFortLatitude = false
             builderResult.fortLatitude = Double(0)
             return self
        }
        public var hasFortLongitude:Bool {
             get {
                  return builderResult.hasFortLongitude
             }
        }
        public var fortLongitude:Double {
             get {
                  return builderResult.fortLongitude
             }
             set (value) {
                 builderResult.hasFortLongitude = true
                 builderResult.fortLongitude = value
             }
        }
        public func setFortLongitude(value:Double) -> RequestEnvelop.FortSearchMessage.Builder {
          self.fortLongitude = value
          return self
        }
        public func clearFortLongitude() -> RequestEnvelop.FortSearchMessage.Builder{
             builderResult.hasFortLongitude = false
             builderResult.fortLongitude = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.FortSearchMessage.Builder {
          builderResult = RequestEnvelop.FortSearchMessage()
          return self
        }
        public override func clone() throws -> RequestEnvelop.FortSearchMessage.Builder {
          return try RequestEnvelop.FortSearchMessage.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.FortSearchMessage {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.FortSearchMessage {
          let returnMe:RequestEnvelop.FortSearchMessage = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.FortSearchMessage) throws -> RequestEnvelop.FortSearchMessage.Builder {
          if other == RequestEnvelop.FortSearchMessage() {
           return self
          }
          if other.hasFortId {
               fortId = other.fortId
          }
          if other.hasPlayerLatitude {
               playerLatitude = other.playerLatitude
          }
          if other.hasPlayerLongitude {
               playerLongitude = other.playerLongitude
          }
          if other.hasFortLatitude {
               fortLatitude = other.fortLatitude
          }
          if other.hasFortLongitude {
               fortLongitude = other.fortLongitude
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.FortSearchMessage.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.FortSearchMessage.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              fortId = try input.readString()

            case 17 :
              playerLatitude = try input.readDouble()

            case 25 :
              playerLongitude = try input.readDouble()

            case 33 :
              fortLatitude = try input.readDouble()

            case 41 :
              fortLongitude = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class FortDetailsRequest : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var fortId:String = ""

      public private(set) var hasFortId:Bool = false
      public private(set) var fortLatitude:Double = Double(0)

      public private(set) var hasFortLatitude:Bool = false
      public private(set) var fortLongitude:Double = Double(0)

      public private(set) var hasFortLongitude:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasFortId {
          return false
        }
        if !hasFortLatitude {
          return false
        }
        if !hasFortLongitude {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasFortId {
          try output.writeString(1, value:fortId)
        }
        if hasFortLatitude {
          try output.writeDouble(2, value:fortLatitude)
        }
        if hasFortLongitude {
          try output.writeDouble(3, value:fortLongitude)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFortId {
          serialize_size += fortId.computeStringSize(1)
        }
        if hasFortLatitude {
          serialize_size += fortLatitude.computeDoubleSize(2)
        }
        if hasFortLongitude {
          serialize_size += fortLongitude.computeDoubleSize(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.FortDetailsRequest> {
        var mergedArray = Array<RequestEnvelop.FortDetailsRequest>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.FortDetailsRequest? {
        return try RequestEnvelop.FortDetailsRequest.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.FortDetailsRequest {
        return try RequestEnvelop.FortDetailsRequest.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.FortDetailsRequest {
        return try RequestEnvelop.FortDetailsRequest.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.FortDetailsRequest {
        return try RequestEnvelop.FortDetailsRequest.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.FortDetailsRequest {
        return try RequestEnvelop.FortDetailsRequest.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.FortDetailsRequest {
        return try RequestEnvelop.FortDetailsRequest.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.FortDetailsRequest {
        return try RequestEnvelop.FortDetailsRequest.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.FortDetailsRequest.Builder {
        return RequestEnvelop.FortDetailsRequest.classBuilder() as! RequestEnvelop.FortDetailsRequest.Builder
      }
      public func getBuilder() -> RequestEnvelop.FortDetailsRequest.Builder {
        return classBuilder() as! RequestEnvelop.FortDetailsRequest.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.FortDetailsRequest.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.FortDetailsRequest.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.FortDetailsRequest.Builder {
        return try RequestEnvelop.FortDetailsRequest.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.FortDetailsRequest) throws -> RequestEnvelop.FortDetailsRequest.Builder {
        return try RequestEnvelop.FortDetailsRequest.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasFortId {
          output += "\(indent) fortId: \(fortId) \n"
        }
        if hasFortLatitude {
          output += "\(indent) fortLatitude: \(fortLatitude) \n"
        }
        if hasFortLongitude {
          output += "\(indent) fortLongitude: \(fortLongitude) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasFortId {
                 hashCode = (hashCode &* 31) &+ fortId.hashValue
              }
              if hasFortLatitude {
                 hashCode = (hashCode &* 31) &+ fortLatitude.hashValue
              }
              if hasFortLongitude {
                 hashCode = (hashCode &* 31) &+ fortLongitude.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.FortDetailsRequest"
      }
      override public func className() -> String {
          return "RequestEnvelop.FortDetailsRequest"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.FortDetailsRequest.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.FortDetailsRequest = RequestEnvelop.FortDetailsRequest()
        public func getMessage() -> RequestEnvelop.FortDetailsRequest {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasFortId:Bool {
             get {
                  return builderResult.hasFortId
             }
        }
        public var fortId:String {
             get {
                  return builderResult.fortId
             }
             set (value) {
                 builderResult.hasFortId = true
                 builderResult.fortId = value
             }
        }
        public func setFortId(value:String) -> RequestEnvelop.FortDetailsRequest.Builder {
          self.fortId = value
          return self
        }
        public func clearFortId() -> RequestEnvelop.FortDetailsRequest.Builder{
             builderResult.hasFortId = false
             builderResult.fortId = ""
             return self
        }
        public var hasFortLatitude:Bool {
             get {
                  return builderResult.hasFortLatitude
             }
        }
        public var fortLatitude:Double {
             get {
                  return builderResult.fortLatitude
             }
             set (value) {
                 builderResult.hasFortLatitude = true
                 builderResult.fortLatitude = value
             }
        }
        public func setFortLatitude(value:Double) -> RequestEnvelop.FortDetailsRequest.Builder {
          self.fortLatitude = value
          return self
        }
        public func clearFortLatitude() -> RequestEnvelop.FortDetailsRequest.Builder{
             builderResult.hasFortLatitude = false
             builderResult.fortLatitude = Double(0)
             return self
        }
        public var hasFortLongitude:Bool {
             get {
                  return builderResult.hasFortLongitude
             }
        }
        public var fortLongitude:Double {
             get {
                  return builderResult.fortLongitude
             }
             set (value) {
                 builderResult.hasFortLongitude = true
                 builderResult.fortLongitude = value
             }
        }
        public func setFortLongitude(value:Double) -> RequestEnvelop.FortDetailsRequest.Builder {
          self.fortLongitude = value
          return self
        }
        public func clearFortLongitude() -> RequestEnvelop.FortDetailsRequest.Builder{
             builderResult.hasFortLongitude = false
             builderResult.fortLongitude = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.FortDetailsRequest.Builder {
          builderResult = RequestEnvelop.FortDetailsRequest()
          return self
        }
        public override func clone() throws -> RequestEnvelop.FortDetailsRequest.Builder {
          return try RequestEnvelop.FortDetailsRequest.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.FortDetailsRequest {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.FortDetailsRequest {
          let returnMe:RequestEnvelop.FortDetailsRequest = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.FortDetailsRequest) throws -> RequestEnvelop.FortDetailsRequest.Builder {
          if other == RequestEnvelop.FortDetailsRequest() {
           return self
          }
          if other.hasFortId {
               fortId = other.fortId
          }
          if other.hasFortLatitude {
               fortLatitude = other.fortLatitude
          }
          if other.hasFortLongitude {
               fortLongitude = other.fortLongitude
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.FortDetailsRequest.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.FortDetailsRequest.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              fortId = try input.readString()

            case 17 :
              fortLatitude = try input.readDouble()

            case 25 :
              fortLongitude = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    //rpc id : 137
    final public class RecycleInventoryItemMessage : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var itemId:Int32 = Int32(0)

      public private(set) var hasItemId:Bool = false
      public private(set) var count:Int32 = Int32(0)

      public private(set) var hasCount:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasItemId {
          return false
        }
        if !hasCount {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasItemId {
          try output.writeInt32(1, value:itemId)
        }
        if hasCount {
          try output.writeInt32(2, value:count)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasItemId {
          serialize_size += itemId.computeInt32Size(1)
        }
        if hasCount {
          serialize_size += count.computeInt32Size(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.RecycleInventoryItemMessage> {
        var mergedArray = Array<RequestEnvelop.RecycleInventoryItemMessage>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.RecycleInventoryItemMessage? {
        return try RequestEnvelop.RecycleInventoryItemMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.RecycleInventoryItemMessage {
        return try RequestEnvelop.RecycleInventoryItemMessage.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.RecycleInventoryItemMessage {
        return try RequestEnvelop.RecycleInventoryItemMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.RecycleInventoryItemMessage {
        return try RequestEnvelop.RecycleInventoryItemMessage.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.RecycleInventoryItemMessage {
        return try RequestEnvelop.RecycleInventoryItemMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.RecycleInventoryItemMessage {
        return try RequestEnvelop.RecycleInventoryItemMessage.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.RecycleInventoryItemMessage {
        return try RequestEnvelop.RecycleInventoryItemMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
        return RequestEnvelop.RecycleInventoryItemMessage.classBuilder() as! RequestEnvelop.RecycleInventoryItemMessage.Builder
      }
      public func getBuilder() -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
        return classBuilder() as! RequestEnvelop.RecycleInventoryItemMessage.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.RecycleInventoryItemMessage.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.RecycleInventoryItemMessage.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
        return try RequestEnvelop.RecycleInventoryItemMessage.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.RecycleInventoryItemMessage) throws -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
        return try RequestEnvelop.RecycleInventoryItemMessage.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasItemId {
          output += "\(indent) itemId: \(itemId) \n"
        }
        if hasCount {
          output += "\(indent) count: \(count) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasItemId {
                 hashCode = (hashCode &* 31) &+ itemId.hashValue
              }
              if hasCount {
                 hashCode = (hashCode &* 31) &+ count.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.RecycleInventoryItemMessage"
      }
      override public func className() -> String {
          return "RequestEnvelop.RecycleInventoryItemMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.RecycleInventoryItemMessage.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.RecycleInventoryItemMessage = RequestEnvelop.RecycleInventoryItemMessage()
        public func getMessage() -> RequestEnvelop.RecycleInventoryItemMessage {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasItemId:Bool {
             get {
                  return builderResult.hasItemId
             }
        }
        public var itemId:Int32 {
             get {
                  return builderResult.itemId
             }
             set (value) {
                 builderResult.hasItemId = true
                 builderResult.itemId = value
             }
        }
        public func setItemId(value:Int32) -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
          self.itemId = value
          return self
        }
        public func clearItemId() -> RequestEnvelop.RecycleInventoryItemMessage.Builder{
             builderResult.hasItemId = false
             builderResult.itemId = Int32(0)
             return self
        }
        public var hasCount:Bool {
             get {
                  return builderResult.hasCount
             }
        }
        public var count:Int32 {
             get {
                  return builderResult.count
             }
             set (value) {
                 builderResult.hasCount = true
                 builderResult.count = value
             }
        }
        public func setCount(value:Int32) -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
          self.count = value
          return self
        }
        public func clearCount() -> RequestEnvelop.RecycleInventoryItemMessage.Builder{
             builderResult.hasCount = false
             builderResult.count = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
          builderResult = RequestEnvelop.RecycleInventoryItemMessage()
          return self
        }
        public override func clone() throws -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
          return try RequestEnvelop.RecycleInventoryItemMessage.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.RecycleInventoryItemMessage {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.RecycleInventoryItemMessage {
          let returnMe:RequestEnvelop.RecycleInventoryItemMessage = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.RecycleInventoryItemMessage) throws -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
          if other == RequestEnvelop.RecycleInventoryItemMessage() {
           return self
          }
          if other.hasItemId {
               itemId = other.itemId
          }
          if other.hasCount {
               count = other.count
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.RecycleInventoryItemMessage.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              itemId = try input.readInt32()

            case 16 :
              count = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class ReleasePokemonMessage : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var pokemonId:UInt64 = UInt64(0)

      public private(set) var hasPokemonId:Bool = false
      public private(set) var pokemonIds:Array<UInt64> = Array<UInt64>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasPokemonId {
          try output.writeFixed64(1, value:pokemonId)
        }
        if !pokemonIds.isEmpty {
          for oneValuepokemonIds in pokemonIds {
            try output.writeFixed64(2, value:oneValuepokemonIds)
          }
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPokemonId {
          serialize_size += pokemonId.computeFixed64Size(1)
        }
        var dataSizePokemonIds:Int32 = 0
        dataSizePokemonIds = 8 * Int32(pokemonIds.count)
        serialize_size += dataSizePokemonIds
        serialize_size += 1 * Int32(pokemonIds.count)
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop.ReleasePokemonMessage> {
        var mergedArray = Array<RequestEnvelop.ReleasePokemonMessage>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop.ReleasePokemonMessage? {
        return try RequestEnvelop.ReleasePokemonMessage.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> RequestEnvelop.ReleasePokemonMessage {
        return try RequestEnvelop.ReleasePokemonMessage.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.ReleasePokemonMessage {
        return try RequestEnvelop.ReleasePokemonMessage.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop.ReleasePokemonMessage {
        return try RequestEnvelop.ReleasePokemonMessage.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.ReleasePokemonMessage {
        return try RequestEnvelop.ReleasePokemonMessage.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.ReleasePokemonMessage {
        return try RequestEnvelop.ReleasePokemonMessage.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.ReleasePokemonMessage {
        return try RequestEnvelop.ReleasePokemonMessage.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> RequestEnvelop.ReleasePokemonMessage.Builder {
        return RequestEnvelop.ReleasePokemonMessage.classBuilder() as! RequestEnvelop.ReleasePokemonMessage.Builder
      }
      public func getBuilder() -> RequestEnvelop.ReleasePokemonMessage.Builder {
        return classBuilder() as! RequestEnvelop.ReleasePokemonMessage.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return RequestEnvelop.ReleasePokemonMessage.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return RequestEnvelop.ReleasePokemonMessage.Builder()
      }
      public func toBuilder() throws -> RequestEnvelop.ReleasePokemonMessage.Builder {
        return try RequestEnvelop.ReleasePokemonMessage.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:RequestEnvelop.ReleasePokemonMessage) throws -> RequestEnvelop.ReleasePokemonMessage.Builder {
        return try RequestEnvelop.ReleasePokemonMessage.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasPokemonId {
          output += "\(indent) pokemonId: \(pokemonId) \n"
        }
        var pokemonIdsElementIndex:Int = 0
        for oneValuepokemonIds in pokemonIds  {
            output += "\(indent) pokemonIds[\(pokemonIdsElementIndex)]: \(oneValuepokemonIds)\n"
            pokemonIdsElementIndex += 1
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasPokemonId {
                 hashCode = (hashCode &* 31) &+ pokemonId.hashValue
              }
              for oneValuepokemonIds in pokemonIds {
                  hashCode = (hashCode &* 31) &+ oneValuepokemonIds.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "RequestEnvelop.ReleasePokemonMessage"
      }
      override public func className() -> String {
          return "RequestEnvelop.ReleasePokemonMessage"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return RequestEnvelop.ReleasePokemonMessage.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:RequestEnvelop.ReleasePokemonMessage = RequestEnvelop.ReleasePokemonMessage()
        public func getMessage() -> RequestEnvelop.ReleasePokemonMessage {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasPokemonId:Bool {
             get {
                  return builderResult.hasPokemonId
             }
        }
        public var pokemonId:UInt64 {
             get {
                  return builderResult.pokemonId
             }
             set (value) {
                 builderResult.hasPokemonId = true
                 builderResult.pokemonId = value
             }
        }
        public func setPokemonId(value:UInt64) -> RequestEnvelop.ReleasePokemonMessage.Builder {
          self.pokemonId = value
          return self
        }
        public func clearPokemonId() -> RequestEnvelop.ReleasePokemonMessage.Builder{
             builderResult.hasPokemonId = false
             builderResult.pokemonId = UInt64(0)
             return self
        }
        public var pokemonIds:Array<UInt64> {
             get {
                 return builderResult.pokemonIds
             }
             set (array) {
                 builderResult.pokemonIds = array
             }
        }
        public func setPokemonIds(value:Array<UInt64>) -> RequestEnvelop.ReleasePokemonMessage.Builder {
          self.pokemonIds = value
          return self
        }
        public func clearPokemonIds() -> RequestEnvelop.ReleasePokemonMessage.Builder {
           builderResult.pokemonIds.removeAll(keepCapacity: false)
           return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> RequestEnvelop.ReleasePokemonMessage.Builder {
          builderResult = RequestEnvelop.ReleasePokemonMessage()
          return self
        }
        public override func clone() throws -> RequestEnvelop.ReleasePokemonMessage.Builder {
          return try RequestEnvelop.ReleasePokemonMessage.builderWithPrototype(builderResult)
        }
        public override func build() throws -> RequestEnvelop.ReleasePokemonMessage {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> RequestEnvelop.ReleasePokemonMessage {
          let returnMe:RequestEnvelop.ReleasePokemonMessage = builderResult
          return returnMe
        }
        public func mergeFrom(other:RequestEnvelop.ReleasePokemonMessage) throws -> RequestEnvelop.ReleasePokemonMessage.Builder {
          if other == RequestEnvelop.ReleasePokemonMessage() {
           return self
          }
          if other.hasPokemonId {
               pokemonId = other.pokemonId
          }
          if !other.pokemonIds.isEmpty {
              builderResult.pokemonIds += other.pokemonIds
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.ReleasePokemonMessage.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.ReleasePokemonMessage.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 9 :
              pokemonId = try input.readFixed64()

            case 17 :
              pokemonIds += [try input.readFixed64()]

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end

  public private(set) var unknown1:Int32 = Int32(0)

  public private(set) var hasUnknown1:Bool = false
  public private(set) var rpcId:Int64 = Int64(0)

  public private(set) var hasRpcId:Bool = false
  public private(set) var requests:Array<RequestEnvelop.Requests>  = Array<RequestEnvelop.Requests>()
  public private(set) var unknown6:RequestEnvelop.Unknown6!
  public private(set) var hasUnknown6:Bool = false
  public private(set) var latitude:Double = Double(0)

  public private(set) var hasLatitude:Bool = false
  public private(set) var longitude:Double = Double(0)

  public private(set) var hasLongitude:Bool = false
  public private(set) var altitude:Double = Double(0)

  public private(set) var hasAltitude:Bool = false
  public private(set) var auth:RequestEnvelop.AuthInfo!
  public private(set) var hasAuth:Bool = false
  public private(set) var unknown12:Int64 = Int64(0)

  public private(set) var hasUnknown12:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasUnknown1 {
      return false
    }
    var isInitrequests:Bool = true
    for oneElementrequests in requests {
        if (!oneElementrequests.isInitialized()) {
            isInitrequests = false
            break 
        }
    }
    if !isInitrequests {
     return isInitrequests
     }
    if hasUnknown6 {
     if !unknown6.isInitialized() {
       return false
     }
    }
    if hasAuth {
     if !auth.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasUnknown1 {
      try output.writeInt32(1, value:unknown1)
    }
    if hasRpcId {
      try output.writeInt64(3, value:rpcId)
    }
    for oneElementrequests in requests {
        try output.writeMessage(4, value:oneElementrequests)
    }
    if hasUnknown6 {
      try output.writeMessage(6, value:unknown6)
    }
    if hasLatitude {
      try output.writeDouble(7, value:latitude)
    }
    if hasLongitude {
      try output.writeDouble(8, value:longitude)
    }
    if hasAltitude {
      try output.writeDouble(9, value:altitude)
    }
    if hasAuth {
      try output.writeMessage(10, value:auth)
    }
    if hasUnknown12 {
      try output.writeInt64(12, value:unknown12)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUnknown1 {
      serialize_size += unknown1.computeInt32Size(1)
    }
    if hasRpcId {
      serialize_size += rpcId.computeInt64Size(3)
    }
    for oneElementrequests in requests {
        serialize_size += oneElementrequests.computeMessageSize(4)
    }
    if hasUnknown6 {
        if let varSizeunknown6 = unknown6?.computeMessageSize(6) {
            serialize_size += varSizeunknown6
        }
    }
    if hasLatitude {
      serialize_size += latitude.computeDoubleSize(7)
    }
    if hasLongitude {
      serialize_size += longitude.computeDoubleSize(8)
    }
    if hasAltitude {
      serialize_size += altitude.computeDoubleSize(9)
    }
    if hasAuth {
        if let varSizeauth = auth?.computeMessageSize(10) {
            serialize_size += varSizeauth
        }
    }
    if hasUnknown12 {
      serialize_size += unknown12.computeInt64Size(12)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<RequestEnvelop> {
    var mergedArray = Array<RequestEnvelop>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> RequestEnvelop? {
    return try RequestEnvelop.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> RequestEnvelop {
    return try RequestEnvelop.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop {
    return try RequestEnvelop.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> RequestEnvelop {
    return try RequestEnvelop.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop {
    return try RequestEnvelop.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop {
    return try RequestEnvelop.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop {
    return try RequestEnvelop.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> RequestEnvelop.Builder {
    return RequestEnvelop.classBuilder() as! RequestEnvelop.Builder
  }
  public func getBuilder() -> RequestEnvelop.Builder {
    return classBuilder() as! RequestEnvelop.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return RequestEnvelop.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return RequestEnvelop.Builder()
  }
  public func toBuilder() throws -> RequestEnvelop.Builder {
    return try RequestEnvelop.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:RequestEnvelop) throws -> RequestEnvelop.Builder {
    return try RequestEnvelop.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasUnknown1 {
      output += "\(indent) unknown1: \(unknown1) \n"
    }
    if hasRpcId {
      output += "\(indent) rpcId: \(rpcId) \n"
    }
    var requestsElementIndex:Int = 0
    for oneElementrequests in requests {
        output += "\(indent) requests[\(requestsElementIndex)] {\n"
        output += try oneElementrequests.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        requestsElementIndex += 1
    }
    if hasUnknown6 {
      output += "\(indent) unknown6 {\n"
      if let outDescUnknown6 = unknown6 {
        output += try outDescUnknown6.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLatitude {
      output += "\(indent) latitude: \(latitude) \n"
    }
    if hasLongitude {
      output += "\(indent) longitude: \(longitude) \n"
    }
    if hasAltitude {
      output += "\(indent) altitude: \(altitude) \n"
    }
    if hasAuth {
      output += "\(indent) auth {\n"
      if let outDescAuth = auth {
        output += try outDescAuth.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasUnknown12 {
      output += "\(indent) unknown12: \(unknown12) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUnknown1 {
             hashCode = (hashCode &* 31) &+ unknown1.hashValue
          }
          if hasRpcId {
             hashCode = (hashCode &* 31) &+ rpcId.hashValue
          }
          for oneElementrequests in requests {
              hashCode = (hashCode &* 31) &+ oneElementrequests.hashValue
          }
          if hasUnknown6 {
              if let hashValueunknown6 = unknown6?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueunknown6
              }
          }
          if hasLatitude {
             hashCode = (hashCode &* 31) &+ latitude.hashValue
          }
          if hasLongitude {
             hashCode = (hashCode &* 31) &+ longitude.hashValue
          }
          if hasAltitude {
             hashCode = (hashCode &* 31) &+ altitude.hashValue
          }
          if hasAuth {
              if let hashValueauth = auth?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueauth
              }
          }
          if hasUnknown12 {
             hashCode = (hashCode &* 31) &+ unknown12.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "RequestEnvelop"
  }
  override public func className() -> String {
      return "RequestEnvelop"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return RequestEnvelop.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:RequestEnvelop = RequestEnvelop()
    public func getMessage() -> RequestEnvelop {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUnknown1:Bool {
         get {
              return builderResult.hasUnknown1
         }
    }
    public var unknown1:Int32 {
         get {
              return builderResult.unknown1
         }
         set (value) {
             builderResult.hasUnknown1 = true
             builderResult.unknown1 = value
         }
    }
    public func setUnknown1(value:Int32) -> RequestEnvelop.Builder {
      self.unknown1 = value
      return self
    }
    public func clearUnknown1() -> RequestEnvelop.Builder{
         builderResult.hasUnknown1 = false
         builderResult.unknown1 = Int32(0)
         return self
    }
    public var hasRpcId:Bool {
         get {
              return builderResult.hasRpcId
         }
    }
    public var rpcId:Int64 {
         get {
              return builderResult.rpcId
         }
         set (value) {
             builderResult.hasRpcId = true
             builderResult.rpcId = value
         }
    }
    public func setRpcId(value:Int64) -> RequestEnvelop.Builder {
      self.rpcId = value
      return self
    }
    public func clearRpcId() -> RequestEnvelop.Builder{
         builderResult.hasRpcId = false
         builderResult.rpcId = Int64(0)
         return self
    }
    public var requests:Array<RequestEnvelop.Requests> {
         get {
             return builderResult.requests
         }
         set (value) {
             builderResult.requests = value
         }
    }
    public func setRequests(value:Array<RequestEnvelop.Requests>) -> RequestEnvelop.Builder {
      self.requests = value
      return self
    }
    public func clearRequests() -> RequestEnvelop.Builder {
      builderResult.requests.removeAll(keepCapacity: false)
      return self
    }
    public var hasUnknown6:Bool {
         get {
             return builderResult.hasUnknown6
         }
    }
    public var unknown6:RequestEnvelop.Unknown6! {
         get {
             if unknown6Builder_ != nil {
                builderResult.unknown6 = unknown6Builder_.getMessage()
             }
             return builderResult.unknown6
         }
         set (value) {
             builderResult.hasUnknown6 = true
             builderResult.unknown6 = value
         }
    }
    private var unknown6Builder_:RequestEnvelop.Unknown6.Builder! {
         didSet {
            builderResult.hasUnknown6 = true
         }
    }
    public func getUnknown6Builder() -> RequestEnvelop.Unknown6.Builder {
      if unknown6Builder_ == nil {
         unknown6Builder_ = RequestEnvelop.Unknown6.Builder()
         builderResult.unknown6 = unknown6Builder_.getMessage()
         if unknown6 != nil {
            try! unknown6Builder_.mergeFrom(unknown6)
         }
      }
      return unknown6Builder_
    }
    public func setUnknown6(value:RequestEnvelop.Unknown6!) -> RequestEnvelop.Builder {
      self.unknown6 = value
      return self
    }
    public func mergeUnknown6(value:RequestEnvelop.Unknown6) throws -> RequestEnvelop.Builder {
      if builderResult.hasUnknown6 {
        builderResult.unknown6 = try RequestEnvelop.Unknown6.builderWithPrototype(builderResult.unknown6).mergeFrom(value).buildPartial()
      } else {
        builderResult.unknown6 = value
      }
      builderResult.hasUnknown6 = true
      return self
    }
    public func clearUnknown6() -> RequestEnvelop.Builder {
      unknown6Builder_ = nil
      builderResult.hasUnknown6 = false
      builderResult.unknown6 = nil
      return self
    }
    public var hasLatitude:Bool {
         get {
              return builderResult.hasLatitude
         }
    }
    public var latitude:Double {
         get {
              return builderResult.latitude
         }
         set (value) {
             builderResult.hasLatitude = true
             builderResult.latitude = value
         }
    }
    public func setLatitude(value:Double) -> RequestEnvelop.Builder {
      self.latitude = value
      return self
    }
    public func clearLatitude() -> RequestEnvelop.Builder{
         builderResult.hasLatitude = false
         builderResult.latitude = Double(0)
         return self
    }
    public var hasLongitude:Bool {
         get {
              return builderResult.hasLongitude
         }
    }
    public var longitude:Double {
         get {
              return builderResult.longitude
         }
         set (value) {
             builderResult.hasLongitude = true
             builderResult.longitude = value
         }
    }
    public func setLongitude(value:Double) -> RequestEnvelop.Builder {
      self.longitude = value
      return self
    }
    public func clearLongitude() -> RequestEnvelop.Builder{
         builderResult.hasLongitude = false
         builderResult.longitude = Double(0)
         return self
    }
    public var hasAltitude:Bool {
         get {
              return builderResult.hasAltitude
         }
    }
    public var altitude:Double {
         get {
              return builderResult.altitude
         }
         set (value) {
             builderResult.hasAltitude = true
             builderResult.altitude = value
         }
    }
    public func setAltitude(value:Double) -> RequestEnvelop.Builder {
      self.altitude = value
      return self
    }
    public func clearAltitude() -> RequestEnvelop.Builder{
         builderResult.hasAltitude = false
         builderResult.altitude = Double(0)
         return self
    }
    public var hasAuth:Bool {
         get {
             return builderResult.hasAuth
         }
    }
    public var auth:RequestEnvelop.AuthInfo! {
         get {
             if authBuilder_ != nil {
                builderResult.auth = authBuilder_.getMessage()
             }
             return builderResult.auth
         }
         set (value) {
             builderResult.hasAuth = true
             builderResult.auth = value
         }
    }
    private var authBuilder_:RequestEnvelop.AuthInfo.Builder! {
         didSet {
            builderResult.hasAuth = true
         }
    }
    public func getAuthBuilder() -> RequestEnvelop.AuthInfo.Builder {
      if authBuilder_ == nil {
         authBuilder_ = RequestEnvelop.AuthInfo.Builder()
         builderResult.auth = authBuilder_.getMessage()
         if auth != nil {
            try! authBuilder_.mergeFrom(auth)
         }
      }
      return authBuilder_
    }
    public func setAuth(value:RequestEnvelop.AuthInfo!) -> RequestEnvelop.Builder {
      self.auth = value
      return self
    }
    public func mergeAuth(value:RequestEnvelop.AuthInfo) throws -> RequestEnvelop.Builder {
      if builderResult.hasAuth {
        builderResult.auth = try RequestEnvelop.AuthInfo.builderWithPrototype(builderResult.auth).mergeFrom(value).buildPartial()
      } else {
        builderResult.auth = value
      }
      builderResult.hasAuth = true
      return self
    }
    public func clearAuth() -> RequestEnvelop.Builder {
      authBuilder_ = nil
      builderResult.hasAuth = false
      builderResult.auth = nil
      return self
    }
    public var hasUnknown12:Bool {
         get {
              return builderResult.hasUnknown12
         }
    }
    public var unknown12:Int64 {
         get {
              return builderResult.unknown12
         }
         set (value) {
             builderResult.hasUnknown12 = true
             builderResult.unknown12 = value
         }
    }
    public func setUnknown12(value:Int64) -> RequestEnvelop.Builder {
      self.unknown12 = value
      return self
    }
    public func clearUnknown12() -> RequestEnvelop.Builder{
         builderResult.hasUnknown12 = false
         builderResult.unknown12 = Int64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> RequestEnvelop.Builder {
      builderResult = RequestEnvelop()
      return self
    }
    public override func clone() throws -> RequestEnvelop.Builder {
      return try RequestEnvelop.builderWithPrototype(builderResult)
    }
    public override func build() throws -> RequestEnvelop {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> RequestEnvelop {
      let returnMe:RequestEnvelop = builderResult
      return returnMe
    }
    public func mergeFrom(other:RequestEnvelop) throws -> RequestEnvelop.Builder {
      if other == RequestEnvelop() {
       return self
      }
      if other.hasUnknown1 {
           unknown1 = other.unknown1
      }
      if other.hasRpcId {
           rpcId = other.rpcId
      }
      if !other.requests.isEmpty  {
         builderResult.requests += other.requests
      }
      if (other.hasUnknown6) {
          try mergeUnknown6(other.unknown6)
      }
      if other.hasLatitude {
           latitude = other.latitude
      }
      if other.hasLongitude {
           longitude = other.longitude
      }
      if other.hasAltitude {
           altitude = other.altitude
      }
      if (other.hasAuth) {
          try mergeAuth(other.auth)
      }
      if other.hasUnknown12 {
           unknown12 = other.unknown12
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> RequestEnvelop.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> RequestEnvelop.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          unknown1 = try input.readInt32()

        case 24 :
          rpcId = try input.readInt64()

        case 34 :
          let subBuilder = RequestEnvelop.Requests.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          requests += [subBuilder.buildPartial()]

        case 50 :
          let subBuilder:RequestEnvelop.Unknown6.Builder = RequestEnvelop.Unknown6.Builder()
          if hasUnknown6 {
            try subBuilder.mergeFrom(unknown6)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          unknown6 = subBuilder.buildPartial()

        case 57 :
          latitude = try input.readDouble()

        case 65 :
          longitude = try input.readDouble()

        case 73 :
          altitude = try input.readDouble()

        case 82 :
          let subBuilder:RequestEnvelop.AuthInfo.Builder = RequestEnvelop.AuthInfo.Builder()
          if hasAuth {
            try subBuilder.mergeFrom(auth)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          auth = subBuilder.buildPartial()

        case 96 :
          unknown12 = try input.readInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ResponseEnvelop : GeneratedMessage, GeneratedMessageProtocol {


  //Nested type declaration start

    final public class Unknown6 : GeneratedMessage, GeneratedMessageProtocol {


      //Nested type declaration start

        final public class Unknown2 : GeneratedMessage, GeneratedMessageProtocol {
          public private(set) var unknown1:NSData = NSData()

          public private(set) var hasUnknown1:Bool = false
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
            if !hasUnknown1 {
              return false
            }
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
            if hasUnknown1 {
              try output.writeData(1, value:unknown1)
            }
            try unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUnknown1 {
              serialize_size += unknown1.computeDataSize(1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
          }
          public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.Unknown6.Unknown2> {
            var mergedArray = Array<ResponseEnvelop.Unknown6.Unknown2>()
            while let value = try parseFromDelimitedFromInputStream(input) {
              mergedArray += [value]
            }
            return mergedArray
          }
          public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Unknown6.Unknown2? {
            return try ResponseEnvelop.Unknown6.Unknown2.Builder().mergeDelimitedFromInputStream(input)?.build()
          }
          public class func parseFromData(data:NSData) throws -> ResponseEnvelop.Unknown6.Unknown2 {
            return try ResponseEnvelop.Unknown6.Unknown2.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
          }
          public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Unknown6.Unknown2 {
            return try ResponseEnvelop.Unknown6.Unknown2.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Unknown6.Unknown2 {
            return try ResponseEnvelop.Unknown6.Unknown2.Builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Unknown6.Unknown2 {
            return try ResponseEnvelop.Unknown6.Unknown2.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Unknown6.Unknown2 {
            return try ResponseEnvelop.Unknown6.Unknown2.Builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Unknown6.Unknown2 {
            return try ResponseEnvelop.Unknown6.Unknown2.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func getBuilder() -> ResponseEnvelop.Unknown6.Unknown2.Builder {
            return ResponseEnvelop.Unknown6.Unknown2.classBuilder() as! ResponseEnvelop.Unknown6.Unknown2.Builder
          }
          public func getBuilder() -> ResponseEnvelop.Unknown6.Unknown2.Builder {
            return classBuilder() as! ResponseEnvelop.Unknown6.Unknown2.Builder
          }
          public override class func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.Unknown6.Unknown2.Builder()
          }
          public override func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.Unknown6.Unknown2.Builder()
          }
          public func toBuilder() throws -> ResponseEnvelop.Unknown6.Unknown2.Builder {
            return try ResponseEnvelop.Unknown6.Unknown2.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:ResponseEnvelop.Unknown6.Unknown2) throws -> ResponseEnvelop.Unknown6.Unknown2.Builder {
            return try ResponseEnvelop.Unknown6.Unknown2.Builder().mergeFrom(prototype)
          }
          override public func getDescription(indent:String) throws -> String {
            var output:String = ""
            if hasUnknown1 {
              output += "\(indent) unknown1: \(unknown1) \n"
            }
            output += unknownFields.getDescription(indent)
            return output
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasUnknown1 {
                     hashCode = (hashCode &* 31) &+ unknown1.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "ResponseEnvelop.Unknown6.Unknown2"
          }
          override public func className() -> String {
              return "ResponseEnvelop.Unknown6.Unknown2"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return ResponseEnvelop.Unknown6.Unknown2.self
          }
          //Meta information declaration end

          final public class Builder : GeneratedMessageBuilder {
            private var builderResult:ResponseEnvelop.Unknown6.Unknown2 = ResponseEnvelop.Unknown6.Unknown2()
            public func getMessage() -> ResponseEnvelop.Unknown6.Unknown2 {
                return builderResult
            }

            required override public init () {
               super.init()
            }
            public var hasUnknown1:Bool {
                 get {
                      return builderResult.hasUnknown1
                 }
            }
            public var unknown1:NSData {
                 get {
                      return builderResult.unknown1
                 }
                 set (value) {
                     builderResult.hasUnknown1 = true
                     builderResult.unknown1 = value
                 }
            }
            public func setUnknown1(value:NSData) -> ResponseEnvelop.Unknown6.Unknown2.Builder {
              self.unknown1 = value
              return self
            }
            public func clearUnknown1() -> ResponseEnvelop.Unknown6.Unknown2.Builder{
                 builderResult.hasUnknown1 = false
                 builderResult.unknown1 = NSData()
                 return self
            }
            override public var internalGetResult:GeneratedMessage {
                 get {
                    return builderResult
                 }
            }
            public override func clear() -> ResponseEnvelop.Unknown6.Unknown2.Builder {
              builderResult = ResponseEnvelop.Unknown6.Unknown2()
              return self
            }
            public override func clone() throws -> ResponseEnvelop.Unknown6.Unknown2.Builder {
              return try ResponseEnvelop.Unknown6.Unknown2.builderWithPrototype(builderResult)
            }
            public override func build() throws -> ResponseEnvelop.Unknown6.Unknown2 {
                 try checkInitialized()
                 return buildPartial()
            }
            public func buildPartial() -> ResponseEnvelop.Unknown6.Unknown2 {
              let returnMe:ResponseEnvelop.Unknown6.Unknown2 = builderResult
              return returnMe
            }
            public func mergeFrom(other:ResponseEnvelop.Unknown6.Unknown2) throws -> ResponseEnvelop.Unknown6.Unknown2.Builder {
              if other == ResponseEnvelop.Unknown6.Unknown2() {
               return self
              }
              if other.hasUnknown1 {
                   unknown1 = other.unknown1
              }
              try mergeUnknownFields(other.unknownFields)
              return self
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Unknown6.Unknown2.Builder {
                 return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Unknown6.Unknown2.Builder {
              let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
              while (true) {
                let protobufTag = try input.readTag()
                switch protobufTag {
                case 0: 
                  self.unknownFields = try unknownFieldsBuilder.build()
                  return self

                case 10 :
                  unknown1 = try input.readData()

                default:
                  if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                     unknownFields = try unknownFieldsBuilder.build()
                     return self
                  }
                }
              }
            }
          }

        }

      //Nested type declaration end

      public private(set) var unknown1:Int32 = Int32(0)

      public private(set) var hasUnknown1:Bool = false
      public private(set) var unknown2:ResponseEnvelop.Unknown6.Unknown2!
      public private(set) var hasUnknown2:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasUnknown1 {
          return false
        }
        if !hasUnknown2 {
          return false
        }
        if !unknown2.isInitialized() {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasUnknown1 {
          try output.writeInt32(1, value:unknown1)
        }
        if hasUnknown2 {
          try output.writeMessage(2, value:unknown2)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUnknown1 {
          serialize_size += unknown1.computeInt32Size(1)
        }
        if hasUnknown2 {
            if let varSizeunknown2 = unknown2?.computeMessageSize(2) {
                serialize_size += varSizeunknown2
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.Unknown6> {
        var mergedArray = Array<ResponseEnvelop.Unknown6>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Unknown6? {
        return try ResponseEnvelop.Unknown6.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.Unknown6 {
        return try ResponseEnvelop.Unknown6.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Unknown6 {
        return try ResponseEnvelop.Unknown6.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Unknown6 {
        return try ResponseEnvelop.Unknown6.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Unknown6 {
        return try ResponseEnvelop.Unknown6.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Unknown6 {
        return try ResponseEnvelop.Unknown6.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Unknown6 {
        return try ResponseEnvelop.Unknown6.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.Unknown6.Builder {
        return ResponseEnvelop.Unknown6.classBuilder() as! ResponseEnvelop.Unknown6.Builder
      }
      public func getBuilder() -> ResponseEnvelop.Unknown6.Builder {
        return classBuilder() as! ResponseEnvelop.Unknown6.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.Unknown6.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.Unknown6.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.Unknown6.Builder {
        return try ResponseEnvelop.Unknown6.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.Unknown6) throws -> ResponseEnvelop.Unknown6.Builder {
        return try ResponseEnvelop.Unknown6.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasUnknown1 {
          output += "\(indent) unknown1: \(unknown1) \n"
        }
        if hasUnknown2 {
          output += "\(indent) unknown2 {\n"
          if let outDescUnknown2 = unknown2 {
            output += try outDescUnknown2.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasUnknown1 {
                 hashCode = (hashCode &* 31) &+ unknown1.hashValue
              }
              if hasUnknown2 {
                  if let hashValueunknown2 = unknown2?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueunknown2
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.Unknown6"
      }
      override public func className() -> String {
          return "ResponseEnvelop.Unknown6"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.Unknown6.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.Unknown6 = ResponseEnvelop.Unknown6()
        public func getMessage() -> ResponseEnvelop.Unknown6 {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasUnknown1:Bool {
             get {
                  return builderResult.hasUnknown1
             }
        }
        public var unknown1:Int32 {
             get {
                  return builderResult.unknown1
             }
             set (value) {
                 builderResult.hasUnknown1 = true
                 builderResult.unknown1 = value
             }
        }
        public func setUnknown1(value:Int32) -> ResponseEnvelop.Unknown6.Builder {
          self.unknown1 = value
          return self
        }
        public func clearUnknown1() -> ResponseEnvelop.Unknown6.Builder{
             builderResult.hasUnknown1 = false
             builderResult.unknown1 = Int32(0)
             return self
        }
        public var hasUnknown2:Bool {
             get {
                 return builderResult.hasUnknown2
             }
        }
        public var unknown2:ResponseEnvelop.Unknown6.Unknown2! {
             get {
                 if unknown2Builder_ != nil {
                    builderResult.unknown2 = unknown2Builder_.getMessage()
                 }
                 return builderResult.unknown2
             }
             set (value) {
                 builderResult.hasUnknown2 = true
                 builderResult.unknown2 = value
             }
        }
        private var unknown2Builder_:ResponseEnvelop.Unknown6.Unknown2.Builder! {
             didSet {
                builderResult.hasUnknown2 = true
             }
        }
        public func getUnknown2Builder() -> ResponseEnvelop.Unknown6.Unknown2.Builder {
          if unknown2Builder_ == nil {
             unknown2Builder_ = ResponseEnvelop.Unknown6.Unknown2.Builder()
             builderResult.unknown2 = unknown2Builder_.getMessage()
             if unknown2 != nil {
                try! unknown2Builder_.mergeFrom(unknown2)
             }
          }
          return unknown2Builder_
        }
        public func setUnknown2(value:ResponseEnvelop.Unknown6.Unknown2!) -> ResponseEnvelop.Unknown6.Builder {
          self.unknown2 = value
          return self
        }
        public func mergeUnknown2(value:ResponseEnvelop.Unknown6.Unknown2) throws -> ResponseEnvelop.Unknown6.Builder {
          if builderResult.hasUnknown2 {
            builderResult.unknown2 = try ResponseEnvelop.Unknown6.Unknown2.builderWithPrototype(builderResult.unknown2).mergeFrom(value).buildPartial()
          } else {
            builderResult.unknown2 = value
          }
          builderResult.hasUnknown2 = true
          return self
        }
        public func clearUnknown2() -> ResponseEnvelop.Unknown6.Builder {
          unknown2Builder_ = nil
          builderResult.hasUnknown2 = false
          builderResult.unknown2 = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.Unknown6.Builder {
          builderResult = ResponseEnvelop.Unknown6()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.Unknown6.Builder {
          return try ResponseEnvelop.Unknown6.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.Unknown6 {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.Unknown6 {
          let returnMe:ResponseEnvelop.Unknown6 = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.Unknown6) throws -> ResponseEnvelop.Unknown6.Builder {
          if other == ResponseEnvelop.Unknown6() {
           return self
          }
          if other.hasUnknown1 {
               unknown1 = other.unknown1
          }
          if (other.hasUnknown2) {
              try mergeUnknown2(other.unknown2)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Unknown6.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Unknown6.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              unknown1 = try input.readInt32()

            case 18 :
              let subBuilder:ResponseEnvelop.Unknown6.Unknown2.Builder = ResponseEnvelop.Unknown6.Unknown2.Builder()
              if hasUnknown2 {
                try subBuilder.mergeFrom(unknown2)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              unknown2 = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class AuthTicket : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var start:NSData = NSData()

      public private(set) var hasStart:Bool = false
      public private(set) var expireTimestampMs:UInt64 = UInt64(0)

      public private(set) var hasExpireTimestampMs:Bool = false
      public private(set) var end:NSData = NSData()

      public private(set) var hasEnd:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasStart {
          try output.writeData(1, value:start)
        }
        if hasExpireTimestampMs {
          try output.writeUInt64(2, value:expireTimestampMs)
        }
        if hasEnd {
          try output.writeData(3, value:end)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasStart {
          serialize_size += start.computeDataSize(1)
        }
        if hasExpireTimestampMs {
          serialize_size += expireTimestampMs.computeUInt64Size(2)
        }
        if hasEnd {
          serialize_size += end.computeDataSize(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.AuthTicket> {
        var mergedArray = Array<ResponseEnvelop.AuthTicket>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.AuthTicket? {
        return try ResponseEnvelop.AuthTicket.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.AuthTicket {
        return try ResponseEnvelop.AuthTicket.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AuthTicket {
        return try ResponseEnvelop.AuthTicket.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.AuthTicket {
        return try ResponseEnvelop.AuthTicket.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AuthTicket {
        return try ResponseEnvelop.AuthTicket.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.AuthTicket {
        return try ResponseEnvelop.AuthTicket.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AuthTicket {
        return try ResponseEnvelop.AuthTicket.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.AuthTicket.Builder {
        return ResponseEnvelop.AuthTicket.classBuilder() as! ResponseEnvelop.AuthTicket.Builder
      }
      public func getBuilder() -> ResponseEnvelop.AuthTicket.Builder {
        return classBuilder() as! ResponseEnvelop.AuthTicket.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.AuthTicket.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.AuthTicket.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.AuthTicket.Builder {
        return try ResponseEnvelop.AuthTicket.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.AuthTicket) throws -> ResponseEnvelop.AuthTicket.Builder {
        return try ResponseEnvelop.AuthTicket.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasStart {
          output += "\(indent) start: \(start) \n"
        }
        if hasExpireTimestampMs {
          output += "\(indent) expireTimestampMs: \(expireTimestampMs) \n"
        }
        if hasEnd {
          output += "\(indent) end: \(end) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasStart {
                 hashCode = (hashCode &* 31) &+ start.hashValue
              }
              if hasExpireTimestampMs {
                 hashCode = (hashCode &* 31) &+ expireTimestampMs.hashValue
              }
              if hasEnd {
                 hashCode = (hashCode &* 31) &+ end.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.AuthTicket"
      }
      override public func className() -> String {
          return "ResponseEnvelop.AuthTicket"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.AuthTicket.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.AuthTicket = ResponseEnvelop.AuthTicket()
        public func getMessage() -> ResponseEnvelop.AuthTicket {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasStart:Bool {
             get {
                  return builderResult.hasStart
             }
        }
        public var start:NSData {
             get {
                  return builderResult.start
             }
             set (value) {
                 builderResult.hasStart = true
                 builderResult.start = value
             }
        }
        public func setStart(value:NSData) -> ResponseEnvelop.AuthTicket.Builder {
          self.start = value
          return self
        }
        public func clearStart() -> ResponseEnvelop.AuthTicket.Builder{
             builderResult.hasStart = false
             builderResult.start = NSData()
             return self
        }
        public var hasExpireTimestampMs:Bool {
             get {
                  return builderResult.hasExpireTimestampMs
             }
        }
        public var expireTimestampMs:UInt64 {
             get {
                  return builderResult.expireTimestampMs
             }
             set (value) {
                 builderResult.hasExpireTimestampMs = true
                 builderResult.expireTimestampMs = value
             }
        }
        public func setExpireTimestampMs(value:UInt64) -> ResponseEnvelop.AuthTicket.Builder {
          self.expireTimestampMs = value
          return self
        }
        public func clearExpireTimestampMs() -> ResponseEnvelop.AuthTicket.Builder{
             builderResult.hasExpireTimestampMs = false
             builderResult.expireTimestampMs = UInt64(0)
             return self
        }
        public var hasEnd:Bool {
             get {
                  return builderResult.hasEnd
             }
        }
        public var end:NSData {
             get {
                  return builderResult.end
             }
             set (value) {
                 builderResult.hasEnd = true
                 builderResult.end = value
             }
        }
        public func setEnd(value:NSData) -> ResponseEnvelop.AuthTicket.Builder {
          self.end = value
          return self
        }
        public func clearEnd() -> ResponseEnvelop.AuthTicket.Builder{
             builderResult.hasEnd = false
             builderResult.end = NSData()
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.AuthTicket.Builder {
          builderResult = ResponseEnvelop.AuthTicket()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.AuthTicket.Builder {
          return try ResponseEnvelop.AuthTicket.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.AuthTicket {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.AuthTicket {
          let returnMe:ResponseEnvelop.AuthTicket = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.AuthTicket) throws -> ResponseEnvelop.AuthTicket.Builder {
          if other == ResponseEnvelop.AuthTicket() {
           return self
          }
          if other.hasStart {
               start = other.start
          }
          if other.hasExpireTimestampMs {
               expireTimestampMs = other.expireTimestampMs
          }
          if other.hasEnd {
               end = other.end
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.AuthTicket.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AuthTicket.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              start = try input.readData()

            case 16 :
              expireTimestampMs = try input.readUInt64()

            case 26 :
              end = try input.readData()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class HeartbeatPayload : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var cells:Array<ResponseEnvelop.ClientMapCell>  = Array<ResponseEnvelop.ClientMapCell>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        var isInitcells:Bool = true
        for oneElementcells in cells {
            if (!oneElementcells.isInitialized()) {
                isInitcells = false
                break 
            }
        }
        if !isInitcells {
         return isInitcells
         }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        for oneElementcells in cells {
            try output.writeMessage(1, value:oneElementcells)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        for oneElementcells in cells {
            serialize_size += oneElementcells.computeMessageSize(1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.HeartbeatPayload> {
        var mergedArray = Array<ResponseEnvelop.HeartbeatPayload>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.HeartbeatPayload? {
        return try ResponseEnvelop.HeartbeatPayload.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.HeartbeatPayload {
        return try ResponseEnvelop.HeartbeatPayload.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.HeartbeatPayload {
        return try ResponseEnvelop.HeartbeatPayload.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.HeartbeatPayload {
        return try ResponseEnvelop.HeartbeatPayload.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.HeartbeatPayload {
        return try ResponseEnvelop.HeartbeatPayload.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.HeartbeatPayload {
        return try ResponseEnvelop.HeartbeatPayload.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.HeartbeatPayload {
        return try ResponseEnvelop.HeartbeatPayload.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.HeartbeatPayload.Builder {
        return ResponseEnvelop.HeartbeatPayload.classBuilder() as! ResponseEnvelop.HeartbeatPayload.Builder
      }
      public func getBuilder() -> ResponseEnvelop.HeartbeatPayload.Builder {
        return classBuilder() as! ResponseEnvelop.HeartbeatPayload.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.HeartbeatPayload.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.HeartbeatPayload.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.HeartbeatPayload.Builder {
        return try ResponseEnvelop.HeartbeatPayload.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.HeartbeatPayload) throws -> ResponseEnvelop.HeartbeatPayload.Builder {
        return try ResponseEnvelop.HeartbeatPayload.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        var cellsElementIndex:Int = 0
        for oneElementcells in cells {
            output += "\(indent) cells[\(cellsElementIndex)] {\n"
            output += try oneElementcells.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            cellsElementIndex += 1
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for oneElementcells in cells {
                  hashCode = (hashCode &* 31) &+ oneElementcells.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.HeartbeatPayload"
      }
      override public func className() -> String {
          return "ResponseEnvelop.HeartbeatPayload"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.HeartbeatPayload.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.HeartbeatPayload = ResponseEnvelop.HeartbeatPayload()
        public func getMessage() -> ResponseEnvelop.HeartbeatPayload {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var cells:Array<ResponseEnvelop.ClientMapCell> {
             get {
                 return builderResult.cells
             }
             set (value) {
                 builderResult.cells = value
             }
        }
        public func setCells(value:Array<ResponseEnvelop.ClientMapCell>) -> ResponseEnvelop.HeartbeatPayload.Builder {
          self.cells = value
          return self
        }
        public func clearCells() -> ResponseEnvelop.HeartbeatPayload.Builder {
          builderResult.cells.removeAll(keepCapacity: false)
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.HeartbeatPayload.Builder {
          builderResult = ResponseEnvelop.HeartbeatPayload()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.HeartbeatPayload.Builder {
          return try ResponseEnvelop.HeartbeatPayload.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.HeartbeatPayload {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.HeartbeatPayload {
          let returnMe:ResponseEnvelop.HeartbeatPayload = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.HeartbeatPayload) throws -> ResponseEnvelop.HeartbeatPayload.Builder {
          if other == ResponseEnvelop.HeartbeatPayload() {
           return self
          }
          if !other.cells.isEmpty  {
             builderResult.cells += other.cells
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.HeartbeatPayload.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.HeartbeatPayload.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              let subBuilder = ResponseEnvelop.ClientMapCell.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              cells += [subBuilder.buildPartial()]

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class ClientMapCell : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var s2CellId:UInt64 = UInt64(0)

      public private(set) var hasS2CellId:Bool = false
      public private(set) var asOfTimeMs:Int64 = Int64(0)

      public private(set) var hasAsOfTimeMs:Bool = false
      public private(set) var fort:Array<ResponseEnvelop.PokemonFortProto>  = Array<ResponseEnvelop.PokemonFortProto>()
      public private(set) var spawnPoint:Array<ResponseEnvelop.ClientSpawnPointProto>  = Array<ResponseEnvelop.ClientSpawnPointProto>()
      public private(set) var wildPokemon:Array<ResponseEnvelop.WildPokemonProto>  = Array<ResponseEnvelop.WildPokemonProto>()
      //unknown DeletedObject = 6;
      public private(set) var isTruncatedList:Bool = false

      public private(set) var hasIsTruncatedList:Bool = false
      public private(set) var fortSummary:Array<ResponseEnvelop.PokemonSummaryFortProto>  = Array<ResponseEnvelop.PokemonSummaryFortProto>()
      public private(set) var decimatedSpawnPoint:Array<ResponseEnvelop.ClientSpawnPointProto>  = Array<ResponseEnvelop.ClientSpawnPointProto>()
      public private(set) var mapPokemon:Array<ResponseEnvelop.MapPokemonProto>  = Array<ResponseEnvelop.MapPokemonProto>()
      public private(set) var nearbyPokemon:Array<ResponseEnvelop.NearbyPokemonProto>  = Array<ResponseEnvelop.NearbyPokemonProto>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasS2CellId {
          return false
        }
        if !hasAsOfTimeMs {
          return false
        }
        var isInitfort:Bool = true
        for oneElementfort in fort {
            if (!oneElementfort.isInitialized()) {
                isInitfort = false
                break 
            }
        }
        if !isInitfort {
         return isInitfort
         }
        var isInitspawnPoint:Bool = true
        for oneElementspawnPoint in spawnPoint {
            if (!oneElementspawnPoint.isInitialized()) {
                isInitspawnPoint = false
                break 
            }
        }
        if !isInitspawnPoint {
         return isInitspawnPoint
         }
        var isInitfortSummary:Bool = true
        for oneElementfortSummary in fortSummary {
            if (!oneElementfortSummary.isInitialized()) {
                isInitfortSummary = false
                break 
            }
        }
        if !isInitfortSummary {
         return isInitfortSummary
         }
        var isInitdecimatedSpawnPoint:Bool = true
        for oneElementdecimatedSpawnPoint in decimatedSpawnPoint {
            if (!oneElementdecimatedSpawnPoint.isInitialized()) {
                isInitdecimatedSpawnPoint = false
                break 
            }
        }
        if !isInitdecimatedSpawnPoint {
         return isInitdecimatedSpawnPoint
         }
        var isInitmapPokemon:Bool = true
        for oneElementmapPokemon in mapPokemon {
            if (!oneElementmapPokemon.isInitialized()) {
                isInitmapPokemon = false
                break 
            }
        }
        if !isInitmapPokemon {
         return isInitmapPokemon
         }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasS2CellId {
          try output.writeUInt64(1, value:s2CellId)
        }
        if hasAsOfTimeMs {
          try output.writeInt64(2, value:asOfTimeMs)
        }
        for oneElementfort in fort {
            try output.writeMessage(3, value:oneElementfort)
        }
        for oneElementspawnPoint in spawnPoint {
            try output.writeMessage(4, value:oneElementspawnPoint)
        }
        for oneElementwildPokemon in wildPokemon {
            try output.writeMessage(5, value:oneElementwildPokemon)
        }
        if hasIsTruncatedList {
          try output.writeBool(7, value:isTruncatedList)
        }
        for oneElementfortSummary in fortSummary {
            try output.writeMessage(8, value:oneElementfortSummary)
        }
        for oneElementdecimatedSpawnPoint in decimatedSpawnPoint {
            try output.writeMessage(9, value:oneElementdecimatedSpawnPoint)
        }
        for oneElementmapPokemon in mapPokemon {
            try output.writeMessage(10, value:oneElementmapPokemon)
        }
        for oneElementnearbyPokemon in nearbyPokemon {
            try output.writeMessage(11, value:oneElementnearbyPokemon)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasS2CellId {
          serialize_size += s2CellId.computeUInt64Size(1)
        }
        if hasAsOfTimeMs {
          serialize_size += asOfTimeMs.computeInt64Size(2)
        }
        for oneElementfort in fort {
            serialize_size += oneElementfort.computeMessageSize(3)
        }
        for oneElementspawnPoint in spawnPoint {
            serialize_size += oneElementspawnPoint.computeMessageSize(4)
        }
        for oneElementwildPokemon in wildPokemon {
            serialize_size += oneElementwildPokemon.computeMessageSize(5)
        }
        if hasIsTruncatedList {
          serialize_size += isTruncatedList.computeBoolSize(7)
        }
        for oneElementfortSummary in fortSummary {
            serialize_size += oneElementfortSummary.computeMessageSize(8)
        }
        for oneElementdecimatedSpawnPoint in decimatedSpawnPoint {
            serialize_size += oneElementdecimatedSpawnPoint.computeMessageSize(9)
        }
        for oneElementmapPokemon in mapPokemon {
            serialize_size += oneElementmapPokemon.computeMessageSize(10)
        }
        for oneElementnearbyPokemon in nearbyPokemon {
            serialize_size += oneElementnearbyPokemon.computeMessageSize(11)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.ClientMapCell> {
        var mergedArray = Array<ResponseEnvelop.ClientMapCell>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ClientMapCell? {
        return try ResponseEnvelop.ClientMapCell.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.ClientMapCell {
        return try ResponseEnvelop.ClientMapCell.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ClientMapCell {
        return try ResponseEnvelop.ClientMapCell.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ClientMapCell {
        return try ResponseEnvelop.ClientMapCell.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ClientMapCell {
        return try ResponseEnvelop.ClientMapCell.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ClientMapCell {
        return try ResponseEnvelop.ClientMapCell.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ClientMapCell {
        return try ResponseEnvelop.ClientMapCell.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.ClientMapCell.Builder {
        return ResponseEnvelop.ClientMapCell.classBuilder() as! ResponseEnvelop.ClientMapCell.Builder
      }
      public func getBuilder() -> ResponseEnvelop.ClientMapCell.Builder {
        return classBuilder() as! ResponseEnvelop.ClientMapCell.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ClientMapCell.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ClientMapCell.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.ClientMapCell.Builder {
        return try ResponseEnvelop.ClientMapCell.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.ClientMapCell) throws -> ResponseEnvelop.ClientMapCell.Builder {
        return try ResponseEnvelop.ClientMapCell.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasS2CellId {
          output += "\(indent) s2CellId: \(s2CellId) \n"
        }
        if hasAsOfTimeMs {
          output += "\(indent) asOfTimeMs: \(asOfTimeMs) \n"
        }
        var fortElementIndex:Int = 0
        for oneElementfort in fort {
            output += "\(indent) fort[\(fortElementIndex)] {\n"
            output += try oneElementfort.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            fortElementIndex += 1
        }
        var spawnPointElementIndex:Int = 0
        for oneElementspawnPoint in spawnPoint {
            output += "\(indent) spawnPoint[\(spawnPointElementIndex)] {\n"
            output += try oneElementspawnPoint.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            spawnPointElementIndex += 1
        }
        var wildPokemonElementIndex:Int = 0
        for oneElementwildPokemon in wildPokemon {
            output += "\(indent) wildPokemon[\(wildPokemonElementIndex)] {\n"
            output += try oneElementwildPokemon.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            wildPokemonElementIndex += 1
        }
        if hasIsTruncatedList {
          output += "\(indent) isTruncatedList: \(isTruncatedList) \n"
        }
        var fortSummaryElementIndex:Int = 0
        for oneElementfortSummary in fortSummary {
            output += "\(indent) fortSummary[\(fortSummaryElementIndex)] {\n"
            output += try oneElementfortSummary.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            fortSummaryElementIndex += 1
        }
        var decimatedSpawnPointElementIndex:Int = 0
        for oneElementdecimatedSpawnPoint in decimatedSpawnPoint {
            output += "\(indent) decimatedSpawnPoint[\(decimatedSpawnPointElementIndex)] {\n"
            output += try oneElementdecimatedSpawnPoint.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            decimatedSpawnPointElementIndex += 1
        }
        var mapPokemonElementIndex:Int = 0
        for oneElementmapPokemon in mapPokemon {
            output += "\(indent) mapPokemon[\(mapPokemonElementIndex)] {\n"
            output += try oneElementmapPokemon.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            mapPokemonElementIndex += 1
        }
        var nearbyPokemonElementIndex:Int = 0
        for oneElementnearbyPokemon in nearbyPokemon {
            output += "\(indent) nearbyPokemon[\(nearbyPokemonElementIndex)] {\n"
            output += try oneElementnearbyPokemon.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            nearbyPokemonElementIndex += 1
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasS2CellId {
                 hashCode = (hashCode &* 31) &+ s2CellId.hashValue
              }
              if hasAsOfTimeMs {
                 hashCode = (hashCode &* 31) &+ asOfTimeMs.hashValue
              }
              for oneElementfort in fort {
                  hashCode = (hashCode &* 31) &+ oneElementfort.hashValue
              }
              for oneElementspawnPoint in spawnPoint {
                  hashCode = (hashCode &* 31) &+ oneElementspawnPoint.hashValue
              }
              for oneElementwildPokemon in wildPokemon {
                  hashCode = (hashCode &* 31) &+ oneElementwildPokemon.hashValue
              }
              if hasIsTruncatedList {
                 hashCode = (hashCode &* 31) &+ isTruncatedList.hashValue
              }
              for oneElementfortSummary in fortSummary {
                  hashCode = (hashCode &* 31) &+ oneElementfortSummary.hashValue
              }
              for oneElementdecimatedSpawnPoint in decimatedSpawnPoint {
                  hashCode = (hashCode &* 31) &+ oneElementdecimatedSpawnPoint.hashValue
              }
              for oneElementmapPokemon in mapPokemon {
                  hashCode = (hashCode &* 31) &+ oneElementmapPokemon.hashValue
              }
              for oneElementnearbyPokemon in nearbyPokemon {
                  hashCode = (hashCode &* 31) &+ oneElementnearbyPokemon.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.ClientMapCell"
      }
      override public func className() -> String {
          return "ResponseEnvelop.ClientMapCell"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.ClientMapCell.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.ClientMapCell = ResponseEnvelop.ClientMapCell()
        public func getMessage() -> ResponseEnvelop.ClientMapCell {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasS2CellId:Bool {
             get {
                  return builderResult.hasS2CellId
             }
        }
        public var s2CellId:UInt64 {
             get {
                  return builderResult.s2CellId
             }
             set (value) {
                 builderResult.hasS2CellId = true
                 builderResult.s2CellId = value
             }
        }
        public func setS2CellId(value:UInt64) -> ResponseEnvelop.ClientMapCell.Builder {
          self.s2CellId = value
          return self
        }
        public func clearS2CellId() -> ResponseEnvelop.ClientMapCell.Builder{
             builderResult.hasS2CellId = false
             builderResult.s2CellId = UInt64(0)
             return self
        }
        public var hasAsOfTimeMs:Bool {
             get {
                  return builderResult.hasAsOfTimeMs
             }
        }
        public var asOfTimeMs:Int64 {
             get {
                  return builderResult.asOfTimeMs
             }
             set (value) {
                 builderResult.hasAsOfTimeMs = true
                 builderResult.asOfTimeMs = value
             }
        }
        public func setAsOfTimeMs(value:Int64) -> ResponseEnvelop.ClientMapCell.Builder {
          self.asOfTimeMs = value
          return self
        }
        public func clearAsOfTimeMs() -> ResponseEnvelop.ClientMapCell.Builder{
             builderResult.hasAsOfTimeMs = false
             builderResult.asOfTimeMs = Int64(0)
             return self
        }
        public var fort:Array<ResponseEnvelop.PokemonFortProto> {
             get {
                 return builderResult.fort
             }
             set (value) {
                 builderResult.fort = value
             }
        }
        public func setFort(value:Array<ResponseEnvelop.PokemonFortProto>) -> ResponseEnvelop.ClientMapCell.Builder {
          self.fort = value
          return self
        }
        public func clearFort() -> ResponseEnvelop.ClientMapCell.Builder {
          builderResult.fort.removeAll(keepCapacity: false)
          return self
        }
        public var spawnPoint:Array<ResponseEnvelop.ClientSpawnPointProto> {
             get {
                 return builderResult.spawnPoint
             }
             set (value) {
                 builderResult.spawnPoint = value
             }
        }
        public func setSpawnPoint(value:Array<ResponseEnvelop.ClientSpawnPointProto>) -> ResponseEnvelop.ClientMapCell.Builder {
          self.spawnPoint = value
          return self
        }
        public func clearSpawnPoint() -> ResponseEnvelop.ClientMapCell.Builder {
          builderResult.spawnPoint.removeAll(keepCapacity: false)
          return self
        }
        public var wildPokemon:Array<ResponseEnvelop.WildPokemonProto> {
             get {
                 return builderResult.wildPokemon
             }
             set (value) {
                 builderResult.wildPokemon = value
             }
        }
        public func setWildPokemon(value:Array<ResponseEnvelop.WildPokemonProto>) -> ResponseEnvelop.ClientMapCell.Builder {
          self.wildPokemon = value
          return self
        }
        public func clearWildPokemon() -> ResponseEnvelop.ClientMapCell.Builder {
          builderResult.wildPokemon.removeAll(keepCapacity: false)
          return self
        }
        public var hasIsTruncatedList:Bool {
             get {
                  return builderResult.hasIsTruncatedList
             }
        }
        public var isTruncatedList:Bool {
             get {
                  return builderResult.isTruncatedList
             }
             set (value) {
                 builderResult.hasIsTruncatedList = true
                 builderResult.isTruncatedList = value
             }
        }
        public func setIsTruncatedList(value:Bool) -> ResponseEnvelop.ClientMapCell.Builder {
          self.isTruncatedList = value
          return self
        }
        public func clearIsTruncatedList() -> ResponseEnvelop.ClientMapCell.Builder{
             builderResult.hasIsTruncatedList = false
             builderResult.isTruncatedList = false
             return self
        }
        public var fortSummary:Array<ResponseEnvelop.PokemonSummaryFortProto> {
             get {
                 return builderResult.fortSummary
             }
             set (value) {
                 builderResult.fortSummary = value
             }
        }
        public func setFortSummary(value:Array<ResponseEnvelop.PokemonSummaryFortProto>) -> ResponseEnvelop.ClientMapCell.Builder {
          self.fortSummary = value
          return self
        }
        public func clearFortSummary() -> ResponseEnvelop.ClientMapCell.Builder {
          builderResult.fortSummary.removeAll(keepCapacity: false)
          return self
        }
        public var decimatedSpawnPoint:Array<ResponseEnvelop.ClientSpawnPointProto> {
             get {
                 return builderResult.decimatedSpawnPoint
             }
             set (value) {
                 builderResult.decimatedSpawnPoint = value
             }
        }
        public func setDecimatedSpawnPoint(value:Array<ResponseEnvelop.ClientSpawnPointProto>) -> ResponseEnvelop.ClientMapCell.Builder {
          self.decimatedSpawnPoint = value
          return self
        }
        public func clearDecimatedSpawnPoint() -> ResponseEnvelop.ClientMapCell.Builder {
          builderResult.decimatedSpawnPoint.removeAll(keepCapacity: false)
          return self
        }
        public var mapPokemon:Array<ResponseEnvelop.MapPokemonProto> {
             get {
                 return builderResult.mapPokemon
             }
             set (value) {
                 builderResult.mapPokemon = value
             }
        }
        public func setMapPokemon(value:Array<ResponseEnvelop.MapPokemonProto>) -> ResponseEnvelop.ClientMapCell.Builder {
          self.mapPokemon = value
          return self
        }
        public func clearMapPokemon() -> ResponseEnvelop.ClientMapCell.Builder {
          builderResult.mapPokemon.removeAll(keepCapacity: false)
          return self
        }
        public var nearbyPokemon:Array<ResponseEnvelop.NearbyPokemonProto> {
             get {
                 return builderResult.nearbyPokemon
             }
             set (value) {
                 builderResult.nearbyPokemon = value
             }
        }
        public func setNearbyPokemon(value:Array<ResponseEnvelop.NearbyPokemonProto>) -> ResponseEnvelop.ClientMapCell.Builder {
          self.nearbyPokemon = value
          return self
        }
        public func clearNearbyPokemon() -> ResponseEnvelop.ClientMapCell.Builder {
          builderResult.nearbyPokemon.removeAll(keepCapacity: false)
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.ClientMapCell.Builder {
          builderResult = ResponseEnvelop.ClientMapCell()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.ClientMapCell.Builder {
          return try ResponseEnvelop.ClientMapCell.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.ClientMapCell {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.ClientMapCell {
          let returnMe:ResponseEnvelop.ClientMapCell = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.ClientMapCell) throws -> ResponseEnvelop.ClientMapCell.Builder {
          if other == ResponseEnvelop.ClientMapCell() {
           return self
          }
          if other.hasS2CellId {
               s2CellId = other.s2CellId
          }
          if other.hasAsOfTimeMs {
               asOfTimeMs = other.asOfTimeMs
          }
          if !other.fort.isEmpty  {
             builderResult.fort += other.fort
          }
          if !other.spawnPoint.isEmpty  {
             builderResult.spawnPoint += other.spawnPoint
          }
          if !other.wildPokemon.isEmpty  {
             builderResult.wildPokemon += other.wildPokemon
          }
          if other.hasIsTruncatedList {
               isTruncatedList = other.isTruncatedList
          }
          if !other.fortSummary.isEmpty  {
             builderResult.fortSummary += other.fortSummary
          }
          if !other.decimatedSpawnPoint.isEmpty  {
             builderResult.decimatedSpawnPoint += other.decimatedSpawnPoint
          }
          if !other.mapPokemon.isEmpty  {
             builderResult.mapPokemon += other.mapPokemon
          }
          if !other.nearbyPokemon.isEmpty  {
             builderResult.nearbyPokemon += other.nearbyPokemon
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ClientMapCell.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ClientMapCell.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              s2CellId = try input.readUInt64()

            case 16 :
              asOfTimeMs = try input.readInt64()

            case 26 :
              let subBuilder = ResponseEnvelop.PokemonFortProto.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              fort += [subBuilder.buildPartial()]

            case 34 :
              let subBuilder = ResponseEnvelop.ClientSpawnPointProto.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              spawnPoint += [subBuilder.buildPartial()]

            case 42 :
              let subBuilder = ResponseEnvelop.WildPokemonProto.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              wildPokemon += [subBuilder.buildPartial()]

            case 56 :
              isTruncatedList = try input.readBool()

            case 66 :
              let subBuilder = ResponseEnvelop.PokemonSummaryFortProto.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              fortSummary += [subBuilder.buildPartial()]

            case 74 :
              let subBuilder = ResponseEnvelop.ClientSpawnPointProto.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              decimatedSpawnPoint += [subBuilder.buildPartial()]

            case 82 :
              let subBuilder = ResponseEnvelop.MapPokemonProto.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              mapPokemon += [subBuilder.buildPartial()]

            case 90 :
              let subBuilder = ResponseEnvelop.NearbyPokemonProto.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              nearbyPokemon += [subBuilder.buildPartial()]

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class MapPokemonProto : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var spawnPointId:String = ""

      public private(set) var hasSpawnPointId:Bool = false
      public private(set) var encounterId:UInt64 = UInt64(0)

      public private(set) var hasEncounterId:Bool = false
      public private(set) var pokedexTypeId:Int32 = Int32(0)

      public private(set) var hasPokedexTypeId:Bool = false
      public private(set) var expirationTimeMs:Int64 = Int64(0)

      public private(set) var hasExpirationTimeMs:Bool = false
      public private(set) var latitude:Double = Double(0)

      public private(set) var hasLatitude:Bool = false
      public private(set) var longitude:Double = Double(0)

      public private(set) var hasLongitude:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasSpawnPointId {
          return false
        }
        if !hasEncounterId {
          return false
        }
        if !hasPokedexTypeId {
          return false
        }
        if !hasExpirationTimeMs {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasSpawnPointId {
          try output.writeString(1, value:spawnPointId)
        }
        if hasEncounterId {
          try output.writeFixed64(2, value:encounterId)
        }
        if hasPokedexTypeId {
          try output.writeInt32(3, value:pokedexTypeId)
        }
        if hasExpirationTimeMs {
          try output.writeInt64(4, value:expirationTimeMs)
        }
        if hasLatitude {
          try output.writeDouble(5, value:latitude)
        }
        if hasLongitude {
          try output.writeDouble(6, value:longitude)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSpawnPointId {
          serialize_size += spawnPointId.computeStringSize(1)
        }
        if hasEncounterId {
          serialize_size += encounterId.computeFixed64Size(2)
        }
        if hasPokedexTypeId {
          serialize_size += pokedexTypeId.computeInt32Size(3)
        }
        if hasExpirationTimeMs {
          serialize_size += expirationTimeMs.computeInt64Size(4)
        }
        if hasLatitude {
          serialize_size += latitude.computeDoubleSize(5)
        }
        if hasLongitude {
          serialize_size += longitude.computeDoubleSize(6)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.MapPokemonProto> {
        var mergedArray = Array<ResponseEnvelop.MapPokemonProto>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.MapPokemonProto? {
        return try ResponseEnvelop.MapPokemonProto.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.MapPokemonProto {
        return try ResponseEnvelop.MapPokemonProto.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.MapPokemonProto {
        return try ResponseEnvelop.MapPokemonProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.MapPokemonProto {
        return try ResponseEnvelop.MapPokemonProto.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.MapPokemonProto {
        return try ResponseEnvelop.MapPokemonProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.MapPokemonProto {
        return try ResponseEnvelop.MapPokemonProto.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.MapPokemonProto {
        return try ResponseEnvelop.MapPokemonProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.MapPokemonProto.Builder {
        return ResponseEnvelop.MapPokemonProto.classBuilder() as! ResponseEnvelop.MapPokemonProto.Builder
      }
      public func getBuilder() -> ResponseEnvelop.MapPokemonProto.Builder {
        return classBuilder() as! ResponseEnvelop.MapPokemonProto.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.MapPokemonProto.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.MapPokemonProto.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.MapPokemonProto.Builder {
        return try ResponseEnvelop.MapPokemonProto.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.MapPokemonProto) throws -> ResponseEnvelop.MapPokemonProto.Builder {
        return try ResponseEnvelop.MapPokemonProto.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasSpawnPointId {
          output += "\(indent) spawnPointId: \(spawnPointId) \n"
        }
        if hasEncounterId {
          output += "\(indent) encounterId: \(encounterId) \n"
        }
        if hasPokedexTypeId {
          output += "\(indent) pokedexTypeId: \(pokedexTypeId) \n"
        }
        if hasExpirationTimeMs {
          output += "\(indent) expirationTimeMs: \(expirationTimeMs) \n"
        }
        if hasLatitude {
          output += "\(indent) latitude: \(latitude) \n"
        }
        if hasLongitude {
          output += "\(indent) longitude: \(longitude) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasSpawnPointId {
                 hashCode = (hashCode &* 31) &+ spawnPointId.hashValue
              }
              if hasEncounterId {
                 hashCode = (hashCode &* 31) &+ encounterId.hashValue
              }
              if hasPokedexTypeId {
                 hashCode = (hashCode &* 31) &+ pokedexTypeId.hashValue
              }
              if hasExpirationTimeMs {
                 hashCode = (hashCode &* 31) &+ expirationTimeMs.hashValue
              }
              if hasLatitude {
                 hashCode = (hashCode &* 31) &+ latitude.hashValue
              }
              if hasLongitude {
                 hashCode = (hashCode &* 31) &+ longitude.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.MapPokemonProto"
      }
      override public func className() -> String {
          return "ResponseEnvelop.MapPokemonProto"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.MapPokemonProto.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.MapPokemonProto = ResponseEnvelop.MapPokemonProto()
        public func getMessage() -> ResponseEnvelop.MapPokemonProto {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasSpawnPointId:Bool {
             get {
                  return builderResult.hasSpawnPointId
             }
        }
        public var spawnPointId:String {
             get {
                  return builderResult.spawnPointId
             }
             set (value) {
                 builderResult.hasSpawnPointId = true
                 builderResult.spawnPointId = value
             }
        }
        public func setSpawnPointId(value:String) -> ResponseEnvelop.MapPokemonProto.Builder {
          self.spawnPointId = value
          return self
        }
        public func clearSpawnPointId() -> ResponseEnvelop.MapPokemonProto.Builder{
             builderResult.hasSpawnPointId = false
             builderResult.spawnPointId = ""
             return self
        }
        public var hasEncounterId:Bool {
             get {
                  return builderResult.hasEncounterId
             }
        }
        public var encounterId:UInt64 {
             get {
                  return builderResult.encounterId
             }
             set (value) {
                 builderResult.hasEncounterId = true
                 builderResult.encounterId = value
             }
        }
        public func setEncounterId(value:UInt64) -> ResponseEnvelop.MapPokemonProto.Builder {
          self.encounterId = value
          return self
        }
        public func clearEncounterId() -> ResponseEnvelop.MapPokemonProto.Builder{
             builderResult.hasEncounterId = false
             builderResult.encounterId = UInt64(0)
             return self
        }
        public var hasPokedexTypeId:Bool {
             get {
                  return builderResult.hasPokedexTypeId
             }
        }
        public var pokedexTypeId:Int32 {
             get {
                  return builderResult.pokedexTypeId
             }
             set (value) {
                 builderResult.hasPokedexTypeId = true
                 builderResult.pokedexTypeId = value
             }
        }
        public func setPokedexTypeId(value:Int32) -> ResponseEnvelop.MapPokemonProto.Builder {
          self.pokedexTypeId = value
          return self
        }
        public func clearPokedexTypeId() -> ResponseEnvelop.MapPokemonProto.Builder{
             builderResult.hasPokedexTypeId = false
             builderResult.pokedexTypeId = Int32(0)
             return self
        }
        public var hasExpirationTimeMs:Bool {
             get {
                  return builderResult.hasExpirationTimeMs
             }
        }
        public var expirationTimeMs:Int64 {
             get {
                  return builderResult.expirationTimeMs
             }
             set (value) {
                 builderResult.hasExpirationTimeMs = true
                 builderResult.expirationTimeMs = value
             }
        }
        public func setExpirationTimeMs(value:Int64) -> ResponseEnvelop.MapPokemonProto.Builder {
          self.expirationTimeMs = value
          return self
        }
        public func clearExpirationTimeMs() -> ResponseEnvelop.MapPokemonProto.Builder{
             builderResult.hasExpirationTimeMs = false
             builderResult.expirationTimeMs = Int64(0)
             return self
        }
        public var hasLatitude:Bool {
             get {
                  return builderResult.hasLatitude
             }
        }
        public var latitude:Double {
             get {
                  return builderResult.latitude
             }
             set (value) {
                 builderResult.hasLatitude = true
                 builderResult.latitude = value
             }
        }
        public func setLatitude(value:Double) -> ResponseEnvelop.MapPokemonProto.Builder {
          self.latitude = value
          return self
        }
        public func clearLatitude() -> ResponseEnvelop.MapPokemonProto.Builder{
             builderResult.hasLatitude = false
             builderResult.latitude = Double(0)
             return self
        }
        public var hasLongitude:Bool {
             get {
                  return builderResult.hasLongitude
             }
        }
        public var longitude:Double {
             get {
                  return builderResult.longitude
             }
             set (value) {
                 builderResult.hasLongitude = true
                 builderResult.longitude = value
             }
        }
        public func setLongitude(value:Double) -> ResponseEnvelop.MapPokemonProto.Builder {
          self.longitude = value
          return self
        }
        public func clearLongitude() -> ResponseEnvelop.MapPokemonProto.Builder{
             builderResult.hasLongitude = false
             builderResult.longitude = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.MapPokemonProto.Builder {
          builderResult = ResponseEnvelop.MapPokemonProto()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.MapPokemonProto.Builder {
          return try ResponseEnvelop.MapPokemonProto.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.MapPokemonProto {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.MapPokemonProto {
          let returnMe:ResponseEnvelop.MapPokemonProto = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.MapPokemonProto) throws -> ResponseEnvelop.MapPokemonProto.Builder {
          if other == ResponseEnvelop.MapPokemonProto() {
           return self
          }
          if other.hasSpawnPointId {
               spawnPointId = other.spawnPointId
          }
          if other.hasEncounterId {
               encounterId = other.encounterId
          }
          if other.hasPokedexTypeId {
               pokedexTypeId = other.pokedexTypeId
          }
          if other.hasExpirationTimeMs {
               expirationTimeMs = other.expirationTimeMs
          }
          if other.hasLatitude {
               latitude = other.latitude
          }
          if other.hasLongitude {
               longitude = other.longitude
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.MapPokemonProto.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.MapPokemonProto.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              spawnPointId = try input.readString()

            case 17 :
              encounterId = try input.readFixed64()

            case 24 :
              pokedexTypeId = try input.readInt32()

            case 32 :
              expirationTimeMs = try input.readInt64()

            case 41 :
              latitude = try input.readDouble()

            case 49 :
              longitude = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class PokemonFortProto : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var fortId:String = ""

      public private(set) var hasFortId:Bool = false
      public private(set) var lastModifiedMs:Int64 = Int64(0)

      public private(set) var hasLastModifiedMs:Bool = false
      public private(set) var latitude:Double = Double(0)

      public private(set) var hasLatitude:Bool = false
      public private(set) var longitude:Double = Double(0)

      public private(set) var hasLongitude:Bool = false
      public private(set) var team:Int32 = Int32(0)

      public private(set) var hasTeam:Bool = false
      public private(set) var guardPokemonId:Int32 = Int32(0)

      public private(set) var hasGuardPokemonId:Bool = false
      public private(set) var guardPokemonLevel:Int32 = Int32(0)

      public private(set) var hasGuardPokemonLevel:Bool = false
      public private(set) var enabled:Bool = false

      public private(set) var hasEnabled:Bool = false
      // ENUM.Holoholo.Rpc.FortType FortType = 9;
      public private(set) var fortType:Int32 = Int32(0)

      public private(set) var hasFortType:Bool = false
      public private(set) var gymPoints:Int64 = Int64(0)

      public private(set) var hasGymPoints:Bool = false
      public private(set) var isInBattle:Bool = false

      public private(set) var hasIsInBattle:Bool = false
      public private(set) var activeFortModifier:NSData = NSData()

      public private(set) var hasActiveFortModifier:Bool = false
      public private(set) var lureInfo:ResponseEnvelop.FortLureInfoProto!
      public private(set) var hasLureInfo:Bool = false
      public private(set) var cooldownCompleteMs:Int64 = Int64(0)

      public private(set) var hasCooldownCompleteMs:Bool = false
      // ENUM.Holoholo.Rpc.Sponsor.Types.FortSponsor.Sponsor Sponsor = 15;
      public private(set) var sponsor:Int32 = Int32(0)

      public private(set) var hasSponsor:Bool = false
      // ENUM.Holoholo.Rpc.RenderingType.Types.FortRenderingType.RenderingType RenderingType = 16;
      public private(set) var renderingType:Int32 = Int32(0)

      public private(set) var hasRenderingType:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasFortId {
          return false
        }
        if !hasLastModifiedMs {
          return false
        }
        if !hasLatitude {
          return false
        }
        if !hasLongitude {
          return false
        }
        if !hasEnabled {
          return false
        }
        if hasLureInfo {
         if !lureInfo.isInitialized() {
           return false
         }
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasFortId {
          try output.writeString(1, value:fortId)
        }
        if hasLastModifiedMs {
          try output.writeInt64(2, value:lastModifiedMs)
        }
        if hasLatitude {
          try output.writeDouble(3, value:latitude)
        }
        if hasLongitude {
          try output.writeDouble(4, value:longitude)
        }
        if hasTeam {
          try output.writeInt32(5, value:team)
        }
        if hasGuardPokemonId {
          try output.writeInt32(6, value:guardPokemonId)
        }
        if hasGuardPokemonLevel {
          try output.writeInt32(7, value:guardPokemonLevel)
        }
        if hasEnabled {
          try output.writeBool(8, value:enabled)
        }
        if hasFortType {
          try output.writeInt32(9, value:fortType)
        }
        if hasGymPoints {
          try output.writeInt64(10, value:gymPoints)
        }
        if hasIsInBattle {
          try output.writeBool(11, value:isInBattle)
        }
        if hasActiveFortModifier {
          try output.writeData(12, value:activeFortModifier)
        }
        if hasLureInfo {
          try output.writeMessage(13, value:lureInfo)
        }
        if hasCooldownCompleteMs {
          try output.writeInt64(14, value:cooldownCompleteMs)
        }
        if hasSponsor {
          try output.writeInt32(15, value:sponsor)
        }
        if hasRenderingType {
          try output.writeInt32(16, value:renderingType)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFortId {
          serialize_size += fortId.computeStringSize(1)
        }
        if hasLastModifiedMs {
          serialize_size += lastModifiedMs.computeInt64Size(2)
        }
        if hasLatitude {
          serialize_size += latitude.computeDoubleSize(3)
        }
        if hasLongitude {
          serialize_size += longitude.computeDoubleSize(4)
        }
        if hasTeam {
          serialize_size += team.computeInt32Size(5)
        }
        if hasGuardPokemonId {
          serialize_size += guardPokemonId.computeInt32Size(6)
        }
        if hasGuardPokemonLevel {
          serialize_size += guardPokemonLevel.computeInt32Size(7)
        }
        if hasEnabled {
          serialize_size += enabled.computeBoolSize(8)
        }
        if hasFortType {
          serialize_size += fortType.computeInt32Size(9)
        }
        if hasGymPoints {
          serialize_size += gymPoints.computeInt64Size(10)
        }
        if hasIsInBattle {
          serialize_size += isInBattle.computeBoolSize(11)
        }
        if hasActiveFortModifier {
          serialize_size += activeFortModifier.computeDataSize(12)
        }
        if hasLureInfo {
            if let varSizelureInfo = lureInfo?.computeMessageSize(13) {
                serialize_size += varSizelureInfo
            }
        }
        if hasCooldownCompleteMs {
          serialize_size += cooldownCompleteMs.computeInt64Size(14)
        }
        if hasSponsor {
          serialize_size += sponsor.computeInt32Size(15)
        }
        if hasRenderingType {
          serialize_size += renderingType.computeInt32Size(16)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.PokemonFortProto> {
        var mergedArray = Array<ResponseEnvelop.PokemonFortProto>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokemonFortProto? {
        return try ResponseEnvelop.PokemonFortProto.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.PokemonFortProto {
        return try ResponseEnvelop.PokemonFortProto.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonFortProto {
        return try ResponseEnvelop.PokemonFortProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokemonFortProto {
        return try ResponseEnvelop.PokemonFortProto.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonFortProto {
        return try ResponseEnvelop.PokemonFortProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokemonFortProto {
        return try ResponseEnvelop.PokemonFortProto.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonFortProto {
        return try ResponseEnvelop.PokemonFortProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.PokemonFortProto.Builder {
        return ResponseEnvelop.PokemonFortProto.classBuilder() as! ResponseEnvelop.PokemonFortProto.Builder
      }
      public func getBuilder() -> ResponseEnvelop.PokemonFortProto.Builder {
        return classBuilder() as! ResponseEnvelop.PokemonFortProto.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokemonFortProto.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokemonFortProto.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.PokemonFortProto.Builder {
        return try ResponseEnvelop.PokemonFortProto.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.PokemonFortProto) throws -> ResponseEnvelop.PokemonFortProto.Builder {
        return try ResponseEnvelop.PokemonFortProto.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasFortId {
          output += "\(indent) fortId: \(fortId) \n"
        }
        if hasLastModifiedMs {
          output += "\(indent) lastModifiedMs: \(lastModifiedMs) \n"
        }
        if hasLatitude {
          output += "\(indent) latitude: \(latitude) \n"
        }
        if hasLongitude {
          output += "\(indent) longitude: \(longitude) \n"
        }
        if hasTeam {
          output += "\(indent) team: \(team) \n"
        }
        if hasGuardPokemonId {
          output += "\(indent) guardPokemonId: \(guardPokemonId) \n"
        }
        if hasGuardPokemonLevel {
          output += "\(indent) guardPokemonLevel: \(guardPokemonLevel) \n"
        }
        if hasEnabled {
          output += "\(indent) enabled: \(enabled) \n"
        }
        if hasFortType {
          output += "\(indent) fortType: \(fortType) \n"
        }
        if hasGymPoints {
          output += "\(indent) gymPoints: \(gymPoints) \n"
        }
        if hasIsInBattle {
          output += "\(indent) isInBattle: \(isInBattle) \n"
        }
        if hasActiveFortModifier {
          output += "\(indent) activeFortModifier: \(activeFortModifier) \n"
        }
        if hasLureInfo {
          output += "\(indent) lureInfo {\n"
          if let outDescLureInfo = lureInfo {
            output += try outDescLureInfo.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasCooldownCompleteMs {
          output += "\(indent) cooldownCompleteMs: \(cooldownCompleteMs) \n"
        }
        if hasSponsor {
          output += "\(indent) sponsor: \(sponsor) \n"
        }
        if hasRenderingType {
          output += "\(indent) renderingType: \(renderingType) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasFortId {
                 hashCode = (hashCode &* 31) &+ fortId.hashValue
              }
              if hasLastModifiedMs {
                 hashCode = (hashCode &* 31) &+ lastModifiedMs.hashValue
              }
              if hasLatitude {
                 hashCode = (hashCode &* 31) &+ latitude.hashValue
              }
              if hasLongitude {
                 hashCode = (hashCode &* 31) &+ longitude.hashValue
              }
              if hasTeam {
                 hashCode = (hashCode &* 31) &+ team.hashValue
              }
              if hasGuardPokemonId {
                 hashCode = (hashCode &* 31) &+ guardPokemonId.hashValue
              }
              if hasGuardPokemonLevel {
                 hashCode = (hashCode &* 31) &+ guardPokemonLevel.hashValue
              }
              if hasEnabled {
                 hashCode = (hashCode &* 31) &+ enabled.hashValue
              }
              if hasFortType {
                 hashCode = (hashCode &* 31) &+ fortType.hashValue
              }
              if hasGymPoints {
                 hashCode = (hashCode &* 31) &+ gymPoints.hashValue
              }
              if hasIsInBattle {
                 hashCode = (hashCode &* 31) &+ isInBattle.hashValue
              }
              if hasActiveFortModifier {
                 hashCode = (hashCode &* 31) &+ activeFortModifier.hashValue
              }
              if hasLureInfo {
                  if let hashValuelureInfo = lureInfo?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuelureInfo
                  }
              }
              if hasCooldownCompleteMs {
                 hashCode = (hashCode &* 31) &+ cooldownCompleteMs.hashValue
              }
              if hasSponsor {
                 hashCode = (hashCode &* 31) &+ sponsor.hashValue
              }
              if hasRenderingType {
                 hashCode = (hashCode &* 31) &+ renderingType.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.PokemonFortProto"
      }
      override public func className() -> String {
          return "ResponseEnvelop.PokemonFortProto"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.PokemonFortProto.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.PokemonFortProto = ResponseEnvelop.PokemonFortProto()
        public func getMessage() -> ResponseEnvelop.PokemonFortProto {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasFortId:Bool {
             get {
                  return builderResult.hasFortId
             }
        }
        public var fortId:String {
             get {
                  return builderResult.fortId
             }
             set (value) {
                 builderResult.hasFortId = true
                 builderResult.fortId = value
             }
        }
        public func setFortId(value:String) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.fortId = value
          return self
        }
        public func clearFortId() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasFortId = false
             builderResult.fortId = ""
             return self
        }
        public var hasLastModifiedMs:Bool {
             get {
                  return builderResult.hasLastModifiedMs
             }
        }
        public var lastModifiedMs:Int64 {
             get {
                  return builderResult.lastModifiedMs
             }
             set (value) {
                 builderResult.hasLastModifiedMs = true
                 builderResult.lastModifiedMs = value
             }
        }
        public func setLastModifiedMs(value:Int64) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.lastModifiedMs = value
          return self
        }
        public func clearLastModifiedMs() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasLastModifiedMs = false
             builderResult.lastModifiedMs = Int64(0)
             return self
        }
        public var hasLatitude:Bool {
             get {
                  return builderResult.hasLatitude
             }
        }
        public var latitude:Double {
             get {
                  return builderResult.latitude
             }
             set (value) {
                 builderResult.hasLatitude = true
                 builderResult.latitude = value
             }
        }
        public func setLatitude(value:Double) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.latitude = value
          return self
        }
        public func clearLatitude() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasLatitude = false
             builderResult.latitude = Double(0)
             return self
        }
        public var hasLongitude:Bool {
             get {
                  return builderResult.hasLongitude
             }
        }
        public var longitude:Double {
             get {
                  return builderResult.longitude
             }
             set (value) {
                 builderResult.hasLongitude = true
                 builderResult.longitude = value
             }
        }
        public func setLongitude(value:Double) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.longitude = value
          return self
        }
        public func clearLongitude() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasLongitude = false
             builderResult.longitude = Double(0)
             return self
        }
        public var hasTeam:Bool {
             get {
                  return builderResult.hasTeam
             }
        }
        public var team:Int32 {
             get {
                  return builderResult.team
             }
             set (value) {
                 builderResult.hasTeam = true
                 builderResult.team = value
             }
        }
        public func setTeam(value:Int32) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.team = value
          return self
        }
        public func clearTeam() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasTeam = false
             builderResult.team = Int32(0)
             return self
        }
        public var hasGuardPokemonId:Bool {
             get {
                  return builderResult.hasGuardPokemonId
             }
        }
        public var guardPokemonId:Int32 {
             get {
                  return builderResult.guardPokemonId
             }
             set (value) {
                 builderResult.hasGuardPokemonId = true
                 builderResult.guardPokemonId = value
             }
        }
        public func setGuardPokemonId(value:Int32) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.guardPokemonId = value
          return self
        }
        public func clearGuardPokemonId() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasGuardPokemonId = false
             builderResult.guardPokemonId = Int32(0)
             return self
        }
        public var hasGuardPokemonLevel:Bool {
             get {
                  return builderResult.hasGuardPokemonLevel
             }
        }
        public var guardPokemonLevel:Int32 {
             get {
                  return builderResult.guardPokemonLevel
             }
             set (value) {
                 builderResult.hasGuardPokemonLevel = true
                 builderResult.guardPokemonLevel = value
             }
        }
        public func setGuardPokemonLevel(value:Int32) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.guardPokemonLevel = value
          return self
        }
        public func clearGuardPokemonLevel() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasGuardPokemonLevel = false
             builderResult.guardPokemonLevel = Int32(0)
             return self
        }
        public var hasEnabled:Bool {
             get {
                  return builderResult.hasEnabled
             }
        }
        public var enabled:Bool {
             get {
                  return builderResult.enabled
             }
             set (value) {
                 builderResult.hasEnabled = true
                 builderResult.enabled = value
             }
        }
        public func setEnabled(value:Bool) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.enabled = value
          return self
        }
        public func clearEnabled() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasEnabled = false
             builderResult.enabled = false
             return self
        }
        public var hasFortType:Bool {
             get {
                  return builderResult.hasFortType
             }
        }
        public var fortType:Int32 {
             get {
                  return builderResult.fortType
             }
             set (value) {
                 builderResult.hasFortType = true
                 builderResult.fortType = value
             }
        }
        public func setFortType(value:Int32) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.fortType = value
          return self
        }
        public func clearFortType() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasFortType = false
             builderResult.fortType = Int32(0)
             return self
        }
        public var hasGymPoints:Bool {
             get {
                  return builderResult.hasGymPoints
             }
        }
        public var gymPoints:Int64 {
             get {
                  return builderResult.gymPoints
             }
             set (value) {
                 builderResult.hasGymPoints = true
                 builderResult.gymPoints = value
             }
        }
        public func setGymPoints(value:Int64) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.gymPoints = value
          return self
        }
        public func clearGymPoints() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasGymPoints = false
             builderResult.gymPoints = Int64(0)
             return self
        }
        public var hasIsInBattle:Bool {
             get {
                  return builderResult.hasIsInBattle
             }
        }
        public var isInBattle:Bool {
             get {
                  return builderResult.isInBattle
             }
             set (value) {
                 builderResult.hasIsInBattle = true
                 builderResult.isInBattle = value
             }
        }
        public func setIsInBattle(value:Bool) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.isInBattle = value
          return self
        }
        public func clearIsInBattle() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasIsInBattle = false
             builderResult.isInBattle = false
             return self
        }
        public var hasActiveFortModifier:Bool {
             get {
                  return builderResult.hasActiveFortModifier
             }
        }
        public var activeFortModifier:NSData {
             get {
                  return builderResult.activeFortModifier
             }
             set (value) {
                 builderResult.hasActiveFortModifier = true
                 builderResult.activeFortModifier = value
             }
        }
        public func setActiveFortModifier(value:NSData) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.activeFortModifier = value
          return self
        }
        public func clearActiveFortModifier() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasActiveFortModifier = false
             builderResult.activeFortModifier = NSData()
             return self
        }
        public var hasLureInfo:Bool {
             get {
                 return builderResult.hasLureInfo
             }
        }
        public var lureInfo:ResponseEnvelop.FortLureInfoProto! {
             get {
                 if lureInfoBuilder_ != nil {
                    builderResult.lureInfo = lureInfoBuilder_.getMessage()
                 }
                 return builderResult.lureInfo
             }
             set (value) {
                 builderResult.hasLureInfo = true
                 builderResult.lureInfo = value
             }
        }
        private var lureInfoBuilder_:ResponseEnvelop.FortLureInfoProto.Builder! {
             didSet {
                builderResult.hasLureInfo = true
             }
        }
        public func getLureInfoBuilder() -> ResponseEnvelop.FortLureInfoProto.Builder {
          if lureInfoBuilder_ == nil {
             lureInfoBuilder_ = ResponseEnvelop.FortLureInfoProto.Builder()
             builderResult.lureInfo = lureInfoBuilder_.getMessage()
             if lureInfo != nil {
                try! lureInfoBuilder_.mergeFrom(lureInfo)
             }
          }
          return lureInfoBuilder_
        }
        public func setLureInfo(value:ResponseEnvelop.FortLureInfoProto!) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.lureInfo = value
          return self
        }
        public func mergeLureInfo(value:ResponseEnvelop.FortLureInfoProto) throws -> ResponseEnvelop.PokemonFortProto.Builder {
          if builderResult.hasLureInfo {
            builderResult.lureInfo = try ResponseEnvelop.FortLureInfoProto.builderWithPrototype(builderResult.lureInfo).mergeFrom(value).buildPartial()
          } else {
            builderResult.lureInfo = value
          }
          builderResult.hasLureInfo = true
          return self
        }
        public func clearLureInfo() -> ResponseEnvelop.PokemonFortProto.Builder {
          lureInfoBuilder_ = nil
          builderResult.hasLureInfo = false
          builderResult.lureInfo = nil
          return self
        }
        public var hasCooldownCompleteMs:Bool {
             get {
                  return builderResult.hasCooldownCompleteMs
             }
        }
        public var cooldownCompleteMs:Int64 {
             get {
                  return builderResult.cooldownCompleteMs
             }
             set (value) {
                 builderResult.hasCooldownCompleteMs = true
                 builderResult.cooldownCompleteMs = value
             }
        }
        public func setCooldownCompleteMs(value:Int64) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.cooldownCompleteMs = value
          return self
        }
        public func clearCooldownCompleteMs() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasCooldownCompleteMs = false
             builderResult.cooldownCompleteMs = Int64(0)
             return self
        }
        public var hasSponsor:Bool {
             get {
                  return builderResult.hasSponsor
             }
        }
        public var sponsor:Int32 {
             get {
                  return builderResult.sponsor
             }
             set (value) {
                 builderResult.hasSponsor = true
                 builderResult.sponsor = value
             }
        }
        public func setSponsor(value:Int32) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.sponsor = value
          return self
        }
        public func clearSponsor() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasSponsor = false
             builderResult.sponsor = Int32(0)
             return self
        }
        public var hasRenderingType:Bool {
             get {
                  return builderResult.hasRenderingType
             }
        }
        public var renderingType:Int32 {
             get {
                  return builderResult.renderingType
             }
             set (value) {
                 builderResult.hasRenderingType = true
                 builderResult.renderingType = value
             }
        }
        public func setRenderingType(value:Int32) -> ResponseEnvelop.PokemonFortProto.Builder {
          self.renderingType = value
          return self
        }
        public func clearRenderingType() -> ResponseEnvelop.PokemonFortProto.Builder{
             builderResult.hasRenderingType = false
             builderResult.renderingType = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.PokemonFortProto.Builder {
          builderResult = ResponseEnvelop.PokemonFortProto()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.PokemonFortProto.Builder {
          return try ResponseEnvelop.PokemonFortProto.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.PokemonFortProto {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.PokemonFortProto {
          let returnMe:ResponseEnvelop.PokemonFortProto = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.PokemonFortProto) throws -> ResponseEnvelop.PokemonFortProto.Builder {
          if other == ResponseEnvelop.PokemonFortProto() {
           return self
          }
          if other.hasFortId {
               fortId = other.fortId
          }
          if other.hasLastModifiedMs {
               lastModifiedMs = other.lastModifiedMs
          }
          if other.hasLatitude {
               latitude = other.latitude
          }
          if other.hasLongitude {
               longitude = other.longitude
          }
          if other.hasTeam {
               team = other.team
          }
          if other.hasGuardPokemonId {
               guardPokemonId = other.guardPokemonId
          }
          if other.hasGuardPokemonLevel {
               guardPokemonLevel = other.guardPokemonLevel
          }
          if other.hasEnabled {
               enabled = other.enabled
          }
          if other.hasFortType {
               fortType = other.fortType
          }
          if other.hasGymPoints {
               gymPoints = other.gymPoints
          }
          if other.hasIsInBattle {
               isInBattle = other.isInBattle
          }
          if other.hasActiveFortModifier {
               activeFortModifier = other.activeFortModifier
          }
          if (other.hasLureInfo) {
              try mergeLureInfo(other.lureInfo)
          }
          if other.hasCooldownCompleteMs {
               cooldownCompleteMs = other.cooldownCompleteMs
          }
          if other.hasSponsor {
               sponsor = other.sponsor
          }
          if other.hasRenderingType {
               renderingType = other.renderingType
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokemonFortProto.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonFortProto.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              fortId = try input.readString()

            case 16 :
              lastModifiedMs = try input.readInt64()

            case 25 :
              latitude = try input.readDouble()

            case 33 :
              longitude = try input.readDouble()

            case 40 :
              team = try input.readInt32()

            case 48 :
              guardPokemonId = try input.readInt32()

            case 56 :
              guardPokemonLevel = try input.readInt32()

            case 64 :
              enabled = try input.readBool()

            case 72 :
              fortType = try input.readInt32()

            case 80 :
              gymPoints = try input.readInt64()

            case 88 :
              isInBattle = try input.readBool()

            case 98 :
              activeFortModifier = try input.readData()

            case 106 :
              let subBuilder:ResponseEnvelop.FortLureInfoProto.Builder = ResponseEnvelop.FortLureInfoProto.Builder()
              if hasLureInfo {
                try subBuilder.mergeFrom(lureInfo)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              lureInfo = subBuilder.buildPartial()

            case 112 :
              cooldownCompleteMs = try input.readInt64()

            case 120 :
              sponsor = try input.readInt32()

            case 128 :
              renderingType = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    //based on : https://github.com/AHAAAAAAA/PokemonGo-Map/blob/master/pokemon.proto
    final public class FortLureInfoProto : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var fortId:String = ""

      public private(set) var hasFortId:Bool = false
      public private(set) var unknown2:Double = Double(0)

      public private(set) var hasUnknown2:Bool = false
      public private(set) var activePokemonId:Int32 = Int32(0)

      public private(set) var hasActivePokemonId:Bool = false
      public private(set) var lureExpiresTimestampMs:Int64 = Int64(0)

      public private(set) var hasLureExpiresTimestampMs:Bool = false
      public private(set) var deployerPlayerCodename:String = ""

      public private(set) var hasDeployerPlayerCodename:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasFortId {
          return false
        }
        if !hasUnknown2 {
          return false
        }
        if !hasActivePokemonId {
          return false
        }
        if !hasLureExpiresTimestampMs {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasFortId {
          try output.writeString(1, value:fortId)
        }
        if hasUnknown2 {
          try output.writeDouble(2, value:unknown2)
        }
        if hasActivePokemonId {
          try output.writeInt32(3, value:activePokemonId)
        }
        if hasLureExpiresTimestampMs {
          try output.writeInt64(4, value:lureExpiresTimestampMs)
        }
        if hasDeployerPlayerCodename {
          try output.writeString(5, value:deployerPlayerCodename)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFortId {
          serialize_size += fortId.computeStringSize(1)
        }
        if hasUnknown2 {
          serialize_size += unknown2.computeDoubleSize(2)
        }
        if hasActivePokemonId {
          serialize_size += activePokemonId.computeInt32Size(3)
        }
        if hasLureExpiresTimestampMs {
          serialize_size += lureExpiresTimestampMs.computeInt64Size(4)
        }
        if hasDeployerPlayerCodename {
          serialize_size += deployerPlayerCodename.computeStringSize(5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.FortLureInfoProto> {
        var mergedArray = Array<ResponseEnvelop.FortLureInfoProto>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.FortLureInfoProto? {
        return try ResponseEnvelop.FortLureInfoProto.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.FortLureInfoProto {
        return try ResponseEnvelop.FortLureInfoProto.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortLureInfoProto {
        return try ResponseEnvelop.FortLureInfoProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.FortLureInfoProto {
        return try ResponseEnvelop.FortLureInfoProto.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortLureInfoProto {
        return try ResponseEnvelop.FortLureInfoProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.FortLureInfoProto {
        return try ResponseEnvelop.FortLureInfoProto.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortLureInfoProto {
        return try ResponseEnvelop.FortLureInfoProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.FortLureInfoProto.Builder {
        return ResponseEnvelop.FortLureInfoProto.classBuilder() as! ResponseEnvelop.FortLureInfoProto.Builder
      }
      public func getBuilder() -> ResponseEnvelop.FortLureInfoProto.Builder {
        return classBuilder() as! ResponseEnvelop.FortLureInfoProto.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.FortLureInfoProto.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.FortLureInfoProto.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.FortLureInfoProto.Builder {
        return try ResponseEnvelop.FortLureInfoProto.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.FortLureInfoProto) throws -> ResponseEnvelop.FortLureInfoProto.Builder {
        return try ResponseEnvelop.FortLureInfoProto.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasFortId {
          output += "\(indent) fortId: \(fortId) \n"
        }
        if hasUnknown2 {
          output += "\(indent) unknown2: \(unknown2) \n"
        }
        if hasActivePokemonId {
          output += "\(indent) activePokemonId: \(activePokemonId) \n"
        }
        if hasLureExpiresTimestampMs {
          output += "\(indent) lureExpiresTimestampMs: \(lureExpiresTimestampMs) \n"
        }
        if hasDeployerPlayerCodename {
          output += "\(indent) deployerPlayerCodename: \(deployerPlayerCodename) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasFortId {
                 hashCode = (hashCode &* 31) &+ fortId.hashValue
              }
              if hasUnknown2 {
                 hashCode = (hashCode &* 31) &+ unknown2.hashValue
              }
              if hasActivePokemonId {
                 hashCode = (hashCode &* 31) &+ activePokemonId.hashValue
              }
              if hasLureExpiresTimestampMs {
                 hashCode = (hashCode &* 31) &+ lureExpiresTimestampMs.hashValue
              }
              if hasDeployerPlayerCodename {
                 hashCode = (hashCode &* 31) &+ deployerPlayerCodename.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.FortLureInfoProto"
      }
      override public func className() -> String {
          return "ResponseEnvelop.FortLureInfoProto"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.FortLureInfoProto.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.FortLureInfoProto = ResponseEnvelop.FortLureInfoProto()
        public func getMessage() -> ResponseEnvelop.FortLureInfoProto {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasFortId:Bool {
             get {
                  return builderResult.hasFortId
             }
        }
        public var fortId:String {
             get {
                  return builderResult.fortId
             }
             set (value) {
                 builderResult.hasFortId = true
                 builderResult.fortId = value
             }
        }
        public func setFortId(value:String) -> ResponseEnvelop.FortLureInfoProto.Builder {
          self.fortId = value
          return self
        }
        public func clearFortId() -> ResponseEnvelop.FortLureInfoProto.Builder{
             builderResult.hasFortId = false
             builderResult.fortId = ""
             return self
        }
        public var hasUnknown2:Bool {
             get {
                  return builderResult.hasUnknown2
             }
        }
        public var unknown2:Double {
             get {
                  return builderResult.unknown2
             }
             set (value) {
                 builderResult.hasUnknown2 = true
                 builderResult.unknown2 = value
             }
        }
        public func setUnknown2(value:Double) -> ResponseEnvelop.FortLureInfoProto.Builder {
          self.unknown2 = value
          return self
        }
        public func clearUnknown2() -> ResponseEnvelop.FortLureInfoProto.Builder{
             builderResult.hasUnknown2 = false
             builderResult.unknown2 = Double(0)
             return self
        }
        public var hasActivePokemonId:Bool {
             get {
                  return builderResult.hasActivePokemonId
             }
        }
        public var activePokemonId:Int32 {
             get {
                  return builderResult.activePokemonId
             }
             set (value) {
                 builderResult.hasActivePokemonId = true
                 builderResult.activePokemonId = value
             }
        }
        public func setActivePokemonId(value:Int32) -> ResponseEnvelop.FortLureInfoProto.Builder {
          self.activePokemonId = value
          return self
        }
        public func clearActivePokemonId() -> ResponseEnvelop.FortLureInfoProto.Builder{
             builderResult.hasActivePokemonId = false
             builderResult.activePokemonId = Int32(0)
             return self
        }
        public var hasLureExpiresTimestampMs:Bool {
             get {
                  return builderResult.hasLureExpiresTimestampMs
             }
        }
        public var lureExpiresTimestampMs:Int64 {
             get {
                  return builderResult.lureExpiresTimestampMs
             }
             set (value) {
                 builderResult.hasLureExpiresTimestampMs = true
                 builderResult.lureExpiresTimestampMs = value
             }
        }
        public func setLureExpiresTimestampMs(value:Int64) -> ResponseEnvelop.FortLureInfoProto.Builder {
          self.lureExpiresTimestampMs = value
          return self
        }
        public func clearLureExpiresTimestampMs() -> ResponseEnvelop.FortLureInfoProto.Builder{
             builderResult.hasLureExpiresTimestampMs = false
             builderResult.lureExpiresTimestampMs = Int64(0)
             return self
        }
        public var hasDeployerPlayerCodename:Bool {
             get {
                  return builderResult.hasDeployerPlayerCodename
             }
        }
        public var deployerPlayerCodename:String {
             get {
                  return builderResult.deployerPlayerCodename
             }
             set (value) {
                 builderResult.hasDeployerPlayerCodename = true
                 builderResult.deployerPlayerCodename = value
             }
        }
        public func setDeployerPlayerCodename(value:String) -> ResponseEnvelop.FortLureInfoProto.Builder {
          self.deployerPlayerCodename = value
          return self
        }
        public func clearDeployerPlayerCodename() -> ResponseEnvelop.FortLureInfoProto.Builder{
             builderResult.hasDeployerPlayerCodename = false
             builderResult.deployerPlayerCodename = ""
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.FortLureInfoProto.Builder {
          builderResult = ResponseEnvelop.FortLureInfoProto()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.FortLureInfoProto.Builder {
          return try ResponseEnvelop.FortLureInfoProto.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.FortLureInfoProto {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.FortLureInfoProto {
          let returnMe:ResponseEnvelop.FortLureInfoProto = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.FortLureInfoProto) throws -> ResponseEnvelop.FortLureInfoProto.Builder {
          if other == ResponseEnvelop.FortLureInfoProto() {
           return self
          }
          if other.hasFortId {
               fortId = other.fortId
          }
          if other.hasUnknown2 {
               unknown2 = other.unknown2
          }
          if other.hasActivePokemonId {
               activePokemonId = other.activePokemonId
          }
          if other.hasLureExpiresTimestampMs {
               lureExpiresTimestampMs = other.lureExpiresTimestampMs
          }
          if other.hasDeployerPlayerCodename {
               deployerPlayerCodename = other.deployerPlayerCodename
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.FortLureInfoProto.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortLureInfoProto.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              fortId = try input.readString()

            case 17 :
              unknown2 = try input.readDouble()

            case 24 :
              activePokemonId = try input.readInt32()

            case 32 :
              lureExpiresTimestampMs = try input.readInt64()

            case 42 :
              deployerPlayerCodename = try input.readString()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class PokemonSummaryFortProto : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var fortSummaryId:String = ""

      public private(set) var hasFortSummaryId:Bool = false
      public private(set) var lastModifiedMs:Int64 = Int64(0)

      public private(set) var hasLastModifiedMs:Bool = false
      public private(set) var latitude:Double = Double(0)

      public private(set) var hasLatitude:Bool = false
      public private(set) var longitude:Double = Double(0)

      public private(set) var hasLongitude:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasFortSummaryId {
          return false
        }
        if !hasLastModifiedMs {
          return false
        }
        if !hasLatitude {
          return false
        }
        if !hasLongitude {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasFortSummaryId {
          try output.writeString(1, value:fortSummaryId)
        }
        if hasLastModifiedMs {
          try output.writeInt64(2, value:lastModifiedMs)
        }
        if hasLatitude {
          try output.writeDouble(3, value:latitude)
        }
        if hasLongitude {
          try output.writeDouble(4, value:longitude)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFortSummaryId {
          serialize_size += fortSummaryId.computeStringSize(1)
        }
        if hasLastModifiedMs {
          serialize_size += lastModifiedMs.computeInt64Size(2)
        }
        if hasLatitude {
          serialize_size += latitude.computeDoubleSize(3)
        }
        if hasLongitude {
          serialize_size += longitude.computeDoubleSize(4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.PokemonSummaryFortProto> {
        var mergedArray = Array<ResponseEnvelop.PokemonSummaryFortProto>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokemonSummaryFortProto? {
        return try ResponseEnvelop.PokemonSummaryFortProto.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.PokemonSummaryFortProto {
        return try ResponseEnvelop.PokemonSummaryFortProto.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonSummaryFortProto {
        return try ResponseEnvelop.PokemonSummaryFortProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokemonSummaryFortProto {
        return try ResponseEnvelop.PokemonSummaryFortProto.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonSummaryFortProto {
        return try ResponseEnvelop.PokemonSummaryFortProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokemonSummaryFortProto {
        return try ResponseEnvelop.PokemonSummaryFortProto.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonSummaryFortProto {
        return try ResponseEnvelop.PokemonSummaryFortProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
        return ResponseEnvelop.PokemonSummaryFortProto.classBuilder() as! ResponseEnvelop.PokemonSummaryFortProto.Builder
      }
      public func getBuilder() -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
        return classBuilder() as! ResponseEnvelop.PokemonSummaryFortProto.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokemonSummaryFortProto.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokemonSummaryFortProto.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
        return try ResponseEnvelop.PokemonSummaryFortProto.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.PokemonSummaryFortProto) throws -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
        return try ResponseEnvelop.PokemonSummaryFortProto.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasFortSummaryId {
          output += "\(indent) fortSummaryId: \(fortSummaryId) \n"
        }
        if hasLastModifiedMs {
          output += "\(indent) lastModifiedMs: \(lastModifiedMs) \n"
        }
        if hasLatitude {
          output += "\(indent) latitude: \(latitude) \n"
        }
        if hasLongitude {
          output += "\(indent) longitude: \(longitude) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasFortSummaryId {
                 hashCode = (hashCode &* 31) &+ fortSummaryId.hashValue
              }
              if hasLastModifiedMs {
                 hashCode = (hashCode &* 31) &+ lastModifiedMs.hashValue
              }
              if hasLatitude {
                 hashCode = (hashCode &* 31) &+ latitude.hashValue
              }
              if hasLongitude {
                 hashCode = (hashCode &* 31) &+ longitude.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.PokemonSummaryFortProto"
      }
      override public func className() -> String {
          return "ResponseEnvelop.PokemonSummaryFortProto"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.PokemonSummaryFortProto.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.PokemonSummaryFortProto = ResponseEnvelop.PokemonSummaryFortProto()
        public func getMessage() -> ResponseEnvelop.PokemonSummaryFortProto {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasFortSummaryId:Bool {
             get {
                  return builderResult.hasFortSummaryId
             }
        }
        public var fortSummaryId:String {
             get {
                  return builderResult.fortSummaryId
             }
             set (value) {
                 builderResult.hasFortSummaryId = true
                 builderResult.fortSummaryId = value
             }
        }
        public func setFortSummaryId(value:String) -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
          self.fortSummaryId = value
          return self
        }
        public func clearFortSummaryId() -> ResponseEnvelop.PokemonSummaryFortProto.Builder{
             builderResult.hasFortSummaryId = false
             builderResult.fortSummaryId = ""
             return self
        }
        public var hasLastModifiedMs:Bool {
             get {
                  return builderResult.hasLastModifiedMs
             }
        }
        public var lastModifiedMs:Int64 {
             get {
                  return builderResult.lastModifiedMs
             }
             set (value) {
                 builderResult.hasLastModifiedMs = true
                 builderResult.lastModifiedMs = value
             }
        }
        public func setLastModifiedMs(value:Int64) -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
          self.lastModifiedMs = value
          return self
        }
        public func clearLastModifiedMs() -> ResponseEnvelop.PokemonSummaryFortProto.Builder{
             builderResult.hasLastModifiedMs = false
             builderResult.lastModifiedMs = Int64(0)
             return self
        }
        public var hasLatitude:Bool {
             get {
                  return builderResult.hasLatitude
             }
        }
        public var latitude:Double {
             get {
                  return builderResult.latitude
             }
             set (value) {
                 builderResult.hasLatitude = true
                 builderResult.latitude = value
             }
        }
        public func setLatitude(value:Double) -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
          self.latitude = value
          return self
        }
        public func clearLatitude() -> ResponseEnvelop.PokemonSummaryFortProto.Builder{
             builderResult.hasLatitude = false
             builderResult.latitude = Double(0)
             return self
        }
        public var hasLongitude:Bool {
             get {
                  return builderResult.hasLongitude
             }
        }
        public var longitude:Double {
             get {
                  return builderResult.longitude
             }
             set (value) {
                 builderResult.hasLongitude = true
                 builderResult.longitude = value
             }
        }
        public func setLongitude(value:Double) -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
          self.longitude = value
          return self
        }
        public func clearLongitude() -> ResponseEnvelop.PokemonSummaryFortProto.Builder{
             builderResult.hasLongitude = false
             builderResult.longitude = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
          builderResult = ResponseEnvelop.PokemonSummaryFortProto()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
          return try ResponseEnvelop.PokemonSummaryFortProto.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.PokemonSummaryFortProto {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.PokemonSummaryFortProto {
          let returnMe:ResponseEnvelop.PokemonSummaryFortProto = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.PokemonSummaryFortProto) throws -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
          if other == ResponseEnvelop.PokemonSummaryFortProto() {
           return self
          }
          if other.hasFortSummaryId {
               fortSummaryId = other.fortSummaryId
          }
          if other.hasLastModifiedMs {
               lastModifiedMs = other.lastModifiedMs
          }
          if other.hasLatitude {
               latitude = other.latitude
          }
          if other.hasLongitude {
               longitude = other.longitude
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonSummaryFortProto.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              fortSummaryId = try input.readString()

            case 16 :
              lastModifiedMs = try input.readInt64()

            case 25 :
              latitude = try input.readDouble()

            case 33 :
              longitude = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class ClientSpawnPointProto : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var latitude:Double = Double(0)

      public private(set) var hasLatitude:Bool = false
      public private(set) var longitude:Double = Double(0)

      public private(set) var hasLongitude:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasLatitude {
          return false
        }
        if !hasLongitude {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasLatitude {
          try output.writeDouble(2, value:latitude)
        }
        if hasLongitude {
          try output.writeDouble(3, value:longitude)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasLatitude {
          serialize_size += latitude.computeDoubleSize(2)
        }
        if hasLongitude {
          serialize_size += longitude.computeDoubleSize(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.ClientSpawnPointProto> {
        var mergedArray = Array<ResponseEnvelop.ClientSpawnPointProto>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ClientSpawnPointProto? {
        return try ResponseEnvelop.ClientSpawnPointProto.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.ClientSpawnPointProto {
        return try ResponseEnvelop.ClientSpawnPointProto.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ClientSpawnPointProto {
        return try ResponseEnvelop.ClientSpawnPointProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ClientSpawnPointProto {
        return try ResponseEnvelop.ClientSpawnPointProto.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ClientSpawnPointProto {
        return try ResponseEnvelop.ClientSpawnPointProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ClientSpawnPointProto {
        return try ResponseEnvelop.ClientSpawnPointProto.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ClientSpawnPointProto {
        return try ResponseEnvelop.ClientSpawnPointProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.ClientSpawnPointProto.Builder {
        return ResponseEnvelop.ClientSpawnPointProto.classBuilder() as! ResponseEnvelop.ClientSpawnPointProto.Builder
      }
      public func getBuilder() -> ResponseEnvelop.ClientSpawnPointProto.Builder {
        return classBuilder() as! ResponseEnvelop.ClientSpawnPointProto.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ClientSpawnPointProto.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ClientSpawnPointProto.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.ClientSpawnPointProto.Builder {
        return try ResponseEnvelop.ClientSpawnPointProto.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.ClientSpawnPointProto) throws -> ResponseEnvelop.ClientSpawnPointProto.Builder {
        return try ResponseEnvelop.ClientSpawnPointProto.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasLatitude {
          output += "\(indent) latitude: \(latitude) \n"
        }
        if hasLongitude {
          output += "\(indent) longitude: \(longitude) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasLatitude {
                 hashCode = (hashCode &* 31) &+ latitude.hashValue
              }
              if hasLongitude {
                 hashCode = (hashCode &* 31) &+ longitude.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.ClientSpawnPointProto"
      }
      override public func className() -> String {
          return "ResponseEnvelop.ClientSpawnPointProto"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.ClientSpawnPointProto.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.ClientSpawnPointProto = ResponseEnvelop.ClientSpawnPointProto()
        public func getMessage() -> ResponseEnvelop.ClientSpawnPointProto {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasLatitude:Bool {
             get {
                  return builderResult.hasLatitude
             }
        }
        public var latitude:Double {
             get {
                  return builderResult.latitude
             }
             set (value) {
                 builderResult.hasLatitude = true
                 builderResult.latitude = value
             }
        }
        public func setLatitude(value:Double) -> ResponseEnvelop.ClientSpawnPointProto.Builder {
          self.latitude = value
          return self
        }
        public func clearLatitude() -> ResponseEnvelop.ClientSpawnPointProto.Builder{
             builderResult.hasLatitude = false
             builderResult.latitude = Double(0)
             return self
        }
        public var hasLongitude:Bool {
             get {
                  return builderResult.hasLongitude
             }
        }
        public var longitude:Double {
             get {
                  return builderResult.longitude
             }
             set (value) {
                 builderResult.hasLongitude = true
                 builderResult.longitude = value
             }
        }
        public func setLongitude(value:Double) -> ResponseEnvelop.ClientSpawnPointProto.Builder {
          self.longitude = value
          return self
        }
        public func clearLongitude() -> ResponseEnvelop.ClientSpawnPointProto.Builder{
             builderResult.hasLongitude = false
             builderResult.longitude = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.ClientSpawnPointProto.Builder {
          builderResult = ResponseEnvelop.ClientSpawnPointProto()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.ClientSpawnPointProto.Builder {
          return try ResponseEnvelop.ClientSpawnPointProto.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.ClientSpawnPointProto {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.ClientSpawnPointProto {
          let returnMe:ResponseEnvelop.ClientSpawnPointProto = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.ClientSpawnPointProto) throws -> ResponseEnvelop.ClientSpawnPointProto.Builder {
          if other == ResponseEnvelop.ClientSpawnPointProto() {
           return self
          }
          if other.hasLatitude {
               latitude = other.latitude
          }
          if other.hasLongitude {
               longitude = other.longitude
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ClientSpawnPointProto.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ClientSpawnPointProto.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 17 :
              latitude = try input.readDouble()

            case 25 :
              longitude = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class WildPokemonProto : GeneratedMessage, GeneratedMessageProtocol {


      //Nested type declaration start

        final public class Pokemon : GeneratedMessage, GeneratedMessageProtocol {
          public private(set) var id:UInt64 = UInt64(0)

          public private(set) var hasId:Bool = false
          public private(set) var pokemonId:Int32 = Int32(0)

          public private(set) var hasPokemonId:Bool = false
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
            if hasId {
              try output.writeUInt64(1, value:id)
            }
            if hasPokemonId {
              try output.writeInt32(2, value:pokemonId)
            }
            try unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasId {
              serialize_size += id.computeUInt64Size(1)
            }
            if hasPokemonId {
              serialize_size += pokemonId.computeInt32Size(2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
          }
          public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.WildPokemonProto.Pokemon> {
            var mergedArray = Array<ResponseEnvelop.WildPokemonProto.Pokemon>()
            while let value = try parseFromDelimitedFromInputStream(input) {
              mergedArray += [value]
            }
            return mergedArray
          }
          public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.WildPokemonProto.Pokemon? {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.Builder().mergeDelimitedFromInputStream(input)?.build()
          }
          public class func parseFromData(data:NSData) throws -> ResponseEnvelop.WildPokemonProto.Pokemon {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
          }
          public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.WildPokemonProto.Pokemon {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.WildPokemonProto.Pokemon {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.Builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.WildPokemonProto.Pokemon {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.WildPokemonProto.Pokemon {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.Builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.WildPokemonProto.Pokemon {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func getBuilder() -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
            return ResponseEnvelop.WildPokemonProto.Pokemon.classBuilder() as! ResponseEnvelop.WildPokemonProto.Pokemon.Builder
          }
          public func getBuilder() -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
            return classBuilder() as! ResponseEnvelop.WildPokemonProto.Pokemon.Builder
          }
          public override class func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.WildPokemonProto.Pokemon.Builder()
          }
          public override func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.WildPokemonProto.Pokemon.Builder()
          }
          public func toBuilder() throws -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:ResponseEnvelop.WildPokemonProto.Pokemon) throws -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
            return try ResponseEnvelop.WildPokemonProto.Pokemon.Builder().mergeFrom(prototype)
          }
          override public func getDescription(indent:String) throws -> String {
            var output:String = ""
            if hasId {
              output += "\(indent) id: \(id) \n"
            }
            if hasPokemonId {
              output += "\(indent) pokemonId: \(pokemonId) \n"
            }
            output += unknownFields.getDescription(indent)
            return output
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasId {
                     hashCode = (hashCode &* 31) &+ id.hashValue
                  }
                  if hasPokemonId {
                     hashCode = (hashCode &* 31) &+ pokemonId.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "ResponseEnvelop.WildPokemonProto.Pokemon"
          }
          override public func className() -> String {
              return "ResponseEnvelop.WildPokemonProto.Pokemon"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return ResponseEnvelop.WildPokemonProto.Pokemon.self
          }
          //Meta information declaration end

          final public class Builder : GeneratedMessageBuilder {
            private var builderResult:ResponseEnvelop.WildPokemonProto.Pokemon = ResponseEnvelop.WildPokemonProto.Pokemon()
            public func getMessage() -> ResponseEnvelop.WildPokemonProto.Pokemon {
                return builderResult
            }

            required override public init () {
               super.init()
            }
            public var hasId:Bool {
                 get {
                      return builderResult.hasId
                 }
            }
            public var id:UInt64 {
                 get {
                      return builderResult.id
                 }
                 set (value) {
                     builderResult.hasId = true
                     builderResult.id = value
                 }
            }
            public func setId(value:UInt64) -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
              self.id = value
              return self
            }
            public func clearId() -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder{
                 builderResult.hasId = false
                 builderResult.id = UInt64(0)
                 return self
            }
            public var hasPokemonId:Bool {
                 get {
                      return builderResult.hasPokemonId
                 }
            }
            public var pokemonId:Int32 {
                 get {
                      return builderResult.pokemonId
                 }
                 set (value) {
                     builderResult.hasPokemonId = true
                     builderResult.pokemonId = value
                 }
            }
            public func setPokemonId(value:Int32) -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
              self.pokemonId = value
              return self
            }
            public func clearPokemonId() -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder{
                 builderResult.hasPokemonId = false
                 builderResult.pokemonId = Int32(0)
                 return self
            }
            override public var internalGetResult:GeneratedMessage {
                 get {
                    return builderResult
                 }
            }
            public override func clear() -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
              builderResult = ResponseEnvelop.WildPokemonProto.Pokemon()
              return self
            }
            public override func clone() throws -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
              return try ResponseEnvelop.WildPokemonProto.Pokemon.builderWithPrototype(builderResult)
            }
            public override func build() throws -> ResponseEnvelop.WildPokemonProto.Pokemon {
                 try checkInitialized()
                 return buildPartial()
            }
            public func buildPartial() -> ResponseEnvelop.WildPokemonProto.Pokemon {
              let returnMe:ResponseEnvelop.WildPokemonProto.Pokemon = builderResult
              return returnMe
            }
            public func mergeFrom(other:ResponseEnvelop.WildPokemonProto.Pokemon) throws -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
              if other == ResponseEnvelop.WildPokemonProto.Pokemon() {
               return self
              }
              if other.hasId {
                   id = other.id
              }
              if other.hasPokemonId {
                   pokemonId = other.pokemonId
              }
              try mergeUnknownFields(other.unknownFields)
              return self
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
                 return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
              let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
              while (true) {
                let protobufTag = try input.readTag()
                switch protobufTag {
                case 0: 
                  self.unknownFields = try unknownFieldsBuilder.build()
                  return self

                case 8 :
                  id = try input.readUInt64()

                case 16 :
                  pokemonId = try input.readInt32()

                default:
                  if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                     unknownFields = try unknownFieldsBuilder.build()
                     return self
                  }
                }
              }
            }
          }

        }

      //Nested type declaration end

      public private(set) var encounterId:UInt64 = UInt64(0)

      public private(set) var hasEncounterId:Bool = false
      public private(set) var lastModifiedMs:Int64 = Int64(0)

      public private(set) var hasLastModifiedMs:Bool = false
      public private(set) var latitude:Double = Double(0)

      public private(set) var hasLatitude:Bool = false
      public private(set) var longitude:Double = Double(0)

      public private(set) var hasLongitude:Bool = false
      public private(set) var spawnPointId:String = ""

      public private(set) var hasSpawnPointId:Bool = false
      public private(set) var pokemon:ResponseEnvelop.WildPokemonProto.Pokemon!
      public private(set) var hasPokemon:Bool = false
      public private(set) var timeTillHiddenMs:Int32 = Int32(0)

      public private(set) var hasTimeTillHiddenMs:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasEncounterId {
          try output.writeFixed64(1, value:encounterId)
        }
        if hasLastModifiedMs {
          try output.writeInt64(2, value:lastModifiedMs)
        }
        if hasLatitude {
          try output.writeDouble(3, value:latitude)
        }
        if hasLongitude {
          try output.writeDouble(4, value:longitude)
        }
        if hasSpawnPointId {
          try output.writeString(5, value:spawnPointId)
        }
        if hasPokemon {
          try output.writeMessage(7, value:pokemon)
        }
        if hasTimeTillHiddenMs {
          try output.writeInt32(11, value:timeTillHiddenMs)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasEncounterId {
          serialize_size += encounterId.computeFixed64Size(1)
        }
        if hasLastModifiedMs {
          serialize_size += lastModifiedMs.computeInt64Size(2)
        }
        if hasLatitude {
          serialize_size += latitude.computeDoubleSize(3)
        }
        if hasLongitude {
          serialize_size += longitude.computeDoubleSize(4)
        }
        if hasSpawnPointId {
          serialize_size += spawnPointId.computeStringSize(5)
        }
        if hasPokemon {
            if let varSizepokemon = pokemon?.computeMessageSize(7) {
                serialize_size += varSizepokemon
            }
        }
        if hasTimeTillHiddenMs {
          serialize_size += timeTillHiddenMs.computeInt32Size(11)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.WildPokemonProto> {
        var mergedArray = Array<ResponseEnvelop.WildPokemonProto>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.WildPokemonProto? {
        return try ResponseEnvelop.WildPokemonProto.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.WildPokemonProto {
        return try ResponseEnvelop.WildPokemonProto.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.WildPokemonProto {
        return try ResponseEnvelop.WildPokemonProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.WildPokemonProto {
        return try ResponseEnvelop.WildPokemonProto.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.WildPokemonProto {
        return try ResponseEnvelop.WildPokemonProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.WildPokemonProto {
        return try ResponseEnvelop.WildPokemonProto.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.WildPokemonProto {
        return try ResponseEnvelop.WildPokemonProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.WildPokemonProto.Builder {
        return ResponseEnvelop.WildPokemonProto.classBuilder() as! ResponseEnvelop.WildPokemonProto.Builder
      }
      public func getBuilder() -> ResponseEnvelop.WildPokemonProto.Builder {
        return classBuilder() as! ResponseEnvelop.WildPokemonProto.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.WildPokemonProto.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.WildPokemonProto.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.WildPokemonProto.Builder {
        return try ResponseEnvelop.WildPokemonProto.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.WildPokemonProto) throws -> ResponseEnvelop.WildPokemonProto.Builder {
        return try ResponseEnvelop.WildPokemonProto.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasEncounterId {
          output += "\(indent) encounterId: \(encounterId) \n"
        }
        if hasLastModifiedMs {
          output += "\(indent) lastModifiedMs: \(lastModifiedMs) \n"
        }
        if hasLatitude {
          output += "\(indent) latitude: \(latitude) \n"
        }
        if hasLongitude {
          output += "\(indent) longitude: \(longitude) \n"
        }
        if hasSpawnPointId {
          output += "\(indent) spawnPointId: \(spawnPointId) \n"
        }
        if hasPokemon {
          output += "\(indent) pokemon {\n"
          if let outDescPokemon = pokemon {
            output += try outDescPokemon.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasTimeTillHiddenMs {
          output += "\(indent) timeTillHiddenMs: \(timeTillHiddenMs) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasEncounterId {
                 hashCode = (hashCode &* 31) &+ encounterId.hashValue
              }
              if hasLastModifiedMs {
                 hashCode = (hashCode &* 31) &+ lastModifiedMs.hashValue
              }
              if hasLatitude {
                 hashCode = (hashCode &* 31) &+ latitude.hashValue
              }
              if hasLongitude {
                 hashCode = (hashCode &* 31) &+ longitude.hashValue
              }
              if hasSpawnPointId {
                 hashCode = (hashCode &* 31) &+ spawnPointId.hashValue
              }
              if hasPokemon {
                  if let hashValuepokemon = pokemon?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuepokemon
                  }
              }
              if hasTimeTillHiddenMs {
                 hashCode = (hashCode &* 31) &+ timeTillHiddenMs.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.WildPokemonProto"
      }
      override public func className() -> String {
          return "ResponseEnvelop.WildPokemonProto"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.WildPokemonProto.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.WildPokemonProto = ResponseEnvelop.WildPokemonProto()
        public func getMessage() -> ResponseEnvelop.WildPokemonProto {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasEncounterId:Bool {
             get {
                  return builderResult.hasEncounterId
             }
        }
        public var encounterId:UInt64 {
             get {
                  return builderResult.encounterId
             }
             set (value) {
                 builderResult.hasEncounterId = true
                 builderResult.encounterId = value
             }
        }
        public func setEncounterId(value:UInt64) -> ResponseEnvelop.WildPokemonProto.Builder {
          self.encounterId = value
          return self
        }
        public func clearEncounterId() -> ResponseEnvelop.WildPokemonProto.Builder{
             builderResult.hasEncounterId = false
             builderResult.encounterId = UInt64(0)
             return self
        }
        public var hasLastModifiedMs:Bool {
             get {
                  return builderResult.hasLastModifiedMs
             }
        }
        public var lastModifiedMs:Int64 {
             get {
                  return builderResult.lastModifiedMs
             }
             set (value) {
                 builderResult.hasLastModifiedMs = true
                 builderResult.lastModifiedMs = value
             }
        }
        public func setLastModifiedMs(value:Int64) -> ResponseEnvelop.WildPokemonProto.Builder {
          self.lastModifiedMs = value
          return self
        }
        public func clearLastModifiedMs() -> ResponseEnvelop.WildPokemonProto.Builder{
             builderResult.hasLastModifiedMs = false
             builderResult.lastModifiedMs = Int64(0)
             return self
        }
        public var hasLatitude:Bool {
             get {
                  return builderResult.hasLatitude
             }
        }
        public var latitude:Double {
             get {
                  return builderResult.latitude
             }
             set (value) {
                 builderResult.hasLatitude = true
                 builderResult.latitude = value
             }
        }
        public func setLatitude(value:Double) -> ResponseEnvelop.WildPokemonProto.Builder {
          self.latitude = value
          return self
        }
        public func clearLatitude() -> ResponseEnvelop.WildPokemonProto.Builder{
             builderResult.hasLatitude = false
             builderResult.latitude = Double(0)
             return self
        }
        public var hasLongitude:Bool {
             get {
                  return builderResult.hasLongitude
             }
        }
        public var longitude:Double {
             get {
                  return builderResult.longitude
             }
             set (value) {
                 builderResult.hasLongitude = true
                 builderResult.longitude = value
             }
        }
        public func setLongitude(value:Double) -> ResponseEnvelop.WildPokemonProto.Builder {
          self.longitude = value
          return self
        }
        public func clearLongitude() -> ResponseEnvelop.WildPokemonProto.Builder{
             builderResult.hasLongitude = false
             builderResult.longitude = Double(0)
             return self
        }
        public var hasSpawnPointId:Bool {
             get {
                  return builderResult.hasSpawnPointId
             }
        }
        public var spawnPointId:String {
             get {
                  return builderResult.spawnPointId
             }
             set (value) {
                 builderResult.hasSpawnPointId = true
                 builderResult.spawnPointId = value
             }
        }
        public func setSpawnPointId(value:String) -> ResponseEnvelop.WildPokemonProto.Builder {
          self.spawnPointId = value
          return self
        }
        public func clearSpawnPointId() -> ResponseEnvelop.WildPokemonProto.Builder{
             builderResult.hasSpawnPointId = false
             builderResult.spawnPointId = ""
             return self
        }
        public var hasPokemon:Bool {
             get {
                 return builderResult.hasPokemon
             }
        }
        public var pokemon:ResponseEnvelop.WildPokemonProto.Pokemon! {
             get {
                 if pokemonBuilder_ != nil {
                    builderResult.pokemon = pokemonBuilder_.getMessage()
                 }
                 return builderResult.pokemon
             }
             set (value) {
                 builderResult.hasPokemon = true
                 builderResult.pokemon = value
             }
        }
        private var pokemonBuilder_:ResponseEnvelop.WildPokemonProto.Pokemon.Builder! {
             didSet {
                builderResult.hasPokemon = true
             }
        }
        public func getPokemonBuilder() -> ResponseEnvelop.WildPokemonProto.Pokemon.Builder {
          if pokemonBuilder_ == nil {
             pokemonBuilder_ = ResponseEnvelop.WildPokemonProto.Pokemon.Builder()
             builderResult.pokemon = pokemonBuilder_.getMessage()
             if pokemon != nil {
                try! pokemonBuilder_.mergeFrom(pokemon)
             }
          }
          return pokemonBuilder_
        }
        public func setPokemon(value:ResponseEnvelop.WildPokemonProto.Pokemon!) -> ResponseEnvelop.WildPokemonProto.Builder {
          self.pokemon = value
          return self
        }
        public func mergePokemon(value:ResponseEnvelop.WildPokemonProto.Pokemon) throws -> ResponseEnvelop.WildPokemonProto.Builder {
          if builderResult.hasPokemon {
            builderResult.pokemon = try ResponseEnvelop.WildPokemonProto.Pokemon.builderWithPrototype(builderResult.pokemon).mergeFrom(value).buildPartial()
          } else {
            builderResult.pokemon = value
          }
          builderResult.hasPokemon = true
          return self
        }
        public func clearPokemon() -> ResponseEnvelop.WildPokemonProto.Builder {
          pokemonBuilder_ = nil
          builderResult.hasPokemon = false
          builderResult.pokemon = nil
          return self
        }
        public var hasTimeTillHiddenMs:Bool {
             get {
                  return builderResult.hasTimeTillHiddenMs
             }
        }
        public var timeTillHiddenMs:Int32 {
             get {
                  return builderResult.timeTillHiddenMs
             }
             set (value) {
                 builderResult.hasTimeTillHiddenMs = true
                 builderResult.timeTillHiddenMs = value
             }
        }
        public func setTimeTillHiddenMs(value:Int32) -> ResponseEnvelop.WildPokemonProto.Builder {
          self.timeTillHiddenMs = value
          return self
        }
        public func clearTimeTillHiddenMs() -> ResponseEnvelop.WildPokemonProto.Builder{
             builderResult.hasTimeTillHiddenMs = false
             builderResult.timeTillHiddenMs = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.WildPokemonProto.Builder {
          builderResult = ResponseEnvelop.WildPokemonProto()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.WildPokemonProto.Builder {
          return try ResponseEnvelop.WildPokemonProto.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.WildPokemonProto {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.WildPokemonProto {
          let returnMe:ResponseEnvelop.WildPokemonProto = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.WildPokemonProto) throws -> ResponseEnvelop.WildPokemonProto.Builder {
          if other == ResponseEnvelop.WildPokemonProto() {
           return self
          }
          if other.hasEncounterId {
               encounterId = other.encounterId
          }
          if other.hasLastModifiedMs {
               lastModifiedMs = other.lastModifiedMs
          }
          if other.hasLatitude {
               latitude = other.latitude
          }
          if other.hasLongitude {
               longitude = other.longitude
          }
          if other.hasSpawnPointId {
               spawnPointId = other.spawnPointId
          }
          if (other.hasPokemon) {
              try mergePokemon(other.pokemon)
          }
          if other.hasTimeTillHiddenMs {
               timeTillHiddenMs = other.timeTillHiddenMs
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.WildPokemonProto.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.WildPokemonProto.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 9 :
              encounterId = try input.readFixed64()

            case 16 :
              lastModifiedMs = try input.readInt64()

            case 25 :
              latitude = try input.readDouble()

            case 33 :
              longitude = try input.readDouble()

            case 42 :
              spawnPointId = try input.readString()

            case 58 :
              let subBuilder:ResponseEnvelop.WildPokemonProto.Pokemon.Builder = ResponseEnvelop.WildPokemonProto.Pokemon.Builder()
              if hasPokemon {
                try subBuilder.mergeFrom(pokemon)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              pokemon = subBuilder.buildPartial()

            case 88 :
              timeTillHiddenMs = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class NearbyPokemonProto : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var pokedexNumber:Int32 = Int32(0)

      public private(set) var hasPokedexNumber:Bool = false
      public private(set) var distanceMeters:Float = Float(0)

      public private(set) var hasDistanceMeters:Bool = false
      public private(set) var encounterId:UInt64 = UInt64(0)

      public private(set) var hasEncounterId:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasPokedexNumber {
          try output.writeInt32(1, value:pokedexNumber)
        }
        if hasDistanceMeters {
          try output.writeFloat(2, value:distanceMeters)
        }
        if hasEncounterId {
          try output.writeFixed64(3, value:encounterId)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPokedexNumber {
          serialize_size += pokedexNumber.computeInt32Size(1)
        }
        if hasDistanceMeters {
          serialize_size += distanceMeters.computeFloatSize(2)
        }
        if hasEncounterId {
          serialize_size += encounterId.computeFixed64Size(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.NearbyPokemonProto> {
        var mergedArray = Array<ResponseEnvelop.NearbyPokemonProto>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.NearbyPokemonProto? {
        return try ResponseEnvelop.NearbyPokemonProto.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.NearbyPokemonProto {
        return try ResponseEnvelop.NearbyPokemonProto.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.NearbyPokemonProto {
        return try ResponseEnvelop.NearbyPokemonProto.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.NearbyPokemonProto {
        return try ResponseEnvelop.NearbyPokemonProto.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.NearbyPokemonProto {
        return try ResponseEnvelop.NearbyPokemonProto.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.NearbyPokemonProto {
        return try ResponseEnvelop.NearbyPokemonProto.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.NearbyPokemonProto {
        return try ResponseEnvelop.NearbyPokemonProto.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.NearbyPokemonProto.Builder {
        return ResponseEnvelop.NearbyPokemonProto.classBuilder() as! ResponseEnvelop.NearbyPokemonProto.Builder
      }
      public func getBuilder() -> ResponseEnvelop.NearbyPokemonProto.Builder {
        return classBuilder() as! ResponseEnvelop.NearbyPokemonProto.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.NearbyPokemonProto.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.NearbyPokemonProto.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.NearbyPokemonProto.Builder {
        return try ResponseEnvelop.NearbyPokemonProto.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.NearbyPokemonProto) throws -> ResponseEnvelop.NearbyPokemonProto.Builder {
        return try ResponseEnvelop.NearbyPokemonProto.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasPokedexNumber {
          output += "\(indent) pokedexNumber: \(pokedexNumber) \n"
        }
        if hasDistanceMeters {
          output += "\(indent) distanceMeters: \(distanceMeters) \n"
        }
        if hasEncounterId {
          output += "\(indent) encounterId: \(encounterId) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasPokedexNumber {
                 hashCode = (hashCode &* 31) &+ pokedexNumber.hashValue
              }
              if hasDistanceMeters {
                 hashCode = (hashCode &* 31) &+ distanceMeters.hashValue
              }
              if hasEncounterId {
                 hashCode = (hashCode &* 31) &+ encounterId.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.NearbyPokemonProto"
      }
      override public func className() -> String {
          return "ResponseEnvelop.NearbyPokemonProto"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.NearbyPokemonProto.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.NearbyPokemonProto = ResponseEnvelop.NearbyPokemonProto()
        public func getMessage() -> ResponseEnvelop.NearbyPokemonProto {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasPokedexNumber:Bool {
             get {
                  return builderResult.hasPokedexNumber
             }
        }
        public var pokedexNumber:Int32 {
             get {
                  return builderResult.pokedexNumber
             }
             set (value) {
                 builderResult.hasPokedexNumber = true
                 builderResult.pokedexNumber = value
             }
        }
        public func setPokedexNumber(value:Int32) -> ResponseEnvelop.NearbyPokemonProto.Builder {
          self.pokedexNumber = value
          return self
        }
        public func clearPokedexNumber() -> ResponseEnvelop.NearbyPokemonProto.Builder{
             builderResult.hasPokedexNumber = false
             builderResult.pokedexNumber = Int32(0)
             return self
        }
        public var hasDistanceMeters:Bool {
             get {
                  return builderResult.hasDistanceMeters
             }
        }
        public var distanceMeters:Float {
             get {
                  return builderResult.distanceMeters
             }
             set (value) {
                 builderResult.hasDistanceMeters = true
                 builderResult.distanceMeters = value
             }
        }
        public func setDistanceMeters(value:Float) -> ResponseEnvelop.NearbyPokemonProto.Builder {
          self.distanceMeters = value
          return self
        }
        public func clearDistanceMeters() -> ResponseEnvelop.NearbyPokemonProto.Builder{
             builderResult.hasDistanceMeters = false
             builderResult.distanceMeters = Float(0)
             return self
        }
        public var hasEncounterId:Bool {
             get {
                  return builderResult.hasEncounterId
             }
        }
        public var encounterId:UInt64 {
             get {
                  return builderResult.encounterId
             }
             set (value) {
                 builderResult.hasEncounterId = true
                 builderResult.encounterId = value
             }
        }
        public func setEncounterId(value:UInt64) -> ResponseEnvelop.NearbyPokemonProto.Builder {
          self.encounterId = value
          return self
        }
        public func clearEncounterId() -> ResponseEnvelop.NearbyPokemonProto.Builder{
             builderResult.hasEncounterId = false
             builderResult.encounterId = UInt64(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.NearbyPokemonProto.Builder {
          builderResult = ResponseEnvelop.NearbyPokemonProto()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.NearbyPokemonProto.Builder {
          return try ResponseEnvelop.NearbyPokemonProto.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.NearbyPokemonProto {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.NearbyPokemonProto {
          let returnMe:ResponseEnvelop.NearbyPokemonProto = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.NearbyPokemonProto) throws -> ResponseEnvelop.NearbyPokemonProto.Builder {
          if other == ResponseEnvelop.NearbyPokemonProto() {
           return self
          }
          if other.hasPokedexNumber {
               pokedexNumber = other.pokedexNumber
          }
          if other.hasDistanceMeters {
               distanceMeters = other.distanceMeters
          }
          if other.hasEncounterId {
               encounterId = other.encounterId
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.NearbyPokemonProto.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.NearbyPokemonProto.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              pokedexNumber = try input.readInt32()

            case 21 :
              distanceMeters = try input.readFloat()

            case 25 :
              encounterId = try input.readFixed64()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class ProfilePayload : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var unknown1:Array<Int32> = Array<Int32>()
      public private(set) var profile:ResponseEnvelop.Profile!
      public private(set) var hasProfile:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if hasProfile {
         if !profile.isInitialized() {
           return false
         }
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if !unknown1.isEmpty {
          for oneValueunknown1 in unknown1 {
            try output.writeInt32(1, value:oneValueunknown1)
          }
        }
        if hasProfile {
          try output.writeMessage(2, value:profile)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        var dataSizeUnknown1:Int32 = 0
        for oneValueunknown1 in unknown1 {
            dataSizeUnknown1 += oneValueunknown1.computeInt32SizeNoTag()
        }
        serialize_size += dataSizeUnknown1
        serialize_size += 1 * Int32(unknown1.count)
        if hasProfile {
            if let varSizeprofile = profile?.computeMessageSize(2) {
                serialize_size += varSizeprofile
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.ProfilePayload> {
        var mergedArray = Array<ResponseEnvelop.ProfilePayload>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ProfilePayload? {
        return try ResponseEnvelop.ProfilePayload.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.ProfilePayload {
        return try ResponseEnvelop.ProfilePayload.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ProfilePayload {
        return try ResponseEnvelop.ProfilePayload.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ProfilePayload {
        return try ResponseEnvelop.ProfilePayload.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ProfilePayload {
        return try ResponseEnvelop.ProfilePayload.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ProfilePayload {
        return try ResponseEnvelop.ProfilePayload.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ProfilePayload {
        return try ResponseEnvelop.ProfilePayload.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.ProfilePayload.Builder {
        return ResponseEnvelop.ProfilePayload.classBuilder() as! ResponseEnvelop.ProfilePayload.Builder
      }
      public func getBuilder() -> ResponseEnvelop.ProfilePayload.Builder {
        return classBuilder() as! ResponseEnvelop.ProfilePayload.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ProfilePayload.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ProfilePayload.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.ProfilePayload.Builder {
        return try ResponseEnvelop.ProfilePayload.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.ProfilePayload) throws -> ResponseEnvelop.ProfilePayload.Builder {
        return try ResponseEnvelop.ProfilePayload.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        var unknown1ElementIndex:Int = 0
        for oneValueunknown1 in unknown1  {
            output += "\(indent) unknown1[\(unknown1ElementIndex)]: \(oneValueunknown1)\n"
            unknown1ElementIndex += 1
        }
        if hasProfile {
          output += "\(indent) profile {\n"
          if let outDescProfile = profile {
            output += try outDescProfile.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for oneValueunknown1 in unknown1 {
                  hashCode = (hashCode &* 31) &+ oneValueunknown1.hashValue
              }
              if hasProfile {
                  if let hashValueprofile = profile?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueprofile
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.ProfilePayload"
      }
      override public func className() -> String {
          return "ResponseEnvelop.ProfilePayload"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.ProfilePayload.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.ProfilePayload = ResponseEnvelop.ProfilePayload()
        public func getMessage() -> ResponseEnvelop.ProfilePayload {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var unknown1:Array<Int32> {
             get {
                 return builderResult.unknown1
             }
             set (array) {
                 builderResult.unknown1 = array
             }
        }
        public func setUnknown1(value:Array<Int32>) -> ResponseEnvelop.ProfilePayload.Builder {
          self.unknown1 = value
          return self
        }
        public func clearUnknown1() -> ResponseEnvelop.ProfilePayload.Builder {
           builderResult.unknown1.removeAll(keepCapacity: false)
           return self
        }
        public var hasProfile:Bool {
             get {
                 return builderResult.hasProfile
             }
        }
        public var profile:ResponseEnvelop.Profile! {
             get {
                 if profileBuilder_ != nil {
                    builderResult.profile = profileBuilder_.getMessage()
                 }
                 return builderResult.profile
             }
             set (value) {
                 builderResult.hasProfile = true
                 builderResult.profile = value
             }
        }
        private var profileBuilder_:ResponseEnvelop.Profile.Builder! {
             didSet {
                builderResult.hasProfile = true
             }
        }
        public func getProfileBuilder() -> ResponseEnvelop.Profile.Builder {
          if profileBuilder_ == nil {
             profileBuilder_ = ResponseEnvelop.Profile.Builder()
             builderResult.profile = profileBuilder_.getMessage()
             if profile != nil {
                try! profileBuilder_.mergeFrom(profile)
             }
          }
          return profileBuilder_
        }
        public func setProfile(value:ResponseEnvelop.Profile!) -> ResponseEnvelop.ProfilePayload.Builder {
          self.profile = value
          return self
        }
        public func mergeProfile(value:ResponseEnvelop.Profile) throws -> ResponseEnvelop.ProfilePayload.Builder {
          if builderResult.hasProfile {
            builderResult.profile = try ResponseEnvelop.Profile.builderWithPrototype(builderResult.profile).mergeFrom(value).buildPartial()
          } else {
            builderResult.profile = value
          }
          builderResult.hasProfile = true
          return self
        }
        public func clearProfile() -> ResponseEnvelop.ProfilePayload.Builder {
          profileBuilder_ = nil
          builderResult.hasProfile = false
          builderResult.profile = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.ProfilePayload.Builder {
          builderResult = ResponseEnvelop.ProfilePayload()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.ProfilePayload.Builder {
          return try ResponseEnvelop.ProfilePayload.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.ProfilePayload {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.ProfilePayload {
          let returnMe:ResponseEnvelop.ProfilePayload = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.ProfilePayload) throws -> ResponseEnvelop.ProfilePayload.Builder {
          if other == ResponseEnvelop.ProfilePayload() {
           return self
          }
          if !other.unknown1.isEmpty {
              builderResult.unknown1 += other.unknown1
          }
          if (other.hasProfile) {
              try mergeProfile(other.profile)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ProfilePayload.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ProfilePayload.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              unknown1 += [try input.readInt32()]

            case 18 :
              let subBuilder:ResponseEnvelop.Profile.Builder = ResponseEnvelop.Profile.Builder()
              if hasProfile {
                try subBuilder.mergeFrom(profile)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              profile = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class Profile : GeneratedMessage, GeneratedMessageProtocol {


      //Nested type declaration start

        final public class AvatarDetails : GeneratedMessage, GeneratedMessageProtocol {
          public private(set) var skin:Int32 = Int32(0)

          public private(set) var hasSkin:Bool = false
          public private(set) var hair:Int32 = Int32(0)

          public private(set) var hasHair:Bool = false
          public private(set) var tshirt:Int32 = Int32(0)

          public private(set) var hasTshirt:Bool = false
          public private(set) var trousers:Int32 = Int32(0)

          public private(set) var hasTrousers:Bool = false
          public private(set) var cap:Int32 = Int32(0)

          public private(set) var hasCap:Bool = false
          public private(set) var boots:Int32 = Int32(0)

          public private(set) var hasBoots:Bool = false
          public private(set) var gender:Int32 = Int32(0)

          public private(set) var hasGender:Bool = false
          public private(set) var eyes:Int32 = Int32(0)

          public private(set) var hasEyes:Bool = false
          public private(set) var backpack:Int32 = Int32(0)

          public private(set) var hasBackpack:Bool = false
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
            if hasSkin {
              try output.writeInt32(2, value:skin)
            }
            if hasHair {
              try output.writeInt32(3, value:hair)
            }
            if hasTshirt {
              try output.writeInt32(4, value:tshirt)
            }
            if hasTrousers {
              try output.writeInt32(5, value:trousers)
            }
            if hasCap {
              try output.writeInt32(6, value:cap)
            }
            if hasBoots {
              try output.writeInt32(7, value:boots)
            }
            if hasGender {
              try output.writeInt32(8, value:gender)
            }
            if hasEyes {
              try output.writeInt32(9, value:eyes)
            }
            if hasBackpack {
              try output.writeInt32(10, value:backpack)
            }
            try unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSkin {
              serialize_size += skin.computeInt32Size(2)
            }
            if hasHair {
              serialize_size += hair.computeInt32Size(3)
            }
            if hasTshirt {
              serialize_size += tshirt.computeInt32Size(4)
            }
            if hasTrousers {
              serialize_size += trousers.computeInt32Size(5)
            }
            if hasCap {
              serialize_size += cap.computeInt32Size(6)
            }
            if hasBoots {
              serialize_size += boots.computeInt32Size(7)
            }
            if hasGender {
              serialize_size += gender.computeInt32Size(8)
            }
            if hasEyes {
              serialize_size += eyes.computeInt32Size(9)
            }
            if hasBackpack {
              serialize_size += backpack.computeInt32Size(10)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
          }
          public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.Profile.AvatarDetails> {
            var mergedArray = Array<ResponseEnvelop.Profile.AvatarDetails>()
            while let value = try parseFromDelimitedFromInputStream(input) {
              mergedArray += [value]
            }
            return mergedArray
          }
          public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Profile.AvatarDetails? {
            return try ResponseEnvelop.Profile.AvatarDetails.Builder().mergeDelimitedFromInputStream(input)?.build()
          }
          public class func parseFromData(data:NSData) throws -> ResponseEnvelop.Profile.AvatarDetails {
            return try ResponseEnvelop.Profile.AvatarDetails.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
          }
          public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.AvatarDetails {
            return try ResponseEnvelop.Profile.AvatarDetails.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Profile.AvatarDetails {
            return try ResponseEnvelop.Profile.AvatarDetails.Builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.AvatarDetails {
            return try ResponseEnvelop.Profile.AvatarDetails.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Profile.AvatarDetails {
            return try ResponseEnvelop.Profile.AvatarDetails.Builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.AvatarDetails {
            return try ResponseEnvelop.Profile.AvatarDetails.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func getBuilder() -> ResponseEnvelop.Profile.AvatarDetails.Builder {
            return ResponseEnvelop.Profile.AvatarDetails.classBuilder() as! ResponseEnvelop.Profile.AvatarDetails.Builder
          }
          public func getBuilder() -> ResponseEnvelop.Profile.AvatarDetails.Builder {
            return classBuilder() as! ResponseEnvelop.Profile.AvatarDetails.Builder
          }
          public override class func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.Profile.AvatarDetails.Builder()
          }
          public override func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.Profile.AvatarDetails.Builder()
          }
          public func toBuilder() throws -> ResponseEnvelop.Profile.AvatarDetails.Builder {
            return try ResponseEnvelop.Profile.AvatarDetails.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:ResponseEnvelop.Profile.AvatarDetails) throws -> ResponseEnvelop.Profile.AvatarDetails.Builder {
            return try ResponseEnvelop.Profile.AvatarDetails.Builder().mergeFrom(prototype)
          }
          override public func getDescription(indent:String) throws -> String {
            var output:String = ""
            if hasSkin {
              output += "\(indent) skin: \(skin) \n"
            }
            if hasHair {
              output += "\(indent) hair: \(hair) \n"
            }
            if hasTshirt {
              output += "\(indent) tshirt: \(tshirt) \n"
            }
            if hasTrousers {
              output += "\(indent) trousers: \(trousers) \n"
            }
            if hasCap {
              output += "\(indent) cap: \(cap) \n"
            }
            if hasBoots {
              output += "\(indent) boots: \(boots) \n"
            }
            if hasGender {
              output += "\(indent) gender: \(gender) \n"
            }
            if hasEyes {
              output += "\(indent) eyes: \(eyes) \n"
            }
            if hasBackpack {
              output += "\(indent) backpack: \(backpack) \n"
            }
            output += unknownFields.getDescription(indent)
            return output
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasSkin {
                     hashCode = (hashCode &* 31) &+ skin.hashValue
                  }
                  if hasHair {
                     hashCode = (hashCode &* 31) &+ hair.hashValue
                  }
                  if hasTshirt {
                     hashCode = (hashCode &* 31) &+ tshirt.hashValue
                  }
                  if hasTrousers {
                     hashCode = (hashCode &* 31) &+ trousers.hashValue
                  }
                  if hasCap {
                     hashCode = (hashCode &* 31) &+ cap.hashValue
                  }
                  if hasBoots {
                     hashCode = (hashCode &* 31) &+ boots.hashValue
                  }
                  if hasGender {
                     hashCode = (hashCode &* 31) &+ gender.hashValue
                  }
                  if hasEyes {
                     hashCode = (hashCode &* 31) &+ eyes.hashValue
                  }
                  if hasBackpack {
                     hashCode = (hashCode &* 31) &+ backpack.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "ResponseEnvelop.Profile.AvatarDetails"
          }
          override public func className() -> String {
              return "ResponseEnvelop.Profile.AvatarDetails"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return ResponseEnvelop.Profile.AvatarDetails.self
          }
          //Meta information declaration end

          final public class Builder : GeneratedMessageBuilder {
            private var builderResult:ResponseEnvelop.Profile.AvatarDetails = ResponseEnvelop.Profile.AvatarDetails()
            public func getMessage() -> ResponseEnvelop.Profile.AvatarDetails {
                return builderResult
            }

            required override public init () {
               super.init()
            }
            public var hasSkin:Bool {
                 get {
                      return builderResult.hasSkin
                 }
            }
            public var skin:Int32 {
                 get {
                      return builderResult.skin
                 }
                 set (value) {
                     builderResult.hasSkin = true
                     builderResult.skin = value
                 }
            }
            public func setSkin(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.skin = value
              return self
            }
            public func clearSkin() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasSkin = false
                 builderResult.skin = Int32(0)
                 return self
            }
            public var hasHair:Bool {
                 get {
                      return builderResult.hasHair
                 }
            }
            public var hair:Int32 {
                 get {
                      return builderResult.hair
                 }
                 set (value) {
                     builderResult.hasHair = true
                     builderResult.hair = value
                 }
            }
            public func setHair(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.hair = value
              return self
            }
            public func clearHair() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasHair = false
                 builderResult.hair = Int32(0)
                 return self
            }
            public var hasTshirt:Bool {
                 get {
                      return builderResult.hasTshirt
                 }
            }
            public var tshirt:Int32 {
                 get {
                      return builderResult.tshirt
                 }
                 set (value) {
                     builderResult.hasTshirt = true
                     builderResult.tshirt = value
                 }
            }
            public func setTshirt(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.tshirt = value
              return self
            }
            public func clearTshirt() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasTshirt = false
                 builderResult.tshirt = Int32(0)
                 return self
            }
            public var hasTrousers:Bool {
                 get {
                      return builderResult.hasTrousers
                 }
            }
            public var trousers:Int32 {
                 get {
                      return builderResult.trousers
                 }
                 set (value) {
                     builderResult.hasTrousers = true
                     builderResult.trousers = value
                 }
            }
            public func setTrousers(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.trousers = value
              return self
            }
            public func clearTrousers() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasTrousers = false
                 builderResult.trousers = Int32(0)
                 return self
            }
            public var hasCap:Bool {
                 get {
                      return builderResult.hasCap
                 }
            }
            public var cap:Int32 {
                 get {
                      return builderResult.cap
                 }
                 set (value) {
                     builderResult.hasCap = true
                     builderResult.cap = value
                 }
            }
            public func setCap(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.cap = value
              return self
            }
            public func clearCap() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasCap = false
                 builderResult.cap = Int32(0)
                 return self
            }
            public var hasBoots:Bool {
                 get {
                      return builderResult.hasBoots
                 }
            }
            public var boots:Int32 {
                 get {
                      return builderResult.boots
                 }
                 set (value) {
                     builderResult.hasBoots = true
                     builderResult.boots = value
                 }
            }
            public func setBoots(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.boots = value
              return self
            }
            public func clearBoots() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasBoots = false
                 builderResult.boots = Int32(0)
                 return self
            }
            public var hasGender:Bool {
                 get {
                      return builderResult.hasGender
                 }
            }
            public var gender:Int32 {
                 get {
                      return builderResult.gender
                 }
                 set (value) {
                     builderResult.hasGender = true
                     builderResult.gender = value
                 }
            }
            public func setGender(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.gender = value
              return self
            }
            public func clearGender() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasGender = false
                 builderResult.gender = Int32(0)
                 return self
            }
            public var hasEyes:Bool {
                 get {
                      return builderResult.hasEyes
                 }
            }
            public var eyes:Int32 {
                 get {
                      return builderResult.eyes
                 }
                 set (value) {
                     builderResult.hasEyes = true
                     builderResult.eyes = value
                 }
            }
            public func setEyes(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.eyes = value
              return self
            }
            public func clearEyes() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasEyes = false
                 builderResult.eyes = Int32(0)
                 return self
            }
            public var hasBackpack:Bool {
                 get {
                      return builderResult.hasBackpack
                 }
            }
            public var backpack:Int32 {
                 get {
                      return builderResult.backpack
                 }
                 set (value) {
                     builderResult.hasBackpack = true
                     builderResult.backpack = value
                 }
            }
            public func setBackpack(value:Int32) -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              self.backpack = value
              return self
            }
            public func clearBackpack() -> ResponseEnvelop.Profile.AvatarDetails.Builder{
                 builderResult.hasBackpack = false
                 builderResult.backpack = Int32(0)
                 return self
            }
            override public var internalGetResult:GeneratedMessage {
                 get {
                    return builderResult
                 }
            }
            public override func clear() -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              builderResult = ResponseEnvelop.Profile.AvatarDetails()
              return self
            }
            public override func clone() throws -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              return try ResponseEnvelop.Profile.AvatarDetails.builderWithPrototype(builderResult)
            }
            public override func build() throws -> ResponseEnvelop.Profile.AvatarDetails {
                 try checkInitialized()
                 return buildPartial()
            }
            public func buildPartial() -> ResponseEnvelop.Profile.AvatarDetails {
              let returnMe:ResponseEnvelop.Profile.AvatarDetails = builderResult
              return returnMe
            }
            public func mergeFrom(other:ResponseEnvelop.Profile.AvatarDetails) throws -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              if other == ResponseEnvelop.Profile.AvatarDetails() {
               return self
              }
              if other.hasSkin {
                   skin = other.skin
              }
              if other.hasHair {
                   hair = other.hair
              }
              if other.hasTshirt {
                   tshirt = other.tshirt
              }
              if other.hasTrousers {
                   trousers = other.trousers
              }
              if other.hasCap {
                   cap = other.cap
              }
              if other.hasBoots {
                   boots = other.boots
              }
              if other.hasGender {
                   gender = other.gender
              }
              if other.hasEyes {
                   eyes = other.eyes
              }
              if other.hasBackpack {
                   backpack = other.backpack
              }
              try mergeUnknownFields(other.unknownFields)
              return self
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Profile.AvatarDetails.Builder {
                 return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.AvatarDetails.Builder {
              let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
              while (true) {
                let protobufTag = try input.readTag()
                switch protobufTag {
                case 0: 
                  self.unknownFields = try unknownFieldsBuilder.build()
                  return self

                case 16 :
                  skin = try input.readInt32()

                case 24 :
                  hair = try input.readInt32()

                case 32 :
                  tshirt = try input.readInt32()

                case 40 :
                  trousers = try input.readInt32()

                case 48 :
                  cap = try input.readInt32()

                case 56 :
                  boots = try input.readInt32()

                case 64 :
                  gender = try input.readInt32()

                case 72 :
                  eyes = try input.readInt32()

                case 80 :
                  backpack = try input.readInt32()

                default:
                  if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                     unknownFields = try unknownFieldsBuilder.build()
                     return self
                  }
                }
              }
            }
          }

        }

      //Nested type declaration end



      //Nested type declaration start

        final public class DailyBonus : GeneratedMessage, GeneratedMessageProtocol {
          public private(set) var nextCollectTimestampMs:Int64 = Int64(0)

          public private(set) var hasNextCollectTimestampMs:Bool = false
          public private(set) var nextDefenderBonusCollectTimestampMs:Int64 = Int64(0)

          public private(set) var hasNextDefenderBonusCollectTimestampMs:Bool = false
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
            if hasNextCollectTimestampMs {
              try output.writeInt64(1, value:nextCollectTimestampMs)
            }
            if hasNextDefenderBonusCollectTimestampMs {
              try output.writeInt64(2, value:nextDefenderBonusCollectTimestampMs)
            }
            try unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasNextCollectTimestampMs {
              serialize_size += nextCollectTimestampMs.computeInt64Size(1)
            }
            if hasNextDefenderBonusCollectTimestampMs {
              serialize_size += nextDefenderBonusCollectTimestampMs.computeInt64Size(2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
          }
          public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.Profile.DailyBonus> {
            var mergedArray = Array<ResponseEnvelop.Profile.DailyBonus>()
            while let value = try parseFromDelimitedFromInputStream(input) {
              mergedArray += [value]
            }
            return mergedArray
          }
          public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Profile.DailyBonus? {
            return try ResponseEnvelop.Profile.DailyBonus.Builder().mergeDelimitedFromInputStream(input)?.build()
          }
          public class func parseFromData(data:NSData) throws -> ResponseEnvelop.Profile.DailyBonus {
            return try ResponseEnvelop.Profile.DailyBonus.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
          }
          public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.DailyBonus {
            return try ResponseEnvelop.Profile.DailyBonus.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Profile.DailyBonus {
            return try ResponseEnvelop.Profile.DailyBonus.Builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.DailyBonus {
            return try ResponseEnvelop.Profile.DailyBonus.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Profile.DailyBonus {
            return try ResponseEnvelop.Profile.DailyBonus.Builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.DailyBonus {
            return try ResponseEnvelop.Profile.DailyBonus.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func getBuilder() -> ResponseEnvelop.Profile.DailyBonus.Builder {
            return ResponseEnvelop.Profile.DailyBonus.classBuilder() as! ResponseEnvelop.Profile.DailyBonus.Builder
          }
          public func getBuilder() -> ResponseEnvelop.Profile.DailyBonus.Builder {
            return classBuilder() as! ResponseEnvelop.Profile.DailyBonus.Builder
          }
          public override class func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.Profile.DailyBonus.Builder()
          }
          public override func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.Profile.DailyBonus.Builder()
          }
          public func toBuilder() throws -> ResponseEnvelop.Profile.DailyBonus.Builder {
            return try ResponseEnvelop.Profile.DailyBonus.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:ResponseEnvelop.Profile.DailyBonus) throws -> ResponseEnvelop.Profile.DailyBonus.Builder {
            return try ResponseEnvelop.Profile.DailyBonus.Builder().mergeFrom(prototype)
          }
          override public func getDescription(indent:String) throws -> String {
            var output:String = ""
            if hasNextCollectTimestampMs {
              output += "\(indent) nextCollectTimestampMs: \(nextCollectTimestampMs) \n"
            }
            if hasNextDefenderBonusCollectTimestampMs {
              output += "\(indent) nextDefenderBonusCollectTimestampMs: \(nextDefenderBonusCollectTimestampMs) \n"
            }
            output += unknownFields.getDescription(indent)
            return output
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasNextCollectTimestampMs {
                     hashCode = (hashCode &* 31) &+ nextCollectTimestampMs.hashValue
                  }
                  if hasNextDefenderBonusCollectTimestampMs {
                     hashCode = (hashCode &* 31) &+ nextDefenderBonusCollectTimestampMs.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "ResponseEnvelop.Profile.DailyBonus"
          }
          override public func className() -> String {
              return "ResponseEnvelop.Profile.DailyBonus"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return ResponseEnvelop.Profile.DailyBonus.self
          }
          //Meta information declaration end

          final public class Builder : GeneratedMessageBuilder {
            private var builderResult:ResponseEnvelop.Profile.DailyBonus = ResponseEnvelop.Profile.DailyBonus()
            public func getMessage() -> ResponseEnvelop.Profile.DailyBonus {
                return builderResult
            }

            required override public init () {
               super.init()
            }
            public var hasNextCollectTimestampMs:Bool {
                 get {
                      return builderResult.hasNextCollectTimestampMs
                 }
            }
            public var nextCollectTimestampMs:Int64 {
                 get {
                      return builderResult.nextCollectTimestampMs
                 }
                 set (value) {
                     builderResult.hasNextCollectTimestampMs = true
                     builderResult.nextCollectTimestampMs = value
                 }
            }
            public func setNextCollectTimestampMs(value:Int64) -> ResponseEnvelop.Profile.DailyBonus.Builder {
              self.nextCollectTimestampMs = value
              return self
            }
            public func clearNextCollectTimestampMs() -> ResponseEnvelop.Profile.DailyBonus.Builder{
                 builderResult.hasNextCollectTimestampMs = false
                 builderResult.nextCollectTimestampMs = Int64(0)
                 return self
            }
            public var hasNextDefenderBonusCollectTimestampMs:Bool {
                 get {
                      return builderResult.hasNextDefenderBonusCollectTimestampMs
                 }
            }
            public var nextDefenderBonusCollectTimestampMs:Int64 {
                 get {
                      return builderResult.nextDefenderBonusCollectTimestampMs
                 }
                 set (value) {
                     builderResult.hasNextDefenderBonusCollectTimestampMs = true
                     builderResult.nextDefenderBonusCollectTimestampMs = value
                 }
            }
            public func setNextDefenderBonusCollectTimestampMs(value:Int64) -> ResponseEnvelop.Profile.DailyBonus.Builder {
              self.nextDefenderBonusCollectTimestampMs = value
              return self
            }
            public func clearNextDefenderBonusCollectTimestampMs() -> ResponseEnvelop.Profile.DailyBonus.Builder{
                 builderResult.hasNextDefenderBonusCollectTimestampMs = false
                 builderResult.nextDefenderBonusCollectTimestampMs = Int64(0)
                 return self
            }
            override public var internalGetResult:GeneratedMessage {
                 get {
                    return builderResult
                 }
            }
            public override func clear() -> ResponseEnvelop.Profile.DailyBonus.Builder {
              builderResult = ResponseEnvelop.Profile.DailyBonus()
              return self
            }
            public override func clone() throws -> ResponseEnvelop.Profile.DailyBonus.Builder {
              return try ResponseEnvelop.Profile.DailyBonus.builderWithPrototype(builderResult)
            }
            public override func build() throws -> ResponseEnvelop.Profile.DailyBonus {
                 try checkInitialized()
                 return buildPartial()
            }
            public func buildPartial() -> ResponseEnvelop.Profile.DailyBonus {
              let returnMe:ResponseEnvelop.Profile.DailyBonus = builderResult
              return returnMe
            }
            public func mergeFrom(other:ResponseEnvelop.Profile.DailyBonus) throws -> ResponseEnvelop.Profile.DailyBonus.Builder {
              if other == ResponseEnvelop.Profile.DailyBonus() {
               return self
              }
              if other.hasNextCollectTimestampMs {
                   nextCollectTimestampMs = other.nextCollectTimestampMs
              }
              if other.hasNextDefenderBonusCollectTimestampMs {
                   nextDefenderBonusCollectTimestampMs = other.nextDefenderBonusCollectTimestampMs
              }
              try mergeUnknownFields(other.unknownFields)
              return self
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Profile.DailyBonus.Builder {
                 return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.DailyBonus.Builder {
              let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
              while (true) {
                let protobufTag = try input.readTag()
                switch protobufTag {
                case 0: 
                  self.unknownFields = try unknownFieldsBuilder.build()
                  return self

                case 8 :
                  nextCollectTimestampMs = try input.readInt64()

                case 16 :
                  nextDefenderBonusCollectTimestampMs = try input.readInt64()

                default:
                  if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                     unknownFields = try unknownFieldsBuilder.build()
                     return self
                  }
                }
              }
            }
          }

        }

      //Nested type declaration end



      //Nested type declaration start

        final public class Currency : GeneratedMessage, GeneratedMessageProtocol {
          public private(set) var types:String = ""

          public private(set) var hasTypes:Bool = false
          public private(set) var amount:Int32 = Int32(0)

          public private(set) var hasAmount:Bool = false
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
            if !hasTypes {
              return false
            }
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
            if hasTypes {
              try output.writeString(1, value:types)
            }
            if hasAmount {
              try output.writeInt32(2, value:amount)
            }
            try unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTypes {
              serialize_size += types.computeStringSize(1)
            }
            if hasAmount {
              serialize_size += amount.computeInt32Size(2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
          }
          public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.Profile.Currency> {
            var mergedArray = Array<ResponseEnvelop.Profile.Currency>()
            while let value = try parseFromDelimitedFromInputStream(input) {
              mergedArray += [value]
            }
            return mergedArray
          }
          public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Profile.Currency? {
            return try ResponseEnvelop.Profile.Currency.Builder().mergeDelimitedFromInputStream(input)?.build()
          }
          public class func parseFromData(data:NSData) throws -> ResponseEnvelop.Profile.Currency {
            return try ResponseEnvelop.Profile.Currency.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
          }
          public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.Currency {
            return try ResponseEnvelop.Profile.Currency.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Profile.Currency {
            return try ResponseEnvelop.Profile.Currency.Builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.Currency {
            return try ResponseEnvelop.Profile.Currency.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Profile.Currency {
            return try ResponseEnvelop.Profile.Currency.Builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.Currency {
            return try ResponseEnvelop.Profile.Currency.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func getBuilder() -> ResponseEnvelop.Profile.Currency.Builder {
            return ResponseEnvelop.Profile.Currency.classBuilder() as! ResponseEnvelop.Profile.Currency.Builder
          }
          public func getBuilder() -> ResponseEnvelop.Profile.Currency.Builder {
            return classBuilder() as! ResponseEnvelop.Profile.Currency.Builder
          }
          public override class func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.Profile.Currency.Builder()
          }
          public override func classBuilder() -> MessageBuilder {
            return ResponseEnvelop.Profile.Currency.Builder()
          }
          public func toBuilder() throws -> ResponseEnvelop.Profile.Currency.Builder {
            return try ResponseEnvelop.Profile.Currency.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:ResponseEnvelop.Profile.Currency) throws -> ResponseEnvelop.Profile.Currency.Builder {
            return try ResponseEnvelop.Profile.Currency.Builder().mergeFrom(prototype)
          }
          override public func getDescription(indent:String) throws -> String {
            var output:String = ""
            if hasTypes {
              output += "\(indent) types: \(types) \n"
            }
            if hasAmount {
              output += "\(indent) amount: \(amount) \n"
            }
            output += unknownFields.getDescription(indent)
            return output
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasTypes {
                     hashCode = (hashCode &* 31) &+ types.hashValue
                  }
                  if hasAmount {
                     hashCode = (hashCode &* 31) &+ amount.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "ResponseEnvelop.Profile.Currency"
          }
          override public func className() -> String {
              return "ResponseEnvelop.Profile.Currency"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return ResponseEnvelop.Profile.Currency.self
          }
          //Meta information declaration end

          final public class Builder : GeneratedMessageBuilder {
            private var builderResult:ResponseEnvelop.Profile.Currency = ResponseEnvelop.Profile.Currency()
            public func getMessage() -> ResponseEnvelop.Profile.Currency {
                return builderResult
            }

            required override public init () {
               super.init()
            }
            public var hasTypes:Bool {
                 get {
                      return builderResult.hasTypes
                 }
            }
            public var types:String {
                 get {
                      return builderResult.types
                 }
                 set (value) {
                     builderResult.hasTypes = true
                     builderResult.types = value
                 }
            }
            public func setTypes(value:String) -> ResponseEnvelop.Profile.Currency.Builder {
              self.types = value
              return self
            }
            public func clearTypes() -> ResponseEnvelop.Profile.Currency.Builder{
                 builderResult.hasTypes = false
                 builderResult.types = ""
                 return self
            }
            public var hasAmount:Bool {
                 get {
                      return builderResult.hasAmount
                 }
            }
            public var amount:Int32 {
                 get {
                      return builderResult.amount
                 }
                 set (value) {
                     builderResult.hasAmount = true
                     builderResult.amount = value
                 }
            }
            public func setAmount(value:Int32) -> ResponseEnvelop.Profile.Currency.Builder {
              self.amount = value
              return self
            }
            public func clearAmount() -> ResponseEnvelop.Profile.Currency.Builder{
                 builderResult.hasAmount = false
                 builderResult.amount = Int32(0)
                 return self
            }
            override public var internalGetResult:GeneratedMessage {
                 get {
                    return builderResult
                 }
            }
            public override func clear() -> ResponseEnvelop.Profile.Currency.Builder {
              builderResult = ResponseEnvelop.Profile.Currency()
              return self
            }
            public override func clone() throws -> ResponseEnvelop.Profile.Currency.Builder {
              return try ResponseEnvelop.Profile.Currency.builderWithPrototype(builderResult)
            }
            public override func build() throws -> ResponseEnvelop.Profile.Currency {
                 try checkInitialized()
                 return buildPartial()
            }
            public func buildPartial() -> ResponseEnvelop.Profile.Currency {
              let returnMe:ResponseEnvelop.Profile.Currency = builderResult
              return returnMe
            }
            public func mergeFrom(other:ResponseEnvelop.Profile.Currency) throws -> ResponseEnvelop.Profile.Currency.Builder {
              if other == ResponseEnvelop.Profile.Currency() {
               return self
              }
              if other.hasTypes {
                   types = other.types
              }
              if other.hasAmount {
                   amount = other.amount
              }
              try mergeUnknownFields(other.unknownFields)
              return self
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Profile.Currency.Builder {
                 return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
            }
            public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.Currency.Builder {
              let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
              while (true) {
                let protobufTag = try input.readTag()
                switch protobufTag {
                case 0: 
                  self.unknownFields = try unknownFieldsBuilder.build()
                  return self

                case 10 :
                  types = try input.readString()

                case 16 :
                  amount = try input.readInt32()

                default:
                  if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                     unknownFields = try unknownFieldsBuilder.build()
                     return self
                  }
                }
              }
            }
          }

        }

      //Nested type declaration end

      public private(set) var creationTime:Int64 = Int64(0)

      public private(set) var hasCreationTime:Bool = false
      public private(set) var username:String = ""

      public private(set) var hasUsername:Bool = false
      public private(set) var team:Int32 = Int32(0)

      public private(set) var hasTeam:Bool = false
      public private(set) var tutorial:NSData = NSData()

      public private(set) var hasTutorial:Bool = false
      public private(set) var avatar:ResponseEnvelop.Profile.AvatarDetails!
      public private(set) var hasAvatar:Bool = false
      public private(set) var pokeStorage:Int32 = Int32(0)

      public private(set) var hasPokeStorage:Bool = false
      public private(set) var itemStorage:Int32 = Int32(0)

      public private(set) var hasItemStorage:Bool = false
      public private(set) var dailyBonus:ResponseEnvelop.Profile.DailyBonus!
      public private(set) var hasDailyBonus:Bool = false
      public private(set) var unknown12:NSData = NSData()

      public private(set) var hasUnknown12:Bool = false
      public private(set) var unknown13:NSData = NSData()

      public private(set) var hasUnknown13:Bool = false
      public private(set) var currency:Array<ResponseEnvelop.Profile.Currency>  = Array<ResponseEnvelop.Profile.Currency>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasCreationTime {
          return false
        }
        var isInitcurrency:Bool = true
        for oneElementcurrency in currency {
            if (!oneElementcurrency.isInitialized()) {
                isInitcurrency = false
                break 
            }
        }
        if !isInitcurrency {
         return isInitcurrency
         }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasCreationTime {
          try output.writeInt64(1, value:creationTime)
        }
        if hasUsername {
          try output.writeString(2, value:username)
        }
        if hasTeam {
          try output.writeInt32(5, value:team)
        }
        if hasTutorial {
          try output.writeData(7, value:tutorial)
        }
        if hasAvatar {
          try output.writeMessage(8, value:avatar)
        }
        if hasPokeStorage {
          try output.writeInt32(9, value:pokeStorage)
        }
        if hasItemStorage {
          try output.writeInt32(10, value:itemStorage)
        }
        if hasDailyBonus {
          try output.writeMessage(11, value:dailyBonus)
        }
        if hasUnknown12 {
          try output.writeData(12, value:unknown12)
        }
        if hasUnknown13 {
          try output.writeData(13, value:unknown13)
        }
        for oneElementcurrency in currency {
            try output.writeMessage(14, value:oneElementcurrency)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasCreationTime {
          serialize_size += creationTime.computeInt64Size(1)
        }
        if hasUsername {
          serialize_size += username.computeStringSize(2)
        }
        if hasTeam {
          serialize_size += team.computeInt32Size(5)
        }
        if hasTutorial {
          serialize_size += tutorial.computeDataSize(7)
        }
        if hasAvatar {
            if let varSizeavatar = avatar?.computeMessageSize(8) {
                serialize_size += varSizeavatar
            }
        }
        if hasPokeStorage {
          serialize_size += pokeStorage.computeInt32Size(9)
        }
        if hasItemStorage {
          serialize_size += itemStorage.computeInt32Size(10)
        }
        if hasDailyBonus {
            if let varSizedailyBonus = dailyBonus?.computeMessageSize(11) {
                serialize_size += varSizedailyBonus
            }
        }
        if hasUnknown12 {
          serialize_size += unknown12.computeDataSize(12)
        }
        if hasUnknown13 {
          serialize_size += unknown13.computeDataSize(13)
        }
        for oneElementcurrency in currency {
            serialize_size += oneElementcurrency.computeMessageSize(14)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.Profile> {
        var mergedArray = Array<ResponseEnvelop.Profile>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Profile? {
        return try ResponseEnvelop.Profile.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.Profile {
        return try ResponseEnvelop.Profile.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile {
        return try ResponseEnvelop.Profile.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Profile {
        return try ResponseEnvelop.Profile.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile {
        return try ResponseEnvelop.Profile.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Profile {
        return try ResponseEnvelop.Profile.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile {
        return try ResponseEnvelop.Profile.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.Profile.Builder {
        return ResponseEnvelop.Profile.classBuilder() as! ResponseEnvelop.Profile.Builder
      }
      public func getBuilder() -> ResponseEnvelop.Profile.Builder {
        return classBuilder() as! ResponseEnvelop.Profile.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.Profile.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.Profile.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.Profile.Builder {
        return try ResponseEnvelop.Profile.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.Profile) throws -> ResponseEnvelop.Profile.Builder {
        return try ResponseEnvelop.Profile.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasCreationTime {
          output += "\(indent) creationTime: \(creationTime) \n"
        }
        if hasUsername {
          output += "\(indent) username: \(username) \n"
        }
        if hasTeam {
          output += "\(indent) team: \(team) \n"
        }
        if hasTutorial {
          output += "\(indent) tutorial: \(tutorial) \n"
        }
        if hasAvatar {
          output += "\(indent) avatar {\n"
          if let outDescAvatar = avatar {
            output += try outDescAvatar.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasPokeStorage {
          output += "\(indent) pokeStorage: \(pokeStorage) \n"
        }
        if hasItemStorage {
          output += "\(indent) itemStorage: \(itemStorage) \n"
        }
        if hasDailyBonus {
          output += "\(indent) dailyBonus {\n"
          if let outDescDailyBonus = dailyBonus {
            output += try outDescDailyBonus.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasUnknown12 {
          output += "\(indent) unknown12: \(unknown12) \n"
        }
        if hasUnknown13 {
          output += "\(indent) unknown13: \(unknown13) \n"
        }
        var currencyElementIndex:Int = 0
        for oneElementcurrency in currency {
            output += "\(indent) currency[\(currencyElementIndex)] {\n"
            output += try oneElementcurrency.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            currencyElementIndex += 1
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasCreationTime {
                 hashCode = (hashCode &* 31) &+ creationTime.hashValue
              }
              if hasUsername {
                 hashCode = (hashCode &* 31) &+ username.hashValue
              }
              if hasTeam {
                 hashCode = (hashCode &* 31) &+ team.hashValue
              }
              if hasTutorial {
                 hashCode = (hashCode &* 31) &+ tutorial.hashValue
              }
              if hasAvatar {
                  if let hashValueavatar = avatar?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueavatar
                  }
              }
              if hasPokeStorage {
                 hashCode = (hashCode &* 31) &+ pokeStorage.hashValue
              }
              if hasItemStorage {
                 hashCode = (hashCode &* 31) &+ itemStorage.hashValue
              }
              if hasDailyBonus {
                  if let hashValuedailyBonus = dailyBonus?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuedailyBonus
                  }
              }
              if hasUnknown12 {
                 hashCode = (hashCode &* 31) &+ unknown12.hashValue
              }
              if hasUnknown13 {
                 hashCode = (hashCode &* 31) &+ unknown13.hashValue
              }
              for oneElementcurrency in currency {
                  hashCode = (hashCode &* 31) &+ oneElementcurrency.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.Profile"
      }
      override public func className() -> String {
          return "ResponseEnvelop.Profile"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.Profile.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.Profile = ResponseEnvelop.Profile()
        public func getMessage() -> ResponseEnvelop.Profile {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasCreationTime:Bool {
             get {
                  return builderResult.hasCreationTime
             }
        }
        public var creationTime:Int64 {
             get {
                  return builderResult.creationTime
             }
             set (value) {
                 builderResult.hasCreationTime = true
                 builderResult.creationTime = value
             }
        }
        public func setCreationTime(value:Int64) -> ResponseEnvelop.Profile.Builder {
          self.creationTime = value
          return self
        }
        public func clearCreationTime() -> ResponseEnvelop.Profile.Builder{
             builderResult.hasCreationTime = false
             builderResult.creationTime = Int64(0)
             return self
        }
        public var hasUsername:Bool {
             get {
                  return builderResult.hasUsername
             }
        }
        public var username:String {
             get {
                  return builderResult.username
             }
             set (value) {
                 builderResult.hasUsername = true
                 builderResult.username = value
             }
        }
        public func setUsername(value:String) -> ResponseEnvelop.Profile.Builder {
          self.username = value
          return self
        }
        public func clearUsername() -> ResponseEnvelop.Profile.Builder{
             builderResult.hasUsername = false
             builderResult.username = ""
             return self
        }
        public var hasTeam:Bool {
             get {
                  return builderResult.hasTeam
             }
        }
        public var team:Int32 {
             get {
                  return builderResult.team
             }
             set (value) {
                 builderResult.hasTeam = true
                 builderResult.team = value
             }
        }
        public func setTeam(value:Int32) -> ResponseEnvelop.Profile.Builder {
          self.team = value
          return self
        }
        public func clearTeam() -> ResponseEnvelop.Profile.Builder{
             builderResult.hasTeam = false
             builderResult.team = Int32(0)
             return self
        }
        public var hasTutorial:Bool {
             get {
                  return builderResult.hasTutorial
             }
        }
        public var tutorial:NSData {
             get {
                  return builderResult.tutorial
             }
             set (value) {
                 builderResult.hasTutorial = true
                 builderResult.tutorial = value
             }
        }
        public func setTutorial(value:NSData) -> ResponseEnvelop.Profile.Builder {
          self.tutorial = value
          return self
        }
        public func clearTutorial() -> ResponseEnvelop.Profile.Builder{
             builderResult.hasTutorial = false
             builderResult.tutorial = NSData()
             return self
        }
        public var hasAvatar:Bool {
             get {
                 return builderResult.hasAvatar
             }
        }
        public var avatar:ResponseEnvelop.Profile.AvatarDetails! {
             get {
                 if avatarBuilder_ != nil {
                    builderResult.avatar = avatarBuilder_.getMessage()
                 }
                 return builderResult.avatar
             }
             set (value) {
                 builderResult.hasAvatar = true
                 builderResult.avatar = value
             }
        }
        private var avatarBuilder_:ResponseEnvelop.Profile.AvatarDetails.Builder! {
             didSet {
                builderResult.hasAvatar = true
             }
        }
        public func getAvatarBuilder() -> ResponseEnvelop.Profile.AvatarDetails.Builder {
          if avatarBuilder_ == nil {
             avatarBuilder_ = ResponseEnvelop.Profile.AvatarDetails.Builder()
             builderResult.avatar = avatarBuilder_.getMessage()
             if avatar != nil {
                try! avatarBuilder_.mergeFrom(avatar)
             }
          }
          return avatarBuilder_
        }
        public func setAvatar(value:ResponseEnvelop.Profile.AvatarDetails!) -> ResponseEnvelop.Profile.Builder {
          self.avatar = value
          return self
        }
        public func mergeAvatar(value:ResponseEnvelop.Profile.AvatarDetails) throws -> ResponseEnvelop.Profile.Builder {
          if builderResult.hasAvatar {
            builderResult.avatar = try ResponseEnvelop.Profile.AvatarDetails.builderWithPrototype(builderResult.avatar).mergeFrom(value).buildPartial()
          } else {
            builderResult.avatar = value
          }
          builderResult.hasAvatar = true
          return self
        }
        public func clearAvatar() -> ResponseEnvelop.Profile.Builder {
          avatarBuilder_ = nil
          builderResult.hasAvatar = false
          builderResult.avatar = nil
          return self
        }
        public var hasPokeStorage:Bool {
             get {
                  return builderResult.hasPokeStorage
             }
        }
        public var pokeStorage:Int32 {
             get {
                  return builderResult.pokeStorage
             }
             set (value) {
                 builderResult.hasPokeStorage = true
                 builderResult.pokeStorage = value
             }
        }
        public func setPokeStorage(value:Int32) -> ResponseEnvelop.Profile.Builder {
          self.pokeStorage = value
          return self
        }
        public func clearPokeStorage() -> ResponseEnvelop.Profile.Builder{
             builderResult.hasPokeStorage = false
             builderResult.pokeStorage = Int32(0)
             return self
        }
        public var hasItemStorage:Bool {
             get {
                  return builderResult.hasItemStorage
             }
        }
        public var itemStorage:Int32 {
             get {
                  return builderResult.itemStorage
             }
             set (value) {
                 builderResult.hasItemStorage = true
                 builderResult.itemStorage = value
             }
        }
        public func setItemStorage(value:Int32) -> ResponseEnvelop.Profile.Builder {
          self.itemStorage = value
          return self
        }
        public func clearItemStorage() -> ResponseEnvelop.Profile.Builder{
             builderResult.hasItemStorage = false
             builderResult.itemStorage = Int32(0)
             return self
        }
        public var hasDailyBonus:Bool {
             get {
                 return builderResult.hasDailyBonus
             }
        }
        public var dailyBonus:ResponseEnvelop.Profile.DailyBonus! {
             get {
                 if dailyBonusBuilder_ != nil {
                    builderResult.dailyBonus = dailyBonusBuilder_.getMessage()
                 }
                 return builderResult.dailyBonus
             }
             set (value) {
                 builderResult.hasDailyBonus = true
                 builderResult.dailyBonus = value
             }
        }
        private var dailyBonusBuilder_:ResponseEnvelop.Profile.DailyBonus.Builder! {
             didSet {
                builderResult.hasDailyBonus = true
             }
        }
        public func getDailyBonusBuilder() -> ResponseEnvelop.Profile.DailyBonus.Builder {
          if dailyBonusBuilder_ == nil {
             dailyBonusBuilder_ = ResponseEnvelop.Profile.DailyBonus.Builder()
             builderResult.dailyBonus = dailyBonusBuilder_.getMessage()
             if dailyBonus != nil {
                try! dailyBonusBuilder_.mergeFrom(dailyBonus)
             }
          }
          return dailyBonusBuilder_
        }
        public func setDailyBonus(value:ResponseEnvelop.Profile.DailyBonus!) -> ResponseEnvelop.Profile.Builder {
          self.dailyBonus = value
          return self
        }
        public func mergeDailyBonus(value:ResponseEnvelop.Profile.DailyBonus) throws -> ResponseEnvelop.Profile.Builder {
          if builderResult.hasDailyBonus {
            builderResult.dailyBonus = try ResponseEnvelop.Profile.DailyBonus.builderWithPrototype(builderResult.dailyBonus).mergeFrom(value).buildPartial()
          } else {
            builderResult.dailyBonus = value
          }
          builderResult.hasDailyBonus = true
          return self
        }
        public func clearDailyBonus() -> ResponseEnvelop.Profile.Builder {
          dailyBonusBuilder_ = nil
          builderResult.hasDailyBonus = false
          builderResult.dailyBonus = nil
          return self
        }
        public var hasUnknown12:Bool {
             get {
                  return builderResult.hasUnknown12
             }
        }
        public var unknown12:NSData {
             get {
                  return builderResult.unknown12
             }
             set (value) {
                 builderResult.hasUnknown12 = true
                 builderResult.unknown12 = value
             }
        }
        public func setUnknown12(value:NSData) -> ResponseEnvelop.Profile.Builder {
          self.unknown12 = value
          return self
        }
        public func clearUnknown12() -> ResponseEnvelop.Profile.Builder{
             builderResult.hasUnknown12 = false
             builderResult.unknown12 = NSData()
             return self
        }
        public var hasUnknown13:Bool {
             get {
                  return builderResult.hasUnknown13
             }
        }
        public var unknown13:NSData {
             get {
                  return builderResult.unknown13
             }
             set (value) {
                 builderResult.hasUnknown13 = true
                 builderResult.unknown13 = value
             }
        }
        public func setUnknown13(value:NSData) -> ResponseEnvelop.Profile.Builder {
          self.unknown13 = value
          return self
        }
        public func clearUnknown13() -> ResponseEnvelop.Profile.Builder{
             builderResult.hasUnknown13 = false
             builderResult.unknown13 = NSData()
             return self
        }
        public var currency:Array<ResponseEnvelop.Profile.Currency> {
             get {
                 return builderResult.currency
             }
             set (value) {
                 builderResult.currency = value
             }
        }
        public func setCurrency(value:Array<ResponseEnvelop.Profile.Currency>) -> ResponseEnvelop.Profile.Builder {
          self.currency = value
          return self
        }
        public func clearCurrency() -> ResponseEnvelop.Profile.Builder {
          builderResult.currency.removeAll(keepCapacity: false)
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.Profile.Builder {
          builderResult = ResponseEnvelop.Profile()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.Profile.Builder {
          return try ResponseEnvelop.Profile.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.Profile {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.Profile {
          let returnMe:ResponseEnvelop.Profile = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.Profile) throws -> ResponseEnvelop.Profile.Builder {
          if other == ResponseEnvelop.Profile() {
           return self
          }
          if other.hasCreationTime {
               creationTime = other.creationTime
          }
          if other.hasUsername {
               username = other.username
          }
          if other.hasTeam {
               team = other.team
          }
          if other.hasTutorial {
               tutorial = other.tutorial
          }
          if (other.hasAvatar) {
              try mergeAvatar(other.avatar)
          }
          if other.hasPokeStorage {
               pokeStorage = other.pokeStorage
          }
          if other.hasItemStorage {
               itemStorage = other.itemStorage
          }
          if (other.hasDailyBonus) {
              try mergeDailyBonus(other.dailyBonus)
          }
          if other.hasUnknown12 {
               unknown12 = other.unknown12
          }
          if other.hasUnknown13 {
               unknown13 = other.unknown13
          }
          if !other.currency.isEmpty  {
             builderResult.currency += other.currency
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Profile.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Profile.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              creationTime = try input.readInt64()

            case 18 :
              username = try input.readString()

            case 40 :
              team = try input.readInt32()

            case 58 :
              tutorial = try input.readData()

            case 66 :
              let subBuilder:ResponseEnvelop.Profile.AvatarDetails.Builder = ResponseEnvelop.Profile.AvatarDetails.Builder()
              if hasAvatar {
                try subBuilder.mergeFrom(avatar)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              avatar = subBuilder.buildPartial()

            case 72 :
              pokeStorage = try input.readInt32()

            case 80 :
              itemStorage = try input.readInt32()

            case 90 :
              let subBuilder:ResponseEnvelop.Profile.DailyBonus.Builder = ResponseEnvelop.Profile.DailyBonus.Builder()
              if hasDailyBonus {
                try subBuilder.mergeFrom(dailyBonus)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              dailyBonus = subBuilder.buildPartial()

            case 98 :
              unknown12 = try input.readData()

            case 106 :
              unknown13 = try input.readData()

            case 114 :
              let subBuilder = ResponseEnvelop.Profile.Currency.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              currency += [subBuilder.buildPartial()]

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class GetInventoryResponse : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var success:Bool = false

      public private(set) var hasSuccess:Bool = false
      public private(set) var inventoryDelta:ResponseEnvelop.InventoryDelta!
      public private(set) var hasInventoryDelta:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasSuccess {
          try output.writeBool(1, value:success)
        }
        if hasInventoryDelta {
          try output.writeMessage(2, value:inventoryDelta)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSuccess {
          serialize_size += success.computeBoolSize(1)
        }
        if hasInventoryDelta {
            if let varSizeinventoryDelta = inventoryDelta?.computeMessageSize(2) {
                serialize_size += varSizeinventoryDelta
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.GetInventoryResponse> {
        var mergedArray = Array<ResponseEnvelop.GetInventoryResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.GetInventoryResponse? {
        return try ResponseEnvelop.GetInventoryResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.GetInventoryResponse {
        return try ResponseEnvelop.GetInventoryResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.GetInventoryResponse {
        return try ResponseEnvelop.GetInventoryResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.GetInventoryResponse {
        return try ResponseEnvelop.GetInventoryResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.GetInventoryResponse {
        return try ResponseEnvelop.GetInventoryResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.GetInventoryResponse {
        return try ResponseEnvelop.GetInventoryResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.GetInventoryResponse {
        return try ResponseEnvelop.GetInventoryResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.GetInventoryResponse.Builder {
        return ResponseEnvelop.GetInventoryResponse.classBuilder() as! ResponseEnvelop.GetInventoryResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.GetInventoryResponse.Builder {
        return classBuilder() as! ResponseEnvelop.GetInventoryResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.GetInventoryResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.GetInventoryResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.GetInventoryResponse.Builder {
        return try ResponseEnvelop.GetInventoryResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.GetInventoryResponse) throws -> ResponseEnvelop.GetInventoryResponse.Builder {
        return try ResponseEnvelop.GetInventoryResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasSuccess {
          output += "\(indent) success: \(success) \n"
        }
        if hasInventoryDelta {
          output += "\(indent) inventoryDelta {\n"
          if let outDescInventoryDelta = inventoryDelta {
            output += try outDescInventoryDelta.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasSuccess {
                 hashCode = (hashCode &* 31) &+ success.hashValue
              }
              if hasInventoryDelta {
                  if let hashValueinventoryDelta = inventoryDelta?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueinventoryDelta
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.GetInventoryResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.GetInventoryResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.GetInventoryResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.GetInventoryResponse = ResponseEnvelop.GetInventoryResponse()
        public func getMessage() -> ResponseEnvelop.GetInventoryResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasSuccess:Bool {
             get {
                  return builderResult.hasSuccess
             }
        }
        public var success:Bool {
             get {
                  return builderResult.success
             }
             set (value) {
                 builderResult.hasSuccess = true
                 builderResult.success = value
             }
        }
        public func setSuccess(value:Bool) -> ResponseEnvelop.GetInventoryResponse.Builder {
          self.success = value
          return self
        }
        public func clearSuccess() -> ResponseEnvelop.GetInventoryResponse.Builder{
             builderResult.hasSuccess = false
             builderResult.success = false
             return self
        }
        public var hasInventoryDelta:Bool {
             get {
                 return builderResult.hasInventoryDelta
             }
        }
        public var inventoryDelta:ResponseEnvelop.InventoryDelta! {
             get {
                 if inventoryDeltaBuilder_ != nil {
                    builderResult.inventoryDelta = inventoryDeltaBuilder_.getMessage()
                 }
                 return builderResult.inventoryDelta
             }
             set (value) {
                 builderResult.hasInventoryDelta = true
                 builderResult.inventoryDelta = value
             }
        }
        private var inventoryDeltaBuilder_:ResponseEnvelop.InventoryDelta.Builder! {
             didSet {
                builderResult.hasInventoryDelta = true
             }
        }
        public func getInventoryDeltaBuilder() -> ResponseEnvelop.InventoryDelta.Builder {
          if inventoryDeltaBuilder_ == nil {
             inventoryDeltaBuilder_ = ResponseEnvelop.InventoryDelta.Builder()
             builderResult.inventoryDelta = inventoryDeltaBuilder_.getMessage()
             if inventoryDelta != nil {
                try! inventoryDeltaBuilder_.mergeFrom(inventoryDelta)
             }
          }
          return inventoryDeltaBuilder_
        }
        public func setInventoryDelta(value:ResponseEnvelop.InventoryDelta!) -> ResponseEnvelop.GetInventoryResponse.Builder {
          self.inventoryDelta = value
          return self
        }
        public func mergeInventoryDelta(value:ResponseEnvelop.InventoryDelta) throws -> ResponseEnvelop.GetInventoryResponse.Builder {
          if builderResult.hasInventoryDelta {
            builderResult.inventoryDelta = try ResponseEnvelop.InventoryDelta.builderWithPrototype(builderResult.inventoryDelta).mergeFrom(value).buildPartial()
          } else {
            builderResult.inventoryDelta = value
          }
          builderResult.hasInventoryDelta = true
          return self
        }
        public func clearInventoryDelta() -> ResponseEnvelop.GetInventoryResponse.Builder {
          inventoryDeltaBuilder_ = nil
          builderResult.hasInventoryDelta = false
          builderResult.inventoryDelta = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.GetInventoryResponse.Builder {
          builderResult = ResponseEnvelop.GetInventoryResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.GetInventoryResponse.Builder {
          return try ResponseEnvelop.GetInventoryResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.GetInventoryResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.GetInventoryResponse {
          let returnMe:ResponseEnvelop.GetInventoryResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.GetInventoryResponse) throws -> ResponseEnvelop.GetInventoryResponse.Builder {
          if other == ResponseEnvelop.GetInventoryResponse() {
           return self
          }
          if other.hasSuccess {
               success = other.success
          }
          if (other.hasInventoryDelta) {
              try mergeInventoryDelta(other.inventoryDelta)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.GetInventoryResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.GetInventoryResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              success = try input.readBool()

            case 18 :
              let subBuilder:ResponseEnvelop.InventoryDelta.Builder = ResponseEnvelop.InventoryDelta.Builder()
              if hasInventoryDelta {
                try subBuilder.mergeFrom(inventoryDelta)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              inventoryDelta = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class InventoryDelta : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var originalTimestampMs:Int64 = Int64(0)

      public private(set) var hasOriginalTimestampMs:Bool = false
      public private(set) var newTimestampMs:Int64 = Int64(0)

      public private(set) var hasNewTimestampMs:Bool = false
      public private(set) var inventoryItems:Array<ResponseEnvelop.InventoryItem>  = Array<ResponseEnvelop.InventoryItem>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasOriginalTimestampMs {
          try output.writeInt64(1, value:originalTimestampMs)
        }
        if hasNewTimestampMs {
          try output.writeInt64(2, value:newTimestampMs)
        }
        for oneElementinventoryItems in inventoryItems {
            try output.writeMessage(3, value:oneElementinventoryItems)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasOriginalTimestampMs {
          serialize_size += originalTimestampMs.computeInt64Size(1)
        }
        if hasNewTimestampMs {
          serialize_size += newTimestampMs.computeInt64Size(2)
        }
        for oneElementinventoryItems in inventoryItems {
            serialize_size += oneElementinventoryItems.computeMessageSize(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.InventoryDelta> {
        var mergedArray = Array<ResponseEnvelop.InventoryDelta>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryDelta? {
        return try ResponseEnvelop.InventoryDelta.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.InventoryDelta {
        return try ResponseEnvelop.InventoryDelta.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryDelta {
        return try ResponseEnvelop.InventoryDelta.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryDelta {
        return try ResponseEnvelop.InventoryDelta.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryDelta {
        return try ResponseEnvelop.InventoryDelta.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryDelta {
        return try ResponseEnvelop.InventoryDelta.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryDelta {
        return try ResponseEnvelop.InventoryDelta.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.InventoryDelta.Builder {
        return ResponseEnvelop.InventoryDelta.classBuilder() as! ResponseEnvelop.InventoryDelta.Builder
      }
      public func getBuilder() -> ResponseEnvelop.InventoryDelta.Builder {
        return classBuilder() as! ResponseEnvelop.InventoryDelta.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryDelta.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryDelta.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.InventoryDelta.Builder {
        return try ResponseEnvelop.InventoryDelta.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.InventoryDelta) throws -> ResponseEnvelop.InventoryDelta.Builder {
        return try ResponseEnvelop.InventoryDelta.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasOriginalTimestampMs {
          output += "\(indent) originalTimestampMs: \(originalTimestampMs) \n"
        }
        if hasNewTimestampMs {
          output += "\(indent) newTimestampMs: \(newTimestampMs) \n"
        }
        var inventoryItemsElementIndex:Int = 0
        for oneElementinventoryItems in inventoryItems {
            output += "\(indent) inventoryItems[\(inventoryItemsElementIndex)] {\n"
            output += try oneElementinventoryItems.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            inventoryItemsElementIndex += 1
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasOriginalTimestampMs {
                 hashCode = (hashCode &* 31) &+ originalTimestampMs.hashValue
              }
              if hasNewTimestampMs {
                 hashCode = (hashCode &* 31) &+ newTimestampMs.hashValue
              }
              for oneElementinventoryItems in inventoryItems {
                  hashCode = (hashCode &* 31) &+ oneElementinventoryItems.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.InventoryDelta"
      }
      override public func className() -> String {
          return "ResponseEnvelop.InventoryDelta"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.InventoryDelta.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.InventoryDelta = ResponseEnvelop.InventoryDelta()
        public func getMessage() -> ResponseEnvelop.InventoryDelta {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasOriginalTimestampMs:Bool {
             get {
                  return builderResult.hasOriginalTimestampMs
             }
        }
        public var originalTimestampMs:Int64 {
             get {
                  return builderResult.originalTimestampMs
             }
             set (value) {
                 builderResult.hasOriginalTimestampMs = true
                 builderResult.originalTimestampMs = value
             }
        }
        public func setOriginalTimestampMs(value:Int64) -> ResponseEnvelop.InventoryDelta.Builder {
          self.originalTimestampMs = value
          return self
        }
        public func clearOriginalTimestampMs() -> ResponseEnvelop.InventoryDelta.Builder{
             builderResult.hasOriginalTimestampMs = false
             builderResult.originalTimestampMs = Int64(0)
             return self
        }
        public var hasNewTimestampMs:Bool {
             get {
                  return builderResult.hasNewTimestampMs
             }
        }
        public var newTimestampMs:Int64 {
             get {
                  return builderResult.newTimestampMs
             }
             set (value) {
                 builderResult.hasNewTimestampMs = true
                 builderResult.newTimestampMs = value
             }
        }
        public func setNewTimestampMs(value:Int64) -> ResponseEnvelop.InventoryDelta.Builder {
          self.newTimestampMs = value
          return self
        }
        public func clearNewTimestampMs() -> ResponseEnvelop.InventoryDelta.Builder{
             builderResult.hasNewTimestampMs = false
             builderResult.newTimestampMs = Int64(0)
             return self
        }
        public var inventoryItems:Array<ResponseEnvelop.InventoryItem> {
             get {
                 return builderResult.inventoryItems
             }
             set (value) {
                 builderResult.inventoryItems = value
             }
        }
        public func setInventoryItems(value:Array<ResponseEnvelop.InventoryItem>) -> ResponseEnvelop.InventoryDelta.Builder {
          self.inventoryItems = value
          return self
        }
        public func clearInventoryItems() -> ResponseEnvelop.InventoryDelta.Builder {
          builderResult.inventoryItems.removeAll(keepCapacity: false)
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.InventoryDelta.Builder {
          builderResult = ResponseEnvelop.InventoryDelta()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.InventoryDelta.Builder {
          return try ResponseEnvelop.InventoryDelta.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.InventoryDelta {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.InventoryDelta {
          let returnMe:ResponseEnvelop.InventoryDelta = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.InventoryDelta) throws -> ResponseEnvelop.InventoryDelta.Builder {
          if other == ResponseEnvelop.InventoryDelta() {
           return self
          }
          if other.hasOriginalTimestampMs {
               originalTimestampMs = other.originalTimestampMs
          }
          if other.hasNewTimestampMs {
               newTimestampMs = other.newTimestampMs
          }
          if !other.inventoryItems.isEmpty  {
             builderResult.inventoryItems += other.inventoryItems
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryDelta.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryDelta.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              originalTimestampMs = try input.readInt64()

            case 16 :
              newTimestampMs = try input.readInt64()

            case 26 :
              let subBuilder = ResponseEnvelop.InventoryItem.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              inventoryItems += [subBuilder.buildPartial()]

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class InventoryItem : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var modifiedTimestampMs:Int64 = Int64(0)

      public private(set) var hasModifiedTimestampMs:Bool = false
      public private(set) var deletedItemKey:Int64 = Int64(0)

      public private(set) var hasDeletedItemKey:Bool = false
      public private(set) var inventoryItemData:ResponseEnvelop.InventoryItemData!
      public private(set) var hasInventoryItemData:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasModifiedTimestampMs {
          try output.writeInt64(1, value:modifiedTimestampMs)
        }
        if hasDeletedItemKey {
          try output.writeInt64(2, value:deletedItemKey)
        }
        if hasInventoryItemData {
          try output.writeMessage(3, value:inventoryItemData)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasModifiedTimestampMs {
          serialize_size += modifiedTimestampMs.computeInt64Size(1)
        }
        if hasDeletedItemKey {
          serialize_size += deletedItemKey.computeInt64Size(2)
        }
        if hasInventoryItemData {
            if let varSizeinventoryItemData = inventoryItemData?.computeMessageSize(3) {
                serialize_size += varSizeinventoryItemData
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.InventoryItem> {
        var mergedArray = Array<ResponseEnvelop.InventoryItem>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryItem? {
        return try ResponseEnvelop.InventoryItem.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.InventoryItem {
        return try ResponseEnvelop.InventoryItem.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryItem {
        return try ResponseEnvelop.InventoryItem.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryItem {
        return try ResponseEnvelop.InventoryItem.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryItem {
        return try ResponseEnvelop.InventoryItem.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryItem {
        return try ResponseEnvelop.InventoryItem.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryItem {
        return try ResponseEnvelop.InventoryItem.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.InventoryItem.Builder {
        return ResponseEnvelop.InventoryItem.classBuilder() as! ResponseEnvelop.InventoryItem.Builder
      }
      public func getBuilder() -> ResponseEnvelop.InventoryItem.Builder {
        return classBuilder() as! ResponseEnvelop.InventoryItem.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryItem.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryItem.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.InventoryItem.Builder {
        return try ResponseEnvelop.InventoryItem.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.InventoryItem) throws -> ResponseEnvelop.InventoryItem.Builder {
        return try ResponseEnvelop.InventoryItem.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasModifiedTimestampMs {
          output += "\(indent) modifiedTimestampMs: \(modifiedTimestampMs) \n"
        }
        if hasDeletedItemKey {
          output += "\(indent) deletedItemKey: \(deletedItemKey) \n"
        }
        if hasInventoryItemData {
          output += "\(indent) inventoryItemData {\n"
          if let outDescInventoryItemData = inventoryItemData {
            output += try outDescInventoryItemData.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasModifiedTimestampMs {
                 hashCode = (hashCode &* 31) &+ modifiedTimestampMs.hashValue
              }
              if hasDeletedItemKey {
                 hashCode = (hashCode &* 31) &+ deletedItemKey.hashValue
              }
              if hasInventoryItemData {
                  if let hashValueinventoryItemData = inventoryItemData?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueinventoryItemData
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.InventoryItem"
      }
      override public func className() -> String {
          return "ResponseEnvelop.InventoryItem"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.InventoryItem.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.InventoryItem = ResponseEnvelop.InventoryItem()
        public func getMessage() -> ResponseEnvelop.InventoryItem {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasModifiedTimestampMs:Bool {
             get {
                  return builderResult.hasModifiedTimestampMs
             }
        }
        public var modifiedTimestampMs:Int64 {
             get {
                  return builderResult.modifiedTimestampMs
             }
             set (value) {
                 builderResult.hasModifiedTimestampMs = true
                 builderResult.modifiedTimestampMs = value
             }
        }
        public func setModifiedTimestampMs(value:Int64) -> ResponseEnvelop.InventoryItem.Builder {
          self.modifiedTimestampMs = value
          return self
        }
        public func clearModifiedTimestampMs() -> ResponseEnvelop.InventoryItem.Builder{
             builderResult.hasModifiedTimestampMs = false
             builderResult.modifiedTimestampMs = Int64(0)
             return self
        }
        public var hasDeletedItemKey:Bool {
             get {
                  return builderResult.hasDeletedItemKey
             }
        }
        public var deletedItemKey:Int64 {
             get {
                  return builderResult.deletedItemKey
             }
             set (value) {
                 builderResult.hasDeletedItemKey = true
                 builderResult.deletedItemKey = value
             }
        }
        public func setDeletedItemKey(value:Int64) -> ResponseEnvelop.InventoryItem.Builder {
          self.deletedItemKey = value
          return self
        }
        public func clearDeletedItemKey() -> ResponseEnvelop.InventoryItem.Builder{
             builderResult.hasDeletedItemKey = false
             builderResult.deletedItemKey = Int64(0)
             return self
        }
        public var hasInventoryItemData:Bool {
             get {
                 return builderResult.hasInventoryItemData
             }
        }
        public var inventoryItemData:ResponseEnvelop.InventoryItemData! {
             get {
                 if inventoryItemDataBuilder_ != nil {
                    builderResult.inventoryItemData = inventoryItemDataBuilder_.getMessage()
                 }
                 return builderResult.inventoryItemData
             }
             set (value) {
                 builderResult.hasInventoryItemData = true
                 builderResult.inventoryItemData = value
             }
        }
        private var inventoryItemDataBuilder_:ResponseEnvelop.InventoryItemData.Builder! {
             didSet {
                builderResult.hasInventoryItemData = true
             }
        }
        public func getInventoryItemDataBuilder() -> ResponseEnvelop.InventoryItemData.Builder {
          if inventoryItemDataBuilder_ == nil {
             inventoryItemDataBuilder_ = ResponseEnvelop.InventoryItemData.Builder()
             builderResult.inventoryItemData = inventoryItemDataBuilder_.getMessage()
             if inventoryItemData != nil {
                try! inventoryItemDataBuilder_.mergeFrom(inventoryItemData)
             }
          }
          return inventoryItemDataBuilder_
        }
        public func setInventoryItemData(value:ResponseEnvelop.InventoryItemData!) -> ResponseEnvelop.InventoryItem.Builder {
          self.inventoryItemData = value
          return self
        }
        public func mergeInventoryItemData(value:ResponseEnvelop.InventoryItemData) throws -> ResponseEnvelop.InventoryItem.Builder {
          if builderResult.hasInventoryItemData {
            builderResult.inventoryItemData = try ResponseEnvelop.InventoryItemData.builderWithPrototype(builderResult.inventoryItemData).mergeFrom(value).buildPartial()
          } else {
            builderResult.inventoryItemData = value
          }
          builderResult.hasInventoryItemData = true
          return self
        }
        public func clearInventoryItemData() -> ResponseEnvelop.InventoryItem.Builder {
          inventoryItemDataBuilder_ = nil
          builderResult.hasInventoryItemData = false
          builderResult.inventoryItemData = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.InventoryItem.Builder {
          builderResult = ResponseEnvelop.InventoryItem()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.InventoryItem.Builder {
          return try ResponseEnvelop.InventoryItem.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.InventoryItem {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.InventoryItem {
          let returnMe:ResponseEnvelop.InventoryItem = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.InventoryItem) throws -> ResponseEnvelop.InventoryItem.Builder {
          if other == ResponseEnvelop.InventoryItem() {
           return self
          }
          if other.hasModifiedTimestampMs {
               modifiedTimestampMs = other.modifiedTimestampMs
          }
          if other.hasDeletedItemKey {
               deletedItemKey = other.deletedItemKey
          }
          if (other.hasInventoryItemData) {
              try mergeInventoryItemData(other.inventoryItemData)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryItem.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryItem.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              modifiedTimestampMs = try input.readInt64()

            case 16 :
              deletedItemKey = try input.readInt64()

            case 26 :
              let subBuilder:ResponseEnvelop.InventoryItemData.Builder = ResponseEnvelop.InventoryItemData.Builder()
              if hasInventoryItemData {
                try subBuilder.mergeFrom(inventoryItemData)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              inventoryItemData = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class InventoryItemData : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var pokemon:ResponseEnvelop.PokemonData!
      public private(set) var hasPokemon:Bool = false
      public private(set) var item:ResponseEnvelop.Item!
      public private(set) var hasItem:Bool = false
      public private(set) var pokedexEntry:ResponseEnvelop.PokedexEntry!
      public private(set) var hasPokedexEntry:Bool = false
      public private(set) var playerStats:ResponseEnvelop.PlayerStats!
      public private(set) var hasPlayerStats:Bool = false
      public private(set) var playerCurrency:ResponseEnvelop.PlayerCurrency!
      public private(set) var hasPlayerCurrency:Bool = false
      public private(set) var playerCamera:ResponseEnvelop.PlayerCamera!
      public private(set) var hasPlayerCamera:Bool = false
      public private(set) var inventoryUpgrades:ResponseEnvelop.InventoryUpgrades!
      public private(set) var hasInventoryUpgrades:Bool = false
      public private(set) var appliedItems:ResponseEnvelop.AppliedItems!
      public private(set) var hasAppliedItems:Bool = false
      public private(set) var eggIncubators:ResponseEnvelop.EggIncubators!
      public private(set) var hasEggIncubators:Bool = false
      public private(set) var pokemonFamily:ResponseEnvelop.PokemonFamily!
      public private(set) var hasPokemonFamily:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasPokemon {
          try output.writeMessage(1, value:pokemon)
        }
        if hasItem {
          try output.writeMessage(2, value:item)
        }
        if hasPokedexEntry {
          try output.writeMessage(3, value:pokedexEntry)
        }
        if hasPlayerStats {
          try output.writeMessage(4, value:playerStats)
        }
        if hasPlayerCurrency {
          try output.writeMessage(5, value:playerCurrency)
        }
        if hasPlayerCamera {
          try output.writeMessage(6, value:playerCamera)
        }
        if hasInventoryUpgrades {
          try output.writeMessage(7, value:inventoryUpgrades)
        }
        if hasAppliedItems {
          try output.writeMessage(8, value:appliedItems)
        }
        if hasEggIncubators {
          try output.writeMessage(9, value:eggIncubators)
        }
        if hasPokemonFamily {
          try output.writeMessage(10, value:pokemonFamily)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPokemon {
            if let varSizepokemon = pokemon?.computeMessageSize(1) {
                serialize_size += varSizepokemon
            }
        }
        if hasItem {
            if let varSizeitem = item?.computeMessageSize(2) {
                serialize_size += varSizeitem
            }
        }
        if hasPokedexEntry {
            if let varSizepokedexEntry = pokedexEntry?.computeMessageSize(3) {
                serialize_size += varSizepokedexEntry
            }
        }
        if hasPlayerStats {
            if let varSizeplayerStats = playerStats?.computeMessageSize(4) {
                serialize_size += varSizeplayerStats
            }
        }
        if hasPlayerCurrency {
            if let varSizeplayerCurrency = playerCurrency?.computeMessageSize(5) {
                serialize_size += varSizeplayerCurrency
            }
        }
        if hasPlayerCamera {
            if let varSizeplayerCamera = playerCamera?.computeMessageSize(6) {
                serialize_size += varSizeplayerCamera
            }
        }
        if hasInventoryUpgrades {
            if let varSizeinventoryUpgrades = inventoryUpgrades?.computeMessageSize(7) {
                serialize_size += varSizeinventoryUpgrades
            }
        }
        if hasAppliedItems {
            if let varSizeappliedItems = appliedItems?.computeMessageSize(8) {
                serialize_size += varSizeappliedItems
            }
        }
        if hasEggIncubators {
            if let varSizeeggIncubators = eggIncubators?.computeMessageSize(9) {
                serialize_size += varSizeeggIncubators
            }
        }
        if hasPokemonFamily {
            if let varSizepokemonFamily = pokemonFamily?.computeMessageSize(10) {
                serialize_size += varSizepokemonFamily
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.InventoryItemData> {
        var mergedArray = Array<ResponseEnvelop.InventoryItemData>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryItemData? {
        return try ResponseEnvelop.InventoryItemData.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.InventoryItemData {
        return try ResponseEnvelop.InventoryItemData.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryItemData {
        return try ResponseEnvelop.InventoryItemData.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryItemData {
        return try ResponseEnvelop.InventoryItemData.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryItemData {
        return try ResponseEnvelop.InventoryItemData.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryItemData {
        return try ResponseEnvelop.InventoryItemData.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryItemData {
        return try ResponseEnvelop.InventoryItemData.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.InventoryItemData.Builder {
        return ResponseEnvelop.InventoryItemData.classBuilder() as! ResponseEnvelop.InventoryItemData.Builder
      }
      public func getBuilder() -> ResponseEnvelop.InventoryItemData.Builder {
        return classBuilder() as! ResponseEnvelop.InventoryItemData.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryItemData.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryItemData.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.InventoryItemData.Builder {
        return try ResponseEnvelop.InventoryItemData.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.InventoryItemData) throws -> ResponseEnvelop.InventoryItemData.Builder {
        return try ResponseEnvelop.InventoryItemData.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasPokemon {
          output += "\(indent) pokemon {\n"
          if let outDescPokemon = pokemon {
            output += try outDescPokemon.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasItem {
          output += "\(indent) item {\n"
          if let outDescItem = item {
            output += try outDescItem.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasPokedexEntry {
          output += "\(indent) pokedexEntry {\n"
          if let outDescPokedexEntry = pokedexEntry {
            output += try outDescPokedexEntry.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasPlayerStats {
          output += "\(indent) playerStats {\n"
          if let outDescPlayerStats = playerStats {
            output += try outDescPlayerStats.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasPlayerCurrency {
          output += "\(indent) playerCurrency {\n"
          if let outDescPlayerCurrency = playerCurrency {
            output += try outDescPlayerCurrency.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasPlayerCamera {
          output += "\(indent) playerCamera {\n"
          if let outDescPlayerCamera = playerCamera {
            output += try outDescPlayerCamera.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasInventoryUpgrades {
          output += "\(indent) inventoryUpgrades {\n"
          if let outDescInventoryUpgrades = inventoryUpgrades {
            output += try outDescInventoryUpgrades.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasAppliedItems {
          output += "\(indent) appliedItems {\n"
          if let outDescAppliedItems = appliedItems {
            output += try outDescAppliedItems.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasEggIncubators {
          output += "\(indent) eggIncubators {\n"
          if let outDescEggIncubators = eggIncubators {
            output += try outDescEggIncubators.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasPokemonFamily {
          output += "\(indent) pokemonFamily {\n"
          if let outDescPokemonFamily = pokemonFamily {
            output += try outDescPokemonFamily.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasPokemon {
                  if let hashValuepokemon = pokemon?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuepokemon
                  }
              }
              if hasItem {
                  if let hashValueitem = item?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueitem
                  }
              }
              if hasPokedexEntry {
                  if let hashValuepokedexEntry = pokedexEntry?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuepokedexEntry
                  }
              }
              if hasPlayerStats {
                  if let hashValueplayerStats = playerStats?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueplayerStats
                  }
              }
              if hasPlayerCurrency {
                  if let hashValueplayerCurrency = playerCurrency?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueplayerCurrency
                  }
              }
              if hasPlayerCamera {
                  if let hashValueplayerCamera = playerCamera?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueplayerCamera
                  }
              }
              if hasInventoryUpgrades {
                  if let hashValueinventoryUpgrades = inventoryUpgrades?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueinventoryUpgrades
                  }
              }
              if hasAppliedItems {
                  if let hashValueappliedItems = appliedItems?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueappliedItems
                  }
              }
              if hasEggIncubators {
                  if let hashValueeggIncubators = eggIncubators?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueeggIncubators
                  }
              }
              if hasPokemonFamily {
                  if let hashValuepokemonFamily = pokemonFamily?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuepokemonFamily
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.InventoryItemData"
      }
      override public func className() -> String {
          return "ResponseEnvelop.InventoryItemData"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.InventoryItemData.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.InventoryItemData = ResponseEnvelop.InventoryItemData()
        public func getMessage() -> ResponseEnvelop.InventoryItemData {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasPokemon:Bool {
             get {
                 return builderResult.hasPokemon
             }
        }
        public var pokemon:ResponseEnvelop.PokemonData! {
             get {
                 if pokemonBuilder_ != nil {
                    builderResult.pokemon = pokemonBuilder_.getMessage()
                 }
                 return builderResult.pokemon
             }
             set (value) {
                 builderResult.hasPokemon = true
                 builderResult.pokemon = value
             }
        }
        private var pokemonBuilder_:ResponseEnvelop.PokemonData.Builder! {
             didSet {
                builderResult.hasPokemon = true
             }
        }
        public func getPokemonBuilder() -> ResponseEnvelop.PokemonData.Builder {
          if pokemonBuilder_ == nil {
             pokemonBuilder_ = ResponseEnvelop.PokemonData.Builder()
             builderResult.pokemon = pokemonBuilder_.getMessage()
             if pokemon != nil {
                try! pokemonBuilder_.mergeFrom(pokemon)
             }
          }
          return pokemonBuilder_
        }
        public func setPokemon(value:ResponseEnvelop.PokemonData!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.pokemon = value
          return self
        }
        public func mergePokemon(value:ResponseEnvelop.PokemonData) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasPokemon {
            builderResult.pokemon = try ResponseEnvelop.PokemonData.builderWithPrototype(builderResult.pokemon).mergeFrom(value).buildPartial()
          } else {
            builderResult.pokemon = value
          }
          builderResult.hasPokemon = true
          return self
        }
        public func clearPokemon() -> ResponseEnvelop.InventoryItemData.Builder {
          pokemonBuilder_ = nil
          builderResult.hasPokemon = false
          builderResult.pokemon = nil
          return self
        }
        public var hasItem:Bool {
             get {
                 return builderResult.hasItem
             }
        }
        public var item:ResponseEnvelop.Item! {
             get {
                 if itemBuilder_ != nil {
                    builderResult.item = itemBuilder_.getMessage()
                 }
                 return builderResult.item
             }
             set (value) {
                 builderResult.hasItem = true
                 builderResult.item = value
             }
        }
        private var itemBuilder_:ResponseEnvelop.Item.Builder! {
             didSet {
                builderResult.hasItem = true
             }
        }
        public func getItemBuilder() -> ResponseEnvelop.Item.Builder {
          if itemBuilder_ == nil {
             itemBuilder_ = ResponseEnvelop.Item.Builder()
             builderResult.item = itemBuilder_.getMessage()
             if item != nil {
                try! itemBuilder_.mergeFrom(item)
             }
          }
          return itemBuilder_
        }
        public func setItem(value:ResponseEnvelop.Item!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.item = value
          return self
        }
        public func mergeItem(value:ResponseEnvelop.Item) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasItem {
            builderResult.item = try ResponseEnvelop.Item.builderWithPrototype(builderResult.item).mergeFrom(value).buildPartial()
          } else {
            builderResult.item = value
          }
          builderResult.hasItem = true
          return self
        }
        public func clearItem() -> ResponseEnvelop.InventoryItemData.Builder {
          itemBuilder_ = nil
          builderResult.hasItem = false
          builderResult.item = nil
          return self
        }
        public var hasPokedexEntry:Bool {
             get {
                 return builderResult.hasPokedexEntry
             }
        }
        public var pokedexEntry:ResponseEnvelop.PokedexEntry! {
             get {
                 if pokedexEntryBuilder_ != nil {
                    builderResult.pokedexEntry = pokedexEntryBuilder_.getMessage()
                 }
                 return builderResult.pokedexEntry
             }
             set (value) {
                 builderResult.hasPokedexEntry = true
                 builderResult.pokedexEntry = value
             }
        }
        private var pokedexEntryBuilder_:ResponseEnvelop.PokedexEntry.Builder! {
             didSet {
                builderResult.hasPokedexEntry = true
             }
        }
        public func getPokedexEntryBuilder() -> ResponseEnvelop.PokedexEntry.Builder {
          if pokedexEntryBuilder_ == nil {
             pokedexEntryBuilder_ = ResponseEnvelop.PokedexEntry.Builder()
             builderResult.pokedexEntry = pokedexEntryBuilder_.getMessage()
             if pokedexEntry != nil {
                try! pokedexEntryBuilder_.mergeFrom(pokedexEntry)
             }
          }
          return pokedexEntryBuilder_
        }
        public func setPokedexEntry(value:ResponseEnvelop.PokedexEntry!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.pokedexEntry = value
          return self
        }
        public func mergePokedexEntry(value:ResponseEnvelop.PokedexEntry) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasPokedexEntry {
            builderResult.pokedexEntry = try ResponseEnvelop.PokedexEntry.builderWithPrototype(builderResult.pokedexEntry).mergeFrom(value).buildPartial()
          } else {
            builderResult.pokedexEntry = value
          }
          builderResult.hasPokedexEntry = true
          return self
        }
        public func clearPokedexEntry() -> ResponseEnvelop.InventoryItemData.Builder {
          pokedexEntryBuilder_ = nil
          builderResult.hasPokedexEntry = false
          builderResult.pokedexEntry = nil
          return self
        }
        public var hasPlayerStats:Bool {
             get {
                 return builderResult.hasPlayerStats
             }
        }
        public var playerStats:ResponseEnvelop.PlayerStats! {
             get {
                 if playerStatsBuilder_ != nil {
                    builderResult.playerStats = playerStatsBuilder_.getMessage()
                 }
                 return builderResult.playerStats
             }
             set (value) {
                 builderResult.hasPlayerStats = true
                 builderResult.playerStats = value
             }
        }
        private var playerStatsBuilder_:ResponseEnvelop.PlayerStats.Builder! {
             didSet {
                builderResult.hasPlayerStats = true
             }
        }
        public func getPlayerStatsBuilder() -> ResponseEnvelop.PlayerStats.Builder {
          if playerStatsBuilder_ == nil {
             playerStatsBuilder_ = ResponseEnvelop.PlayerStats.Builder()
             builderResult.playerStats = playerStatsBuilder_.getMessage()
             if playerStats != nil {
                try! playerStatsBuilder_.mergeFrom(playerStats)
             }
          }
          return playerStatsBuilder_
        }
        public func setPlayerStats(value:ResponseEnvelop.PlayerStats!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.playerStats = value
          return self
        }
        public func mergePlayerStats(value:ResponseEnvelop.PlayerStats) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasPlayerStats {
            builderResult.playerStats = try ResponseEnvelop.PlayerStats.builderWithPrototype(builderResult.playerStats).mergeFrom(value).buildPartial()
          } else {
            builderResult.playerStats = value
          }
          builderResult.hasPlayerStats = true
          return self
        }
        public func clearPlayerStats() -> ResponseEnvelop.InventoryItemData.Builder {
          playerStatsBuilder_ = nil
          builderResult.hasPlayerStats = false
          builderResult.playerStats = nil
          return self
        }
        public var hasPlayerCurrency:Bool {
             get {
                 return builderResult.hasPlayerCurrency
             }
        }
        public var playerCurrency:ResponseEnvelop.PlayerCurrency! {
             get {
                 if playerCurrencyBuilder_ != nil {
                    builderResult.playerCurrency = playerCurrencyBuilder_.getMessage()
                 }
                 return builderResult.playerCurrency
             }
             set (value) {
                 builderResult.hasPlayerCurrency = true
                 builderResult.playerCurrency = value
             }
        }
        private var playerCurrencyBuilder_:ResponseEnvelop.PlayerCurrency.Builder! {
             didSet {
                builderResult.hasPlayerCurrency = true
             }
        }
        public func getPlayerCurrencyBuilder() -> ResponseEnvelop.PlayerCurrency.Builder {
          if playerCurrencyBuilder_ == nil {
             playerCurrencyBuilder_ = ResponseEnvelop.PlayerCurrency.Builder()
             builderResult.playerCurrency = playerCurrencyBuilder_.getMessage()
             if playerCurrency != nil {
                try! playerCurrencyBuilder_.mergeFrom(playerCurrency)
             }
          }
          return playerCurrencyBuilder_
        }
        public func setPlayerCurrency(value:ResponseEnvelop.PlayerCurrency!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.playerCurrency = value
          return self
        }
        public func mergePlayerCurrency(value:ResponseEnvelop.PlayerCurrency) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasPlayerCurrency {
            builderResult.playerCurrency = try ResponseEnvelop.PlayerCurrency.builderWithPrototype(builderResult.playerCurrency).mergeFrom(value).buildPartial()
          } else {
            builderResult.playerCurrency = value
          }
          builderResult.hasPlayerCurrency = true
          return self
        }
        public func clearPlayerCurrency() -> ResponseEnvelop.InventoryItemData.Builder {
          playerCurrencyBuilder_ = nil
          builderResult.hasPlayerCurrency = false
          builderResult.playerCurrency = nil
          return self
        }
        public var hasPlayerCamera:Bool {
             get {
                 return builderResult.hasPlayerCamera
             }
        }
        public var playerCamera:ResponseEnvelop.PlayerCamera! {
             get {
                 if playerCameraBuilder_ != nil {
                    builderResult.playerCamera = playerCameraBuilder_.getMessage()
                 }
                 return builderResult.playerCamera
             }
             set (value) {
                 builderResult.hasPlayerCamera = true
                 builderResult.playerCamera = value
             }
        }
        private var playerCameraBuilder_:ResponseEnvelop.PlayerCamera.Builder! {
             didSet {
                builderResult.hasPlayerCamera = true
             }
        }
        public func getPlayerCameraBuilder() -> ResponseEnvelop.PlayerCamera.Builder {
          if playerCameraBuilder_ == nil {
             playerCameraBuilder_ = ResponseEnvelop.PlayerCamera.Builder()
             builderResult.playerCamera = playerCameraBuilder_.getMessage()
             if playerCamera != nil {
                try! playerCameraBuilder_.mergeFrom(playerCamera)
             }
          }
          return playerCameraBuilder_
        }
        public func setPlayerCamera(value:ResponseEnvelop.PlayerCamera!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.playerCamera = value
          return self
        }
        public func mergePlayerCamera(value:ResponseEnvelop.PlayerCamera) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasPlayerCamera {
            builderResult.playerCamera = try ResponseEnvelop.PlayerCamera.builderWithPrototype(builderResult.playerCamera).mergeFrom(value).buildPartial()
          } else {
            builderResult.playerCamera = value
          }
          builderResult.hasPlayerCamera = true
          return self
        }
        public func clearPlayerCamera() -> ResponseEnvelop.InventoryItemData.Builder {
          playerCameraBuilder_ = nil
          builderResult.hasPlayerCamera = false
          builderResult.playerCamera = nil
          return self
        }
        public var hasInventoryUpgrades:Bool {
             get {
                 return builderResult.hasInventoryUpgrades
             }
        }
        public var inventoryUpgrades:ResponseEnvelop.InventoryUpgrades! {
             get {
                 if inventoryUpgradesBuilder_ != nil {
                    builderResult.inventoryUpgrades = inventoryUpgradesBuilder_.getMessage()
                 }
                 return builderResult.inventoryUpgrades
             }
             set (value) {
                 builderResult.hasInventoryUpgrades = true
                 builderResult.inventoryUpgrades = value
             }
        }
        private var inventoryUpgradesBuilder_:ResponseEnvelop.InventoryUpgrades.Builder! {
             didSet {
                builderResult.hasInventoryUpgrades = true
             }
        }
        public func getInventoryUpgradesBuilder() -> ResponseEnvelop.InventoryUpgrades.Builder {
          if inventoryUpgradesBuilder_ == nil {
             inventoryUpgradesBuilder_ = ResponseEnvelop.InventoryUpgrades.Builder()
             builderResult.inventoryUpgrades = inventoryUpgradesBuilder_.getMessage()
             if inventoryUpgrades != nil {
                try! inventoryUpgradesBuilder_.mergeFrom(inventoryUpgrades)
             }
          }
          return inventoryUpgradesBuilder_
        }
        public func setInventoryUpgrades(value:ResponseEnvelop.InventoryUpgrades!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.inventoryUpgrades = value
          return self
        }
        public func mergeInventoryUpgrades(value:ResponseEnvelop.InventoryUpgrades) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasInventoryUpgrades {
            builderResult.inventoryUpgrades = try ResponseEnvelop.InventoryUpgrades.builderWithPrototype(builderResult.inventoryUpgrades).mergeFrom(value).buildPartial()
          } else {
            builderResult.inventoryUpgrades = value
          }
          builderResult.hasInventoryUpgrades = true
          return self
        }
        public func clearInventoryUpgrades() -> ResponseEnvelop.InventoryItemData.Builder {
          inventoryUpgradesBuilder_ = nil
          builderResult.hasInventoryUpgrades = false
          builderResult.inventoryUpgrades = nil
          return self
        }
        public var hasAppliedItems:Bool {
             get {
                 return builderResult.hasAppliedItems
             }
        }
        public var appliedItems:ResponseEnvelop.AppliedItems! {
             get {
                 if appliedItemsBuilder_ != nil {
                    builderResult.appliedItems = appliedItemsBuilder_.getMessage()
                 }
                 return builderResult.appliedItems
             }
             set (value) {
                 builderResult.hasAppliedItems = true
                 builderResult.appliedItems = value
             }
        }
        private var appliedItemsBuilder_:ResponseEnvelop.AppliedItems.Builder! {
             didSet {
                builderResult.hasAppliedItems = true
             }
        }
        public func getAppliedItemsBuilder() -> ResponseEnvelop.AppliedItems.Builder {
          if appliedItemsBuilder_ == nil {
             appliedItemsBuilder_ = ResponseEnvelop.AppliedItems.Builder()
             builderResult.appliedItems = appliedItemsBuilder_.getMessage()
             if appliedItems != nil {
                try! appliedItemsBuilder_.mergeFrom(appliedItems)
             }
          }
          return appliedItemsBuilder_
        }
        public func setAppliedItems(value:ResponseEnvelop.AppliedItems!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.appliedItems = value
          return self
        }
        public func mergeAppliedItems(value:ResponseEnvelop.AppliedItems) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasAppliedItems {
            builderResult.appliedItems = try ResponseEnvelop.AppliedItems.builderWithPrototype(builderResult.appliedItems).mergeFrom(value).buildPartial()
          } else {
            builderResult.appliedItems = value
          }
          builderResult.hasAppliedItems = true
          return self
        }
        public func clearAppliedItems() -> ResponseEnvelop.InventoryItemData.Builder {
          appliedItemsBuilder_ = nil
          builderResult.hasAppliedItems = false
          builderResult.appliedItems = nil
          return self
        }
        public var hasEggIncubators:Bool {
             get {
                 return builderResult.hasEggIncubators
             }
        }
        public var eggIncubators:ResponseEnvelop.EggIncubators! {
             get {
                 if eggIncubatorsBuilder_ != nil {
                    builderResult.eggIncubators = eggIncubatorsBuilder_.getMessage()
                 }
                 return builderResult.eggIncubators
             }
             set (value) {
                 builderResult.hasEggIncubators = true
                 builderResult.eggIncubators = value
             }
        }
        private var eggIncubatorsBuilder_:ResponseEnvelop.EggIncubators.Builder! {
             didSet {
                builderResult.hasEggIncubators = true
             }
        }
        public func getEggIncubatorsBuilder() -> ResponseEnvelop.EggIncubators.Builder {
          if eggIncubatorsBuilder_ == nil {
             eggIncubatorsBuilder_ = ResponseEnvelop.EggIncubators.Builder()
             builderResult.eggIncubators = eggIncubatorsBuilder_.getMessage()
             if eggIncubators != nil {
                try! eggIncubatorsBuilder_.mergeFrom(eggIncubators)
             }
          }
          return eggIncubatorsBuilder_
        }
        public func setEggIncubators(value:ResponseEnvelop.EggIncubators!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.eggIncubators = value
          return self
        }
        public func mergeEggIncubators(value:ResponseEnvelop.EggIncubators) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasEggIncubators {
            builderResult.eggIncubators = try ResponseEnvelop.EggIncubators.builderWithPrototype(builderResult.eggIncubators).mergeFrom(value).buildPartial()
          } else {
            builderResult.eggIncubators = value
          }
          builderResult.hasEggIncubators = true
          return self
        }
        public func clearEggIncubators() -> ResponseEnvelop.InventoryItemData.Builder {
          eggIncubatorsBuilder_ = nil
          builderResult.hasEggIncubators = false
          builderResult.eggIncubators = nil
          return self
        }
        public var hasPokemonFamily:Bool {
             get {
                 return builderResult.hasPokemonFamily
             }
        }
        public var pokemonFamily:ResponseEnvelop.PokemonFamily! {
             get {
                 if pokemonFamilyBuilder_ != nil {
                    builderResult.pokemonFamily = pokemonFamilyBuilder_.getMessage()
                 }
                 return builderResult.pokemonFamily
             }
             set (value) {
                 builderResult.hasPokemonFamily = true
                 builderResult.pokemonFamily = value
             }
        }
        private var pokemonFamilyBuilder_:ResponseEnvelop.PokemonFamily.Builder! {
             didSet {
                builderResult.hasPokemonFamily = true
             }
        }
        public func getPokemonFamilyBuilder() -> ResponseEnvelop.PokemonFamily.Builder {
          if pokemonFamilyBuilder_ == nil {
             pokemonFamilyBuilder_ = ResponseEnvelop.PokemonFamily.Builder()
             builderResult.pokemonFamily = pokemonFamilyBuilder_.getMessage()
             if pokemonFamily != nil {
                try! pokemonFamilyBuilder_.mergeFrom(pokemonFamily)
             }
          }
          return pokemonFamilyBuilder_
        }
        public func setPokemonFamily(value:ResponseEnvelop.PokemonFamily!) -> ResponseEnvelop.InventoryItemData.Builder {
          self.pokemonFamily = value
          return self
        }
        public func mergePokemonFamily(value:ResponseEnvelop.PokemonFamily) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if builderResult.hasPokemonFamily {
            builderResult.pokemonFamily = try ResponseEnvelop.PokemonFamily.builderWithPrototype(builderResult.pokemonFamily).mergeFrom(value).buildPartial()
          } else {
            builderResult.pokemonFamily = value
          }
          builderResult.hasPokemonFamily = true
          return self
        }
        public func clearPokemonFamily() -> ResponseEnvelop.InventoryItemData.Builder {
          pokemonFamilyBuilder_ = nil
          builderResult.hasPokemonFamily = false
          builderResult.pokemonFamily = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.InventoryItemData.Builder {
          builderResult = ResponseEnvelop.InventoryItemData()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.InventoryItemData.Builder {
          return try ResponseEnvelop.InventoryItemData.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.InventoryItemData {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.InventoryItemData {
          let returnMe:ResponseEnvelop.InventoryItemData = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.InventoryItemData) throws -> ResponseEnvelop.InventoryItemData.Builder {
          if other == ResponseEnvelop.InventoryItemData() {
           return self
          }
          if (other.hasPokemon) {
              try mergePokemon(other.pokemon)
          }
          if (other.hasItem) {
              try mergeItem(other.item)
          }
          if (other.hasPokedexEntry) {
              try mergePokedexEntry(other.pokedexEntry)
          }
          if (other.hasPlayerStats) {
              try mergePlayerStats(other.playerStats)
          }
          if (other.hasPlayerCurrency) {
              try mergePlayerCurrency(other.playerCurrency)
          }
          if (other.hasPlayerCamera) {
              try mergePlayerCamera(other.playerCamera)
          }
          if (other.hasInventoryUpgrades) {
              try mergeInventoryUpgrades(other.inventoryUpgrades)
          }
          if (other.hasAppliedItems) {
              try mergeAppliedItems(other.appliedItems)
          }
          if (other.hasEggIncubators) {
              try mergeEggIncubators(other.eggIncubators)
          }
          if (other.hasPokemonFamily) {
              try mergePokemonFamily(other.pokemonFamily)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryItemData.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryItemData.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              let subBuilder:ResponseEnvelop.PokemonData.Builder = ResponseEnvelop.PokemonData.Builder()
              if hasPokemon {
                try subBuilder.mergeFrom(pokemon)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              pokemon = subBuilder.buildPartial()

            case 18 :
              let subBuilder:ResponseEnvelop.Item.Builder = ResponseEnvelop.Item.Builder()
              if hasItem {
                try subBuilder.mergeFrom(item)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              item = subBuilder.buildPartial()

            case 26 :
              let subBuilder:ResponseEnvelop.PokedexEntry.Builder = ResponseEnvelop.PokedexEntry.Builder()
              if hasPokedexEntry {
                try subBuilder.mergeFrom(pokedexEntry)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              pokedexEntry = subBuilder.buildPartial()

            case 34 :
              let subBuilder:ResponseEnvelop.PlayerStats.Builder = ResponseEnvelop.PlayerStats.Builder()
              if hasPlayerStats {
                try subBuilder.mergeFrom(playerStats)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              playerStats = subBuilder.buildPartial()

            case 42 :
              let subBuilder:ResponseEnvelop.PlayerCurrency.Builder = ResponseEnvelop.PlayerCurrency.Builder()
              if hasPlayerCurrency {
                try subBuilder.mergeFrom(playerCurrency)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              playerCurrency = subBuilder.buildPartial()

            case 50 :
              let subBuilder:ResponseEnvelop.PlayerCamera.Builder = ResponseEnvelop.PlayerCamera.Builder()
              if hasPlayerCamera {
                try subBuilder.mergeFrom(playerCamera)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              playerCamera = subBuilder.buildPartial()

            case 58 :
              let subBuilder:ResponseEnvelop.InventoryUpgrades.Builder = ResponseEnvelop.InventoryUpgrades.Builder()
              if hasInventoryUpgrades {
                try subBuilder.mergeFrom(inventoryUpgrades)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              inventoryUpgrades = subBuilder.buildPartial()

            case 66 :
              let subBuilder:ResponseEnvelop.AppliedItems.Builder = ResponseEnvelop.AppliedItems.Builder()
              if hasAppliedItems {
                try subBuilder.mergeFrom(appliedItems)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              appliedItems = subBuilder.buildPartial()

            case 74 :
              let subBuilder:ResponseEnvelop.EggIncubators.Builder = ResponseEnvelop.EggIncubators.Builder()
              if hasEggIncubators {
                try subBuilder.mergeFrom(eggIncubators)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              eggIncubators = subBuilder.buildPartial()

            case 82 :
              let subBuilder:ResponseEnvelop.PokemonFamily.Builder = ResponseEnvelop.PokemonFamily.Builder()
              if hasPokemonFamily {
                try subBuilder.mergeFrom(pokemonFamily)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              pokemonFamily = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class PokemonData : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var id:UInt64 = UInt64(0)

      public private(set) var hasId:Bool = false
      public private(set) var pokemonId:ResponseEnvelop.PokemonId = ResponseEnvelop.PokemonId.Missingno
      public private(set) var hasPokemonId:Bool = false
      public private(set) var cp:Int32 = Int32(0)

      public private(set) var hasCp:Bool = false
      public private(set) var stamina:Int32 = Int32(0)

      public private(set) var hasStamina:Bool = false
      public private(set) var staminaMax:Int32 = Int32(0)

      public private(set) var hasStaminaMax:Bool = false
      public private(set) var move1:ResponseEnvelop.PokemonMove = ResponseEnvelop.PokemonMove.MoveUnset
      public private(set) var hasMove1:Bool = false
      public private(set) var move2:ResponseEnvelop.PokemonMove = ResponseEnvelop.PokemonMove.MoveUnset
      public private(set) var hasMove2:Bool = false
      public private(set) var deployedFortId:String = ""

      public private(set) var hasDeployedFortId:Bool = false
      public private(set) var ownerName:String = ""

      public private(set) var hasOwnerName:Bool = false
      public private(set) var isEgg:Bool = false

      public private(set) var hasIsEgg:Bool = false
      public private(set) var eggKmWalkedTarget:Double = Double(0)

      public private(set) var hasEggKmWalkedTarget:Bool = false
      public private(set) var eggKmWalkedStart:Double = Double(0)

      public private(set) var hasEggKmWalkedStart:Bool = false
      public private(set) var origin:Int32 = Int32(0)

      public private(set) var hasOrigin:Bool = false
      public private(set) var heightM:Float = Float(0)

      public private(set) var hasHeightM:Bool = false
      public private(set) var weightKg:Float = Float(0)

      public private(set) var hasWeightKg:Bool = false
      public private(set) var individualAttack:Int32 = Int32(0)

      public private(set) var hasIndividualAttack:Bool = false
      public private(set) var individualDefense:Int32 = Int32(0)

      public private(set) var hasIndividualDefense:Bool = false
      public private(set) var individualStamina:Int32 = Int32(0)

      public private(set) var hasIndividualStamina:Bool = false
      public private(set) var cpMultiplier:Float = Float(0)

      public private(set) var hasCpMultiplier:Bool = false
      public private(set) var pokeball:ResponseEnvelop.ItemId = ResponseEnvelop.ItemId.ItemUnknown
      public private(set) var hasPokeball:Bool = false
      public private(set) var capturedCellId:UInt64 = UInt64(0)

      public private(set) var hasCapturedCellId:Bool = false
      public private(set) var battlesAttacked:Int32 = Int32(0)

      public private(set) var hasBattlesAttacked:Bool = false
      public private(set) var battlesDefended:Int32 = Int32(0)

      public private(set) var hasBattlesDefended:Bool = false
      public private(set) var eggIncubatorId:String = ""

      public private(set) var hasEggIncubatorId:Bool = false
      public private(set) var creationTimeMs:UInt64 = UInt64(0)

      public private(set) var hasCreationTimeMs:Bool = false
      public private(set) var numUpgrades:Int32 = Int32(0)

      public private(set) var hasNumUpgrades:Bool = false
      public private(set) var additionalCpMultiplier:Float = Float(0)

      public private(set) var hasAdditionalCpMultiplier:Bool = false
      public private(set) var favorite:Int32 = Int32(0)

      public private(set) var hasFavorite:Bool = false
      public private(set) var nickname:String = ""

      public private(set) var hasNickname:Bool = false
      public private(set) var fromFort:Int32 = Int32(0)

      public private(set) var hasFromFort:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasId {
          try output.writeFixed64(1, value:id)
        }
        if hasPokemonId {
          try output.writeEnum(2, value:pokemonId.rawValue)
        }
        if hasCp {
          try output.writeInt32(3, value:cp)
        }
        if hasStamina {
          try output.writeInt32(4, value:stamina)
        }
        if hasStaminaMax {
          try output.writeInt32(5, value:staminaMax)
        }
        if hasMove1 {
          try output.writeEnum(6, value:move1.rawValue)
        }
        if hasMove2 {
          try output.writeEnum(7, value:move2.rawValue)
        }
        if hasDeployedFortId {
          try output.writeString(8, value:deployedFortId)
        }
        if hasOwnerName {
          try output.writeString(9, value:ownerName)
        }
        if hasIsEgg {
          try output.writeBool(10, value:isEgg)
        }
        if hasEggKmWalkedTarget {
          try output.writeDouble(11, value:eggKmWalkedTarget)
        }
        if hasEggKmWalkedStart {
          try output.writeDouble(12, value:eggKmWalkedStart)
        }
        if hasOrigin {
          try output.writeInt32(14, value:origin)
        }
        if hasHeightM {
          try output.writeFloat(15, value:heightM)
        }
        if hasWeightKg {
          try output.writeFloat(16, value:weightKg)
        }
        if hasIndividualAttack {
          try output.writeInt32(17, value:individualAttack)
        }
        if hasIndividualDefense {
          try output.writeInt32(18, value:individualDefense)
        }
        if hasIndividualStamina {
          try output.writeInt32(19, value:individualStamina)
        }
        if hasCpMultiplier {
          try output.writeFloat(20, value:cpMultiplier)
        }
        if hasPokeball {
          try output.writeEnum(21, value:pokeball.rawValue)
        }
        if hasCapturedCellId {
          try output.writeUInt64(22, value:capturedCellId)
        }
        if hasBattlesAttacked {
          try output.writeInt32(23, value:battlesAttacked)
        }
        if hasBattlesDefended {
          try output.writeInt32(24, value:battlesDefended)
        }
        if hasEggIncubatorId {
          try output.writeString(25, value:eggIncubatorId)
        }
        if hasCreationTimeMs {
          try output.writeUInt64(26, value:creationTimeMs)
        }
        if hasNumUpgrades {
          try output.writeInt32(27, value:numUpgrades)
        }
        if hasAdditionalCpMultiplier {
          try output.writeFloat(28, value:additionalCpMultiplier)
        }
        if hasFavorite {
          try output.writeInt32(29, value:favorite)
        }
        if hasNickname {
          try output.writeString(30, value:nickname)
        }
        if hasFromFort {
          try output.writeInt32(31, value:fromFort)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
          serialize_size += id.computeFixed64Size(1)
        }
        if (hasPokemonId) {
          serialize_size += pokemonId.rawValue.computeEnumSize(2)
        }
        if hasCp {
          serialize_size += cp.computeInt32Size(3)
        }
        if hasStamina {
          serialize_size += stamina.computeInt32Size(4)
        }
        if hasStaminaMax {
          serialize_size += staminaMax.computeInt32Size(5)
        }
        if (hasMove1) {
          serialize_size += move1.rawValue.computeEnumSize(6)
        }
        if (hasMove2) {
          serialize_size += move2.rawValue.computeEnumSize(7)
        }
        if hasDeployedFortId {
          serialize_size += deployedFortId.computeStringSize(8)
        }
        if hasOwnerName {
          serialize_size += ownerName.computeStringSize(9)
        }
        if hasIsEgg {
          serialize_size += isEgg.computeBoolSize(10)
        }
        if hasEggKmWalkedTarget {
          serialize_size += eggKmWalkedTarget.computeDoubleSize(11)
        }
        if hasEggKmWalkedStart {
          serialize_size += eggKmWalkedStart.computeDoubleSize(12)
        }
        if hasOrigin {
          serialize_size += origin.computeInt32Size(14)
        }
        if hasHeightM {
          serialize_size += heightM.computeFloatSize(15)
        }
        if hasWeightKg {
          serialize_size += weightKg.computeFloatSize(16)
        }
        if hasIndividualAttack {
          serialize_size += individualAttack.computeInt32Size(17)
        }
        if hasIndividualDefense {
          serialize_size += individualDefense.computeInt32Size(18)
        }
        if hasIndividualStamina {
          serialize_size += individualStamina.computeInt32Size(19)
        }
        if hasCpMultiplier {
          serialize_size += cpMultiplier.computeFloatSize(20)
        }
        if (hasPokeball) {
          serialize_size += pokeball.rawValue.computeEnumSize(21)
        }
        if hasCapturedCellId {
          serialize_size += capturedCellId.computeUInt64Size(22)
        }
        if hasBattlesAttacked {
          serialize_size += battlesAttacked.computeInt32Size(23)
        }
        if hasBattlesDefended {
          serialize_size += battlesDefended.computeInt32Size(24)
        }
        if hasEggIncubatorId {
          serialize_size += eggIncubatorId.computeStringSize(25)
        }
        if hasCreationTimeMs {
          serialize_size += creationTimeMs.computeUInt64Size(26)
        }
        if hasNumUpgrades {
          serialize_size += numUpgrades.computeInt32Size(27)
        }
        if hasAdditionalCpMultiplier {
          serialize_size += additionalCpMultiplier.computeFloatSize(28)
        }
        if hasFavorite {
          serialize_size += favorite.computeInt32Size(29)
        }
        if hasNickname {
          serialize_size += nickname.computeStringSize(30)
        }
        if hasFromFort {
          serialize_size += fromFort.computeInt32Size(31)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.PokemonData> {
        var mergedArray = Array<ResponseEnvelop.PokemonData>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokemonData? {
        return try ResponseEnvelop.PokemonData.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.PokemonData {
        return try ResponseEnvelop.PokemonData.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonData {
        return try ResponseEnvelop.PokemonData.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokemonData {
        return try ResponseEnvelop.PokemonData.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonData {
        return try ResponseEnvelop.PokemonData.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokemonData {
        return try ResponseEnvelop.PokemonData.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonData {
        return try ResponseEnvelop.PokemonData.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.PokemonData.Builder {
        return ResponseEnvelop.PokemonData.classBuilder() as! ResponseEnvelop.PokemonData.Builder
      }
      public func getBuilder() -> ResponseEnvelop.PokemonData.Builder {
        return classBuilder() as! ResponseEnvelop.PokemonData.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokemonData.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokemonData.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.PokemonData.Builder {
        return try ResponseEnvelop.PokemonData.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.PokemonData) throws -> ResponseEnvelop.PokemonData.Builder {
        return try ResponseEnvelop.PokemonData.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasId {
          output += "\(indent) id: \(id) \n"
        }
        if (hasPokemonId) {
          output += "\(indent) pokemonId: \(pokemonId.description)\n"
        }
        if hasCp {
          output += "\(indent) cp: \(cp) \n"
        }
        if hasStamina {
          output += "\(indent) stamina: \(stamina) \n"
        }
        if hasStaminaMax {
          output += "\(indent) staminaMax: \(staminaMax) \n"
        }
        if (hasMove1) {
          output += "\(indent) move1: \(move1.description)\n"
        }
        if (hasMove2) {
          output += "\(indent) move2: \(move2.description)\n"
        }
        if hasDeployedFortId {
          output += "\(indent) deployedFortId: \(deployedFortId) \n"
        }
        if hasOwnerName {
          output += "\(indent) ownerName: \(ownerName) \n"
        }
        if hasIsEgg {
          output += "\(indent) isEgg: \(isEgg) \n"
        }
        if hasEggKmWalkedTarget {
          output += "\(indent) eggKmWalkedTarget: \(eggKmWalkedTarget) \n"
        }
        if hasEggKmWalkedStart {
          output += "\(indent) eggKmWalkedStart: \(eggKmWalkedStart) \n"
        }
        if hasOrigin {
          output += "\(indent) origin: \(origin) \n"
        }
        if hasHeightM {
          output += "\(indent) heightM: \(heightM) \n"
        }
        if hasWeightKg {
          output += "\(indent) weightKg: \(weightKg) \n"
        }
        if hasIndividualAttack {
          output += "\(indent) individualAttack: \(individualAttack) \n"
        }
        if hasIndividualDefense {
          output += "\(indent) individualDefense: \(individualDefense) \n"
        }
        if hasIndividualStamina {
          output += "\(indent) individualStamina: \(individualStamina) \n"
        }
        if hasCpMultiplier {
          output += "\(indent) cpMultiplier: \(cpMultiplier) \n"
        }
        if (hasPokeball) {
          output += "\(indent) pokeball: \(pokeball.description)\n"
        }
        if hasCapturedCellId {
          output += "\(indent) capturedCellId: \(capturedCellId) \n"
        }
        if hasBattlesAttacked {
          output += "\(indent) battlesAttacked: \(battlesAttacked) \n"
        }
        if hasBattlesDefended {
          output += "\(indent) battlesDefended: \(battlesDefended) \n"
        }
        if hasEggIncubatorId {
          output += "\(indent) eggIncubatorId: \(eggIncubatorId) \n"
        }
        if hasCreationTimeMs {
          output += "\(indent) creationTimeMs: \(creationTimeMs) \n"
        }
        if hasNumUpgrades {
          output += "\(indent) numUpgrades: \(numUpgrades) \n"
        }
        if hasAdditionalCpMultiplier {
          output += "\(indent) additionalCpMultiplier: \(additionalCpMultiplier) \n"
        }
        if hasFavorite {
          output += "\(indent) favorite: \(favorite) \n"
        }
        if hasNickname {
          output += "\(indent) nickname: \(nickname) \n"
        }
        if hasFromFort {
          output += "\(indent) fromFort: \(fromFort) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasId {
                 hashCode = (hashCode &* 31) &+ id.hashValue
              }
              if hasPokemonId {
                 hashCode = (hashCode &* 31) &+ Int(pokemonId.rawValue)
              }
              if hasCp {
                 hashCode = (hashCode &* 31) &+ cp.hashValue
              }
              if hasStamina {
                 hashCode = (hashCode &* 31) &+ stamina.hashValue
              }
              if hasStaminaMax {
                 hashCode = (hashCode &* 31) &+ staminaMax.hashValue
              }
              if hasMove1 {
                 hashCode = (hashCode &* 31) &+ Int(move1.rawValue)
              }
              if hasMove2 {
                 hashCode = (hashCode &* 31) &+ Int(move2.rawValue)
              }
              if hasDeployedFortId {
                 hashCode = (hashCode &* 31) &+ deployedFortId.hashValue
              }
              if hasOwnerName {
                 hashCode = (hashCode &* 31) &+ ownerName.hashValue
              }
              if hasIsEgg {
                 hashCode = (hashCode &* 31) &+ isEgg.hashValue
              }
              if hasEggKmWalkedTarget {
                 hashCode = (hashCode &* 31) &+ eggKmWalkedTarget.hashValue
              }
              if hasEggKmWalkedStart {
                 hashCode = (hashCode &* 31) &+ eggKmWalkedStart.hashValue
              }
              if hasOrigin {
                 hashCode = (hashCode &* 31) &+ origin.hashValue
              }
              if hasHeightM {
                 hashCode = (hashCode &* 31) &+ heightM.hashValue
              }
              if hasWeightKg {
                 hashCode = (hashCode &* 31) &+ weightKg.hashValue
              }
              if hasIndividualAttack {
                 hashCode = (hashCode &* 31) &+ individualAttack.hashValue
              }
              if hasIndividualDefense {
                 hashCode = (hashCode &* 31) &+ individualDefense.hashValue
              }
              if hasIndividualStamina {
                 hashCode = (hashCode &* 31) &+ individualStamina.hashValue
              }
              if hasCpMultiplier {
                 hashCode = (hashCode &* 31) &+ cpMultiplier.hashValue
              }
              if hasPokeball {
                 hashCode = (hashCode &* 31) &+ Int(pokeball.rawValue)
              }
              if hasCapturedCellId {
                 hashCode = (hashCode &* 31) &+ capturedCellId.hashValue
              }
              if hasBattlesAttacked {
                 hashCode = (hashCode &* 31) &+ battlesAttacked.hashValue
              }
              if hasBattlesDefended {
                 hashCode = (hashCode &* 31) &+ battlesDefended.hashValue
              }
              if hasEggIncubatorId {
                 hashCode = (hashCode &* 31) &+ eggIncubatorId.hashValue
              }
              if hasCreationTimeMs {
                 hashCode = (hashCode &* 31) &+ creationTimeMs.hashValue
              }
              if hasNumUpgrades {
                 hashCode = (hashCode &* 31) &+ numUpgrades.hashValue
              }
              if hasAdditionalCpMultiplier {
                 hashCode = (hashCode &* 31) &+ additionalCpMultiplier.hashValue
              }
              if hasFavorite {
                 hashCode = (hashCode &* 31) &+ favorite.hashValue
              }
              if hasNickname {
                 hashCode = (hashCode &* 31) &+ nickname.hashValue
              }
              if hasFromFort {
                 hashCode = (hashCode &* 31) &+ fromFort.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.PokemonData"
      }
      override public func className() -> String {
          return "ResponseEnvelop.PokemonData"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.PokemonData.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.PokemonData = ResponseEnvelop.PokemonData()
        public func getMessage() -> ResponseEnvelop.PokemonData {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasId:Bool {
             get {
                  return builderResult.hasId
             }
        }
        public var id:UInt64 {
             get {
                  return builderResult.id
             }
             set (value) {
                 builderResult.hasId = true
                 builderResult.id = value
             }
        }
        public func setId(value:UInt64) -> ResponseEnvelop.PokemonData.Builder {
          self.id = value
          return self
        }
        public func clearId() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasId = false
             builderResult.id = UInt64(0)
             return self
        }
          public var hasPokemonId:Bool{
              get {
                  return builderResult.hasPokemonId
              }
          }
          public var pokemonId:ResponseEnvelop.PokemonId {
              get {
                  return builderResult.pokemonId
              }
              set (value) {
                  builderResult.hasPokemonId = true
                  builderResult.pokemonId = value
              }
          }
          public func setPokemonId(value:ResponseEnvelop.PokemonId) -> ResponseEnvelop.PokemonData.Builder {
            self.pokemonId = value
            return self
          }
          public func clearPokemonId() -> ResponseEnvelop.PokemonData.Builder {
             builderResult.hasPokemonId = false
             builderResult.pokemonId = .Missingno
             return self
          }
        public var hasCp:Bool {
             get {
                  return builderResult.hasCp
             }
        }
        public var cp:Int32 {
             get {
                  return builderResult.cp
             }
             set (value) {
                 builderResult.hasCp = true
                 builderResult.cp = value
             }
        }
        public func setCp(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.cp = value
          return self
        }
        public func clearCp() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasCp = false
             builderResult.cp = Int32(0)
             return self
        }
        public var hasStamina:Bool {
             get {
                  return builderResult.hasStamina
             }
        }
        public var stamina:Int32 {
             get {
                  return builderResult.stamina
             }
             set (value) {
                 builderResult.hasStamina = true
                 builderResult.stamina = value
             }
        }
        public func setStamina(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.stamina = value
          return self
        }
        public func clearStamina() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasStamina = false
             builderResult.stamina = Int32(0)
             return self
        }
        public var hasStaminaMax:Bool {
             get {
                  return builderResult.hasStaminaMax
             }
        }
        public var staminaMax:Int32 {
             get {
                  return builderResult.staminaMax
             }
             set (value) {
                 builderResult.hasStaminaMax = true
                 builderResult.staminaMax = value
             }
        }
        public func setStaminaMax(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.staminaMax = value
          return self
        }
        public func clearStaminaMax() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasStaminaMax = false
             builderResult.staminaMax = Int32(0)
             return self
        }
          public var hasMove1:Bool{
              get {
                  return builderResult.hasMove1
              }
          }
          public var move1:ResponseEnvelop.PokemonMove {
              get {
                  return builderResult.move1
              }
              set (value) {
                  builderResult.hasMove1 = true
                  builderResult.move1 = value
              }
          }
          public func setMove1(value:ResponseEnvelop.PokemonMove) -> ResponseEnvelop.PokemonData.Builder {
            self.move1 = value
            return self
          }
          public func clearMove1() -> ResponseEnvelop.PokemonData.Builder {
             builderResult.hasMove1 = false
             builderResult.move1 = .MoveUnset
             return self
          }
          public var hasMove2:Bool{
              get {
                  return builderResult.hasMove2
              }
          }
          public var move2:ResponseEnvelop.PokemonMove {
              get {
                  return builderResult.move2
              }
              set (value) {
                  builderResult.hasMove2 = true
                  builderResult.move2 = value
              }
          }
          public func setMove2(value:ResponseEnvelop.PokemonMove) -> ResponseEnvelop.PokemonData.Builder {
            self.move2 = value
            return self
          }
          public func clearMove2() -> ResponseEnvelop.PokemonData.Builder {
             builderResult.hasMove2 = false
             builderResult.move2 = .MoveUnset
             return self
          }
        public var hasDeployedFortId:Bool {
             get {
                  return builderResult.hasDeployedFortId
             }
        }
        public var deployedFortId:String {
             get {
                  return builderResult.deployedFortId
             }
             set (value) {
                 builderResult.hasDeployedFortId = true
                 builderResult.deployedFortId = value
             }
        }
        public func setDeployedFortId(value:String) -> ResponseEnvelop.PokemonData.Builder {
          self.deployedFortId = value
          return self
        }
        public func clearDeployedFortId() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasDeployedFortId = false
             builderResult.deployedFortId = ""
             return self
        }
        public var hasOwnerName:Bool {
             get {
                  return builderResult.hasOwnerName
             }
        }
        public var ownerName:String {
             get {
                  return builderResult.ownerName
             }
             set (value) {
                 builderResult.hasOwnerName = true
                 builderResult.ownerName = value
             }
        }
        public func setOwnerName(value:String) -> ResponseEnvelop.PokemonData.Builder {
          self.ownerName = value
          return self
        }
        public func clearOwnerName() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasOwnerName = false
             builderResult.ownerName = ""
             return self
        }
        public var hasIsEgg:Bool {
             get {
                  return builderResult.hasIsEgg
             }
        }
        public var isEgg:Bool {
             get {
                  return builderResult.isEgg
             }
             set (value) {
                 builderResult.hasIsEgg = true
                 builderResult.isEgg = value
             }
        }
        public func setIsEgg(value:Bool) -> ResponseEnvelop.PokemonData.Builder {
          self.isEgg = value
          return self
        }
        public func clearIsEgg() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasIsEgg = false
             builderResult.isEgg = false
             return self
        }
        public var hasEggKmWalkedTarget:Bool {
             get {
                  return builderResult.hasEggKmWalkedTarget
             }
        }
        public var eggKmWalkedTarget:Double {
             get {
                  return builderResult.eggKmWalkedTarget
             }
             set (value) {
                 builderResult.hasEggKmWalkedTarget = true
                 builderResult.eggKmWalkedTarget = value
             }
        }
        public func setEggKmWalkedTarget(value:Double) -> ResponseEnvelop.PokemonData.Builder {
          self.eggKmWalkedTarget = value
          return self
        }
        public func clearEggKmWalkedTarget() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasEggKmWalkedTarget = false
             builderResult.eggKmWalkedTarget = Double(0)
             return self
        }
        public var hasEggKmWalkedStart:Bool {
             get {
                  return builderResult.hasEggKmWalkedStart
             }
        }
        public var eggKmWalkedStart:Double {
             get {
                  return builderResult.eggKmWalkedStart
             }
             set (value) {
                 builderResult.hasEggKmWalkedStart = true
                 builderResult.eggKmWalkedStart = value
             }
        }
        public func setEggKmWalkedStart(value:Double) -> ResponseEnvelop.PokemonData.Builder {
          self.eggKmWalkedStart = value
          return self
        }
        public func clearEggKmWalkedStart() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasEggKmWalkedStart = false
             builderResult.eggKmWalkedStart = Double(0)
             return self
        }
        public var hasOrigin:Bool {
             get {
                  return builderResult.hasOrigin
             }
        }
        public var origin:Int32 {
             get {
                  return builderResult.origin
             }
             set (value) {
                 builderResult.hasOrigin = true
                 builderResult.origin = value
             }
        }
        public func setOrigin(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.origin = value
          return self
        }
        public func clearOrigin() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasOrigin = false
             builderResult.origin = Int32(0)
             return self
        }
        public var hasHeightM:Bool {
             get {
                  return builderResult.hasHeightM
             }
        }
        public var heightM:Float {
             get {
                  return builderResult.heightM
             }
             set (value) {
                 builderResult.hasHeightM = true
                 builderResult.heightM = value
             }
        }
        public func setHeightM(value:Float) -> ResponseEnvelop.PokemonData.Builder {
          self.heightM = value
          return self
        }
        public func clearHeightM() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasHeightM = false
             builderResult.heightM = Float(0)
             return self
        }
        public var hasWeightKg:Bool {
             get {
                  return builderResult.hasWeightKg
             }
        }
        public var weightKg:Float {
             get {
                  return builderResult.weightKg
             }
             set (value) {
                 builderResult.hasWeightKg = true
                 builderResult.weightKg = value
             }
        }
        public func setWeightKg(value:Float) -> ResponseEnvelop.PokemonData.Builder {
          self.weightKg = value
          return self
        }
        public func clearWeightKg() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasWeightKg = false
             builderResult.weightKg = Float(0)
             return self
        }
        public var hasIndividualAttack:Bool {
             get {
                  return builderResult.hasIndividualAttack
             }
        }
        public var individualAttack:Int32 {
             get {
                  return builderResult.individualAttack
             }
             set (value) {
                 builderResult.hasIndividualAttack = true
                 builderResult.individualAttack = value
             }
        }
        public func setIndividualAttack(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.individualAttack = value
          return self
        }
        public func clearIndividualAttack() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasIndividualAttack = false
             builderResult.individualAttack = Int32(0)
             return self
        }
        public var hasIndividualDefense:Bool {
             get {
                  return builderResult.hasIndividualDefense
             }
        }
        public var individualDefense:Int32 {
             get {
                  return builderResult.individualDefense
             }
             set (value) {
                 builderResult.hasIndividualDefense = true
                 builderResult.individualDefense = value
             }
        }
        public func setIndividualDefense(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.individualDefense = value
          return self
        }
        public func clearIndividualDefense() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasIndividualDefense = false
             builderResult.individualDefense = Int32(0)
             return self
        }
        public var hasIndividualStamina:Bool {
             get {
                  return builderResult.hasIndividualStamina
             }
        }
        public var individualStamina:Int32 {
             get {
                  return builderResult.individualStamina
             }
             set (value) {
                 builderResult.hasIndividualStamina = true
                 builderResult.individualStamina = value
             }
        }
        public func setIndividualStamina(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.individualStamina = value
          return self
        }
        public func clearIndividualStamina() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasIndividualStamina = false
             builderResult.individualStamina = Int32(0)
             return self
        }
        public var hasCpMultiplier:Bool {
             get {
                  return builderResult.hasCpMultiplier
             }
        }
        public var cpMultiplier:Float {
             get {
                  return builderResult.cpMultiplier
             }
             set (value) {
                 builderResult.hasCpMultiplier = true
                 builderResult.cpMultiplier = value
             }
        }
        public func setCpMultiplier(value:Float) -> ResponseEnvelop.PokemonData.Builder {
          self.cpMultiplier = value
          return self
        }
        public func clearCpMultiplier() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasCpMultiplier = false
             builderResult.cpMultiplier = Float(0)
             return self
        }
          public var hasPokeball:Bool{
              get {
                  return builderResult.hasPokeball
              }
          }
          public var pokeball:ResponseEnvelop.ItemId {
              get {
                  return builderResult.pokeball
              }
              set (value) {
                  builderResult.hasPokeball = true
                  builderResult.pokeball = value
              }
          }
          public func setPokeball(value:ResponseEnvelop.ItemId) -> ResponseEnvelop.PokemonData.Builder {
            self.pokeball = value
            return self
          }
          public func clearPokeball() -> ResponseEnvelop.PokemonData.Builder {
             builderResult.hasPokeball = false
             builderResult.pokeball = .ItemUnknown
             return self
          }
        public var hasCapturedCellId:Bool {
             get {
                  return builderResult.hasCapturedCellId
             }
        }
        public var capturedCellId:UInt64 {
             get {
                  return builderResult.capturedCellId
             }
             set (value) {
                 builderResult.hasCapturedCellId = true
                 builderResult.capturedCellId = value
             }
        }
        public func setCapturedCellId(value:UInt64) -> ResponseEnvelop.PokemonData.Builder {
          self.capturedCellId = value
          return self
        }
        public func clearCapturedCellId() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasCapturedCellId = false
             builderResult.capturedCellId = UInt64(0)
             return self
        }
        public var hasBattlesAttacked:Bool {
             get {
                  return builderResult.hasBattlesAttacked
             }
        }
        public var battlesAttacked:Int32 {
             get {
                  return builderResult.battlesAttacked
             }
             set (value) {
                 builderResult.hasBattlesAttacked = true
                 builderResult.battlesAttacked = value
             }
        }
        public func setBattlesAttacked(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.battlesAttacked = value
          return self
        }
        public func clearBattlesAttacked() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasBattlesAttacked = false
             builderResult.battlesAttacked = Int32(0)
             return self
        }
        public var hasBattlesDefended:Bool {
             get {
                  return builderResult.hasBattlesDefended
             }
        }
        public var battlesDefended:Int32 {
             get {
                  return builderResult.battlesDefended
             }
             set (value) {
                 builderResult.hasBattlesDefended = true
                 builderResult.battlesDefended = value
             }
        }
        public func setBattlesDefended(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.battlesDefended = value
          return self
        }
        public func clearBattlesDefended() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasBattlesDefended = false
             builderResult.battlesDefended = Int32(0)
             return self
        }
        public var hasEggIncubatorId:Bool {
             get {
                  return builderResult.hasEggIncubatorId
             }
        }
        public var eggIncubatorId:String {
             get {
                  return builderResult.eggIncubatorId
             }
             set (value) {
                 builderResult.hasEggIncubatorId = true
                 builderResult.eggIncubatorId = value
             }
        }
        public func setEggIncubatorId(value:String) -> ResponseEnvelop.PokemonData.Builder {
          self.eggIncubatorId = value
          return self
        }
        public func clearEggIncubatorId() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasEggIncubatorId = false
             builderResult.eggIncubatorId = ""
             return self
        }
        public var hasCreationTimeMs:Bool {
             get {
                  return builderResult.hasCreationTimeMs
             }
        }
        public var creationTimeMs:UInt64 {
             get {
                  return builderResult.creationTimeMs
             }
             set (value) {
                 builderResult.hasCreationTimeMs = true
                 builderResult.creationTimeMs = value
             }
        }
        public func setCreationTimeMs(value:UInt64) -> ResponseEnvelop.PokemonData.Builder {
          self.creationTimeMs = value
          return self
        }
        public func clearCreationTimeMs() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasCreationTimeMs = false
             builderResult.creationTimeMs = UInt64(0)
             return self
        }
        public var hasNumUpgrades:Bool {
             get {
                  return builderResult.hasNumUpgrades
             }
        }
        public var numUpgrades:Int32 {
             get {
                  return builderResult.numUpgrades
             }
             set (value) {
                 builderResult.hasNumUpgrades = true
                 builderResult.numUpgrades = value
             }
        }
        public func setNumUpgrades(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.numUpgrades = value
          return self
        }
        public func clearNumUpgrades() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasNumUpgrades = false
             builderResult.numUpgrades = Int32(0)
             return self
        }
        public var hasAdditionalCpMultiplier:Bool {
             get {
                  return builderResult.hasAdditionalCpMultiplier
             }
        }
        public var additionalCpMultiplier:Float {
             get {
                  return builderResult.additionalCpMultiplier
             }
             set (value) {
                 builderResult.hasAdditionalCpMultiplier = true
                 builderResult.additionalCpMultiplier = value
             }
        }
        public func setAdditionalCpMultiplier(value:Float) -> ResponseEnvelop.PokemonData.Builder {
          self.additionalCpMultiplier = value
          return self
        }
        public func clearAdditionalCpMultiplier() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasAdditionalCpMultiplier = false
             builderResult.additionalCpMultiplier = Float(0)
             return self
        }
        public var hasFavorite:Bool {
             get {
                  return builderResult.hasFavorite
             }
        }
        public var favorite:Int32 {
             get {
                  return builderResult.favorite
             }
             set (value) {
                 builderResult.hasFavorite = true
                 builderResult.favorite = value
             }
        }
        public func setFavorite(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.favorite = value
          return self
        }
        public func clearFavorite() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasFavorite = false
             builderResult.favorite = Int32(0)
             return self
        }
        public var hasNickname:Bool {
             get {
                  return builderResult.hasNickname
             }
        }
        public var nickname:String {
             get {
                  return builderResult.nickname
             }
             set (value) {
                 builderResult.hasNickname = true
                 builderResult.nickname = value
             }
        }
        public func setNickname(value:String) -> ResponseEnvelop.PokemonData.Builder {
          self.nickname = value
          return self
        }
        public func clearNickname() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasNickname = false
             builderResult.nickname = ""
             return self
        }
        public var hasFromFort:Bool {
             get {
                  return builderResult.hasFromFort
             }
        }
        public var fromFort:Int32 {
             get {
                  return builderResult.fromFort
             }
             set (value) {
                 builderResult.hasFromFort = true
                 builderResult.fromFort = value
             }
        }
        public func setFromFort(value:Int32) -> ResponseEnvelop.PokemonData.Builder {
          self.fromFort = value
          return self
        }
        public func clearFromFort() -> ResponseEnvelop.PokemonData.Builder{
             builderResult.hasFromFort = false
             builderResult.fromFort = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.PokemonData.Builder {
          builderResult = ResponseEnvelop.PokemonData()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.PokemonData.Builder {
          return try ResponseEnvelop.PokemonData.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.PokemonData {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.PokemonData {
          let returnMe:ResponseEnvelop.PokemonData = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.PokemonData) throws -> ResponseEnvelop.PokemonData.Builder {
          if other == ResponseEnvelop.PokemonData() {
           return self
          }
          if other.hasId {
               id = other.id
          }
          if other.hasPokemonId {
               pokemonId = other.pokemonId
          }
          if other.hasCp {
               cp = other.cp
          }
          if other.hasStamina {
               stamina = other.stamina
          }
          if other.hasStaminaMax {
               staminaMax = other.staminaMax
          }
          if other.hasMove1 {
               move1 = other.move1
          }
          if other.hasMove2 {
               move2 = other.move2
          }
          if other.hasDeployedFortId {
               deployedFortId = other.deployedFortId
          }
          if other.hasOwnerName {
               ownerName = other.ownerName
          }
          if other.hasIsEgg {
               isEgg = other.isEgg
          }
          if other.hasEggKmWalkedTarget {
               eggKmWalkedTarget = other.eggKmWalkedTarget
          }
          if other.hasEggKmWalkedStart {
               eggKmWalkedStart = other.eggKmWalkedStart
          }
          if other.hasOrigin {
               origin = other.origin
          }
          if other.hasHeightM {
               heightM = other.heightM
          }
          if other.hasWeightKg {
               weightKg = other.weightKg
          }
          if other.hasIndividualAttack {
               individualAttack = other.individualAttack
          }
          if other.hasIndividualDefense {
               individualDefense = other.individualDefense
          }
          if other.hasIndividualStamina {
               individualStamina = other.individualStamina
          }
          if other.hasCpMultiplier {
               cpMultiplier = other.cpMultiplier
          }
          if other.hasPokeball {
               pokeball = other.pokeball
          }
          if other.hasCapturedCellId {
               capturedCellId = other.capturedCellId
          }
          if other.hasBattlesAttacked {
               battlesAttacked = other.battlesAttacked
          }
          if other.hasBattlesDefended {
               battlesDefended = other.battlesDefended
          }
          if other.hasEggIncubatorId {
               eggIncubatorId = other.eggIncubatorId
          }
          if other.hasCreationTimeMs {
               creationTimeMs = other.creationTimeMs
          }
          if other.hasNumUpgrades {
               numUpgrades = other.numUpgrades
          }
          if other.hasAdditionalCpMultiplier {
               additionalCpMultiplier = other.additionalCpMultiplier
          }
          if other.hasFavorite {
               favorite = other.favorite
          }
          if other.hasNickname {
               nickname = other.nickname
          }
          if other.hasFromFort {
               fromFort = other.fromFort
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokemonData.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonData.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 9 :
              id = try input.readFixed64()

            case 16 :
              let valueIntpokemonId = try input.readEnum()
              if let enumspokemonId = ResponseEnvelop.PokemonId(rawValue:valueIntpokemonId){
                   pokemonId = enumspokemonId
              } else {
                   try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntpokemonId))
              }

            case 24 :
              cp = try input.readInt32()

            case 32 :
              stamina = try input.readInt32()

            case 40 :
              staminaMax = try input.readInt32()

            case 48 :
              let valueIntmove1 = try input.readEnum()
              if let enumsmove1 = ResponseEnvelop.PokemonMove(rawValue:valueIntmove1){
                   move1 = enumsmove1
              } else {
                   try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntmove1))
              }

            case 56 :
              let valueIntmove2 = try input.readEnum()
              if let enumsmove2 = ResponseEnvelop.PokemonMove(rawValue:valueIntmove2){
                   move2 = enumsmove2
              } else {
                   try unknownFieldsBuilder.mergeVarintField(7, value:Int64(valueIntmove2))
              }

            case 66 :
              deployedFortId = try input.readString()

            case 74 :
              ownerName = try input.readString()

            case 80 :
              isEgg = try input.readBool()

            case 89 :
              eggKmWalkedTarget = try input.readDouble()

            case 97 :
              eggKmWalkedStart = try input.readDouble()

            case 112 :
              origin = try input.readInt32()

            case 125 :
              heightM = try input.readFloat()

            case 133 :
              weightKg = try input.readFloat()

            case 136 :
              individualAttack = try input.readInt32()

            case 144 :
              individualDefense = try input.readInt32()

            case 152 :
              individualStamina = try input.readInt32()

            case 165 :
              cpMultiplier = try input.readFloat()

            case 168 :
              let valueIntpokeball = try input.readEnum()
              if let enumspokeball = ResponseEnvelop.ItemId(rawValue:valueIntpokeball){
                   pokeball = enumspokeball
              } else {
                   try unknownFieldsBuilder.mergeVarintField(21, value:Int64(valueIntpokeball))
              }

            case 176 :
              capturedCellId = try input.readUInt64()

            case 184 :
              battlesAttacked = try input.readInt32()

            case 192 :
              battlesDefended = try input.readInt32()

            case 202 :
              eggIncubatorId = try input.readString()

            case 208 :
              creationTimeMs = try input.readUInt64()

            case 216 :
              numUpgrades = try input.readInt32()

            case 229 :
              additionalCpMultiplier = try input.readFloat()

            case 232 :
              favorite = try input.readInt32()

            case 242 :
              nickname = try input.readString()

            case 248 :
              fromFort = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class Pokemon : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var id:Int32 = Int32(0)

      public private(set) var hasId:Bool = false
      public private(set) var pokemonType:ResponseEnvelop.PokemonId = ResponseEnvelop.PokemonId.Missingno
      public private(set) var hasPokemonType:Bool = false
      public private(set) var cp:Int32 = Int32(0)

      public private(set) var hasCp:Bool = false
      public private(set) var stamina:Int32 = Int32(0)

      public private(set) var hasStamina:Bool = false
      public private(set) var staminaMax:Int32 = Int32(0)

      public private(set) var hasStaminaMax:Bool = false
      public private(set) var move1:ResponseEnvelop.PokemonMove = ResponseEnvelop.PokemonMove.MoveUnset
      public private(set) var hasMove1:Bool = false
      public private(set) var move2:ResponseEnvelop.PokemonMove = ResponseEnvelop.PokemonMove.MoveUnset
      public private(set) var hasMove2:Bool = false
      public private(set) var deployedFortId:String = ""

      public private(set) var hasDeployedFortId:Bool = false
      public private(set) var ownerName:String = ""

      public private(set) var hasOwnerName:Bool = false
      public private(set) var isEgg:Bool = false

      public private(set) var hasIsEgg:Bool = false
      public private(set) var eggKmWalkedTarget:Int32 = Int32(0)

      public private(set) var hasEggKmWalkedTarget:Bool = false
      public private(set) var eggKmWalkedStart:Int32 = Int32(0)

      public private(set) var hasEggKmWalkedStart:Bool = false
      public private(set) var origin:Int32 = Int32(0)

      public private(set) var hasOrigin:Bool = false
      public private(set) var heightM:Float = Float(0)

      public private(set) var hasHeightM:Bool = false
      public private(set) var weightKg:Float = Float(0)

      public private(set) var hasWeightKg:Bool = false
      public private(set) var individualAttack:Int32 = Int32(0)

      public private(set) var hasIndividualAttack:Bool = false
      public private(set) var individualDefense:Int32 = Int32(0)

      public private(set) var hasIndividualDefense:Bool = false
      public private(set) var individualStamina:Int32 = Int32(0)

      public private(set) var hasIndividualStamina:Bool = false
      public private(set) var cpMultiplier:Int32 = Int32(0)

      public private(set) var hasCpMultiplier:Bool = false
      public private(set) var pokeball:Int32 = Int32(0)

      public private(set) var hasPokeball:Bool = false
      public private(set) var capturedCellId:UInt64 = UInt64(0)

      public private(set) var hasCapturedCellId:Bool = false
      public private(set) var battlesAttacked:Int32 = Int32(0)

      public private(set) var hasBattlesAttacked:Bool = false
      public private(set) var battlesDefended:Int32 = Int32(0)

      public private(set) var hasBattlesDefended:Bool = false
      public private(set) var eggIncubatorId:Int32 = Int32(0)

      public private(set) var hasEggIncubatorId:Bool = false
      public private(set) var creationTimeMs:UInt64 = UInt64(0)

      public private(set) var hasCreationTimeMs:Bool = false
      public private(set) var numUpgrades:Int32 = Int32(0)

      public private(set) var hasNumUpgrades:Bool = false
      public private(set) var additionalCpMultiplier:Int32 = Int32(0)

      public private(set) var hasAdditionalCpMultiplier:Bool = false
      public private(set) var favorite:Int32 = Int32(0)

      public private(set) var hasFavorite:Bool = false
      public private(set) var nickname:String = ""

      public private(set) var hasNickname:Bool = false
      public private(set) var fromFort:Int32 = Int32(0)

      public private(set) var hasFromFort:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasId {
          try output.writeInt32(1, value:id)
        }
        if hasPokemonType {
          try output.writeEnum(2, value:pokemonType.rawValue)
        }
        if hasCp {
          try output.writeInt32(3, value:cp)
        }
        if hasStamina {
          try output.writeInt32(4, value:stamina)
        }
        if hasStaminaMax {
          try output.writeInt32(5, value:staminaMax)
        }
        if hasMove1 {
          try output.writeEnum(6, value:move1.rawValue)
        }
        if hasMove2 {
          try output.writeEnum(7, value:move2.rawValue)
        }
        if hasDeployedFortId {
          try output.writeString(8, value:deployedFortId)
        }
        if hasOwnerName {
          try output.writeString(9, value:ownerName)
        }
        if hasIsEgg {
          try output.writeBool(10, value:isEgg)
        }
        if hasEggKmWalkedTarget {
          try output.writeInt32(11, value:eggKmWalkedTarget)
        }
        if hasEggKmWalkedStart {
          try output.writeInt32(12, value:eggKmWalkedStart)
        }
        if hasOrigin {
          try output.writeInt32(14, value:origin)
        }
        if hasHeightM {
          try output.writeFloat(15, value:heightM)
        }
        if hasWeightKg {
          try output.writeFloat(16, value:weightKg)
        }
        if hasIndividualAttack {
          try output.writeInt32(17, value:individualAttack)
        }
        if hasIndividualDefense {
          try output.writeInt32(18, value:individualDefense)
        }
        if hasIndividualStamina {
          try output.writeInt32(19, value:individualStamina)
        }
        if hasCpMultiplier {
          try output.writeInt32(20, value:cpMultiplier)
        }
        if hasPokeball {
          try output.writeInt32(21, value:pokeball)
        }
        if hasCapturedCellId {
          try output.writeUInt64(22, value:capturedCellId)
        }
        if hasBattlesAttacked {
          try output.writeInt32(23, value:battlesAttacked)
        }
        if hasBattlesDefended {
          try output.writeInt32(24, value:battlesDefended)
        }
        if hasEggIncubatorId {
          try output.writeInt32(25, value:eggIncubatorId)
        }
        if hasCreationTimeMs {
          try output.writeUInt64(26, value:creationTimeMs)
        }
        if hasNumUpgrades {
          try output.writeInt32(27, value:numUpgrades)
        }
        if hasAdditionalCpMultiplier {
          try output.writeInt32(28, value:additionalCpMultiplier)
        }
        if hasFavorite {
          try output.writeInt32(29, value:favorite)
        }
        if hasNickname {
          try output.writeString(30, value:nickname)
        }
        if hasFromFort {
          try output.writeInt32(31, value:fromFort)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
          serialize_size += id.computeInt32Size(1)
        }
        if (hasPokemonType) {
          serialize_size += pokemonType.rawValue.computeEnumSize(2)
        }
        if hasCp {
          serialize_size += cp.computeInt32Size(3)
        }
        if hasStamina {
          serialize_size += stamina.computeInt32Size(4)
        }
        if hasStaminaMax {
          serialize_size += staminaMax.computeInt32Size(5)
        }
        if (hasMove1) {
          serialize_size += move1.rawValue.computeEnumSize(6)
        }
        if (hasMove2) {
          serialize_size += move2.rawValue.computeEnumSize(7)
        }
        if hasDeployedFortId {
          serialize_size += deployedFortId.computeStringSize(8)
        }
        if hasOwnerName {
          serialize_size += ownerName.computeStringSize(9)
        }
        if hasIsEgg {
          serialize_size += isEgg.computeBoolSize(10)
        }
        if hasEggKmWalkedTarget {
          serialize_size += eggKmWalkedTarget.computeInt32Size(11)
        }
        if hasEggKmWalkedStart {
          serialize_size += eggKmWalkedStart.computeInt32Size(12)
        }
        if hasOrigin {
          serialize_size += origin.computeInt32Size(14)
        }
        if hasHeightM {
          serialize_size += heightM.computeFloatSize(15)
        }
        if hasWeightKg {
          serialize_size += weightKg.computeFloatSize(16)
        }
        if hasIndividualAttack {
          serialize_size += individualAttack.computeInt32Size(17)
        }
        if hasIndividualDefense {
          serialize_size += individualDefense.computeInt32Size(18)
        }
        if hasIndividualStamina {
          serialize_size += individualStamina.computeInt32Size(19)
        }
        if hasCpMultiplier {
          serialize_size += cpMultiplier.computeInt32Size(20)
        }
        if hasPokeball {
          serialize_size += pokeball.computeInt32Size(21)
        }
        if hasCapturedCellId {
          serialize_size += capturedCellId.computeUInt64Size(22)
        }
        if hasBattlesAttacked {
          serialize_size += battlesAttacked.computeInt32Size(23)
        }
        if hasBattlesDefended {
          serialize_size += battlesDefended.computeInt32Size(24)
        }
        if hasEggIncubatorId {
          serialize_size += eggIncubatorId.computeInt32Size(25)
        }
        if hasCreationTimeMs {
          serialize_size += creationTimeMs.computeUInt64Size(26)
        }
        if hasNumUpgrades {
          serialize_size += numUpgrades.computeInt32Size(27)
        }
        if hasAdditionalCpMultiplier {
          serialize_size += additionalCpMultiplier.computeInt32Size(28)
        }
        if hasFavorite {
          serialize_size += favorite.computeInt32Size(29)
        }
        if hasNickname {
          serialize_size += nickname.computeStringSize(30)
        }
        if hasFromFort {
          serialize_size += fromFort.computeInt32Size(31)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.Pokemon> {
        var mergedArray = Array<ResponseEnvelop.Pokemon>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Pokemon? {
        return try ResponseEnvelop.Pokemon.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.Pokemon {
        return try ResponseEnvelop.Pokemon.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Pokemon {
        return try ResponseEnvelop.Pokemon.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Pokemon {
        return try ResponseEnvelop.Pokemon.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Pokemon {
        return try ResponseEnvelop.Pokemon.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Pokemon {
        return try ResponseEnvelop.Pokemon.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Pokemon {
        return try ResponseEnvelop.Pokemon.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.Pokemon.Builder {
        return ResponseEnvelop.Pokemon.classBuilder() as! ResponseEnvelop.Pokemon.Builder
      }
      public func getBuilder() -> ResponseEnvelop.Pokemon.Builder {
        return classBuilder() as! ResponseEnvelop.Pokemon.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.Pokemon.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.Pokemon.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.Pokemon.Builder {
        return try ResponseEnvelop.Pokemon.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.Pokemon) throws -> ResponseEnvelop.Pokemon.Builder {
        return try ResponseEnvelop.Pokemon.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasId {
          output += "\(indent) id: \(id) \n"
        }
        if (hasPokemonType) {
          output += "\(indent) pokemonType: \(pokemonType.description)\n"
        }
        if hasCp {
          output += "\(indent) cp: \(cp) \n"
        }
        if hasStamina {
          output += "\(indent) stamina: \(stamina) \n"
        }
        if hasStaminaMax {
          output += "\(indent) staminaMax: \(staminaMax) \n"
        }
        if (hasMove1) {
          output += "\(indent) move1: \(move1.description)\n"
        }
        if (hasMove2) {
          output += "\(indent) move2: \(move2.description)\n"
        }
        if hasDeployedFortId {
          output += "\(indent) deployedFortId: \(deployedFortId) \n"
        }
        if hasOwnerName {
          output += "\(indent) ownerName: \(ownerName) \n"
        }
        if hasIsEgg {
          output += "\(indent) isEgg: \(isEgg) \n"
        }
        if hasEggKmWalkedTarget {
          output += "\(indent) eggKmWalkedTarget: \(eggKmWalkedTarget) \n"
        }
        if hasEggKmWalkedStart {
          output += "\(indent) eggKmWalkedStart: \(eggKmWalkedStart) \n"
        }
        if hasOrigin {
          output += "\(indent) origin: \(origin) \n"
        }
        if hasHeightM {
          output += "\(indent) heightM: \(heightM) \n"
        }
        if hasWeightKg {
          output += "\(indent) weightKg: \(weightKg) \n"
        }
        if hasIndividualAttack {
          output += "\(indent) individualAttack: \(individualAttack) \n"
        }
        if hasIndividualDefense {
          output += "\(indent) individualDefense: \(individualDefense) \n"
        }
        if hasIndividualStamina {
          output += "\(indent) individualStamina: \(individualStamina) \n"
        }
        if hasCpMultiplier {
          output += "\(indent) cpMultiplier: \(cpMultiplier) \n"
        }
        if hasPokeball {
          output += "\(indent) pokeball: \(pokeball) \n"
        }
        if hasCapturedCellId {
          output += "\(indent) capturedCellId: \(capturedCellId) \n"
        }
        if hasBattlesAttacked {
          output += "\(indent) battlesAttacked: \(battlesAttacked) \n"
        }
        if hasBattlesDefended {
          output += "\(indent) battlesDefended: \(battlesDefended) \n"
        }
        if hasEggIncubatorId {
          output += "\(indent) eggIncubatorId: \(eggIncubatorId) \n"
        }
        if hasCreationTimeMs {
          output += "\(indent) creationTimeMs: \(creationTimeMs) \n"
        }
        if hasNumUpgrades {
          output += "\(indent) numUpgrades: \(numUpgrades) \n"
        }
        if hasAdditionalCpMultiplier {
          output += "\(indent) additionalCpMultiplier: \(additionalCpMultiplier) \n"
        }
        if hasFavorite {
          output += "\(indent) favorite: \(favorite) \n"
        }
        if hasNickname {
          output += "\(indent) nickname: \(nickname) \n"
        }
        if hasFromFort {
          output += "\(indent) fromFort: \(fromFort) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasId {
                 hashCode = (hashCode &* 31) &+ id.hashValue
              }
              if hasPokemonType {
                 hashCode = (hashCode &* 31) &+ Int(pokemonType.rawValue)
              }
              if hasCp {
                 hashCode = (hashCode &* 31) &+ cp.hashValue
              }
              if hasStamina {
                 hashCode = (hashCode &* 31) &+ stamina.hashValue
              }
              if hasStaminaMax {
                 hashCode = (hashCode &* 31) &+ staminaMax.hashValue
              }
              if hasMove1 {
                 hashCode = (hashCode &* 31) &+ Int(move1.rawValue)
              }
              if hasMove2 {
                 hashCode = (hashCode &* 31) &+ Int(move2.rawValue)
              }
              if hasDeployedFortId {
                 hashCode = (hashCode &* 31) &+ deployedFortId.hashValue
              }
              if hasOwnerName {
                 hashCode = (hashCode &* 31) &+ ownerName.hashValue
              }
              if hasIsEgg {
                 hashCode = (hashCode &* 31) &+ isEgg.hashValue
              }
              if hasEggKmWalkedTarget {
                 hashCode = (hashCode &* 31) &+ eggKmWalkedTarget.hashValue
              }
              if hasEggKmWalkedStart {
                 hashCode = (hashCode &* 31) &+ eggKmWalkedStart.hashValue
              }
              if hasOrigin {
                 hashCode = (hashCode &* 31) &+ origin.hashValue
              }
              if hasHeightM {
                 hashCode = (hashCode &* 31) &+ heightM.hashValue
              }
              if hasWeightKg {
                 hashCode = (hashCode &* 31) &+ weightKg.hashValue
              }
              if hasIndividualAttack {
                 hashCode = (hashCode &* 31) &+ individualAttack.hashValue
              }
              if hasIndividualDefense {
                 hashCode = (hashCode &* 31) &+ individualDefense.hashValue
              }
              if hasIndividualStamina {
                 hashCode = (hashCode &* 31) &+ individualStamina.hashValue
              }
              if hasCpMultiplier {
                 hashCode = (hashCode &* 31) &+ cpMultiplier.hashValue
              }
              if hasPokeball {
                 hashCode = (hashCode &* 31) &+ pokeball.hashValue
              }
              if hasCapturedCellId {
                 hashCode = (hashCode &* 31) &+ capturedCellId.hashValue
              }
              if hasBattlesAttacked {
                 hashCode = (hashCode &* 31) &+ battlesAttacked.hashValue
              }
              if hasBattlesDefended {
                 hashCode = (hashCode &* 31) &+ battlesDefended.hashValue
              }
              if hasEggIncubatorId {
                 hashCode = (hashCode &* 31) &+ eggIncubatorId.hashValue
              }
              if hasCreationTimeMs {
                 hashCode = (hashCode &* 31) &+ creationTimeMs.hashValue
              }
              if hasNumUpgrades {
                 hashCode = (hashCode &* 31) &+ numUpgrades.hashValue
              }
              if hasAdditionalCpMultiplier {
                 hashCode = (hashCode &* 31) &+ additionalCpMultiplier.hashValue
              }
              if hasFavorite {
                 hashCode = (hashCode &* 31) &+ favorite.hashValue
              }
              if hasNickname {
                 hashCode = (hashCode &* 31) &+ nickname.hashValue
              }
              if hasFromFort {
                 hashCode = (hashCode &* 31) &+ fromFort.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.Pokemon"
      }
      override public func className() -> String {
          return "ResponseEnvelop.Pokemon"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.Pokemon.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.Pokemon = ResponseEnvelop.Pokemon()
        public func getMessage() -> ResponseEnvelop.Pokemon {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasId:Bool {
             get {
                  return builderResult.hasId
             }
        }
        public var id:Int32 {
             get {
                  return builderResult.id
             }
             set (value) {
                 builderResult.hasId = true
                 builderResult.id = value
             }
        }
        public func setId(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.id = value
          return self
        }
        public func clearId() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasId = false
             builderResult.id = Int32(0)
             return self
        }
          public var hasPokemonType:Bool{
              get {
                  return builderResult.hasPokemonType
              }
          }
          public var pokemonType:ResponseEnvelop.PokemonId {
              get {
                  return builderResult.pokemonType
              }
              set (value) {
                  builderResult.hasPokemonType = true
                  builderResult.pokemonType = value
              }
          }
          public func setPokemonType(value:ResponseEnvelop.PokemonId) -> ResponseEnvelop.Pokemon.Builder {
            self.pokemonType = value
            return self
          }
          public func clearPokemonType() -> ResponseEnvelop.Pokemon.Builder {
             builderResult.hasPokemonType = false
             builderResult.pokemonType = .Missingno
             return self
          }
        public var hasCp:Bool {
             get {
                  return builderResult.hasCp
             }
        }
        public var cp:Int32 {
             get {
                  return builderResult.cp
             }
             set (value) {
                 builderResult.hasCp = true
                 builderResult.cp = value
             }
        }
        public func setCp(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.cp = value
          return self
        }
        public func clearCp() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasCp = false
             builderResult.cp = Int32(0)
             return self
        }
        public var hasStamina:Bool {
             get {
                  return builderResult.hasStamina
             }
        }
        public var stamina:Int32 {
             get {
                  return builderResult.stamina
             }
             set (value) {
                 builderResult.hasStamina = true
                 builderResult.stamina = value
             }
        }
        public func setStamina(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.stamina = value
          return self
        }
        public func clearStamina() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasStamina = false
             builderResult.stamina = Int32(0)
             return self
        }
        public var hasStaminaMax:Bool {
             get {
                  return builderResult.hasStaminaMax
             }
        }
        public var staminaMax:Int32 {
             get {
                  return builderResult.staminaMax
             }
             set (value) {
                 builderResult.hasStaminaMax = true
                 builderResult.staminaMax = value
             }
        }
        public func setStaminaMax(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.staminaMax = value
          return self
        }
        public func clearStaminaMax() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasStaminaMax = false
             builderResult.staminaMax = Int32(0)
             return self
        }
          public var hasMove1:Bool{
              get {
                  return builderResult.hasMove1
              }
          }
          public var move1:ResponseEnvelop.PokemonMove {
              get {
                  return builderResult.move1
              }
              set (value) {
                  builderResult.hasMove1 = true
                  builderResult.move1 = value
              }
          }
          public func setMove1(value:ResponseEnvelop.PokemonMove) -> ResponseEnvelop.Pokemon.Builder {
            self.move1 = value
            return self
          }
          public func clearMove1() -> ResponseEnvelop.Pokemon.Builder {
             builderResult.hasMove1 = false
             builderResult.move1 = .MoveUnset
             return self
          }
          public var hasMove2:Bool{
              get {
                  return builderResult.hasMove2
              }
          }
          public var move2:ResponseEnvelop.PokemonMove {
              get {
                  return builderResult.move2
              }
              set (value) {
                  builderResult.hasMove2 = true
                  builderResult.move2 = value
              }
          }
          public func setMove2(value:ResponseEnvelop.PokemonMove) -> ResponseEnvelop.Pokemon.Builder {
            self.move2 = value
            return self
          }
          public func clearMove2() -> ResponseEnvelop.Pokemon.Builder {
             builderResult.hasMove2 = false
             builderResult.move2 = .MoveUnset
             return self
          }
        public var hasDeployedFortId:Bool {
             get {
                  return builderResult.hasDeployedFortId
             }
        }
        public var deployedFortId:String {
             get {
                  return builderResult.deployedFortId
             }
             set (value) {
                 builderResult.hasDeployedFortId = true
                 builderResult.deployedFortId = value
             }
        }
        public func setDeployedFortId(value:String) -> ResponseEnvelop.Pokemon.Builder {
          self.deployedFortId = value
          return self
        }
        public func clearDeployedFortId() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasDeployedFortId = false
             builderResult.deployedFortId = ""
             return self
        }
        public var hasOwnerName:Bool {
             get {
                  return builderResult.hasOwnerName
             }
        }
        public var ownerName:String {
             get {
                  return builderResult.ownerName
             }
             set (value) {
                 builderResult.hasOwnerName = true
                 builderResult.ownerName = value
             }
        }
        public func setOwnerName(value:String) -> ResponseEnvelop.Pokemon.Builder {
          self.ownerName = value
          return self
        }
        public func clearOwnerName() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasOwnerName = false
             builderResult.ownerName = ""
             return self
        }
        public var hasIsEgg:Bool {
             get {
                  return builderResult.hasIsEgg
             }
        }
        public var isEgg:Bool {
             get {
                  return builderResult.isEgg
             }
             set (value) {
                 builderResult.hasIsEgg = true
                 builderResult.isEgg = value
             }
        }
        public func setIsEgg(value:Bool) -> ResponseEnvelop.Pokemon.Builder {
          self.isEgg = value
          return self
        }
        public func clearIsEgg() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasIsEgg = false
             builderResult.isEgg = false
             return self
        }
        public var hasEggKmWalkedTarget:Bool {
             get {
                  return builderResult.hasEggKmWalkedTarget
             }
        }
        public var eggKmWalkedTarget:Int32 {
             get {
                  return builderResult.eggKmWalkedTarget
             }
             set (value) {
                 builderResult.hasEggKmWalkedTarget = true
                 builderResult.eggKmWalkedTarget = value
             }
        }
        public func setEggKmWalkedTarget(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.eggKmWalkedTarget = value
          return self
        }
        public func clearEggKmWalkedTarget() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasEggKmWalkedTarget = false
             builderResult.eggKmWalkedTarget = Int32(0)
             return self
        }
        public var hasEggKmWalkedStart:Bool {
             get {
                  return builderResult.hasEggKmWalkedStart
             }
        }
        public var eggKmWalkedStart:Int32 {
             get {
                  return builderResult.eggKmWalkedStart
             }
             set (value) {
                 builderResult.hasEggKmWalkedStart = true
                 builderResult.eggKmWalkedStart = value
             }
        }
        public func setEggKmWalkedStart(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.eggKmWalkedStart = value
          return self
        }
        public func clearEggKmWalkedStart() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasEggKmWalkedStart = false
             builderResult.eggKmWalkedStart = Int32(0)
             return self
        }
        public var hasOrigin:Bool {
             get {
                  return builderResult.hasOrigin
             }
        }
        public var origin:Int32 {
             get {
                  return builderResult.origin
             }
             set (value) {
                 builderResult.hasOrigin = true
                 builderResult.origin = value
             }
        }
        public func setOrigin(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.origin = value
          return self
        }
        public func clearOrigin() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasOrigin = false
             builderResult.origin = Int32(0)
             return self
        }
        public var hasHeightM:Bool {
             get {
                  return builderResult.hasHeightM
             }
        }
        public var heightM:Float {
             get {
                  return builderResult.heightM
             }
             set (value) {
                 builderResult.hasHeightM = true
                 builderResult.heightM = value
             }
        }
        public func setHeightM(value:Float) -> ResponseEnvelop.Pokemon.Builder {
          self.heightM = value
          return self
        }
        public func clearHeightM() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasHeightM = false
             builderResult.heightM = Float(0)
             return self
        }
        public var hasWeightKg:Bool {
             get {
                  return builderResult.hasWeightKg
             }
        }
        public var weightKg:Float {
             get {
                  return builderResult.weightKg
             }
             set (value) {
                 builderResult.hasWeightKg = true
                 builderResult.weightKg = value
             }
        }
        public func setWeightKg(value:Float) -> ResponseEnvelop.Pokemon.Builder {
          self.weightKg = value
          return self
        }
        public func clearWeightKg() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasWeightKg = false
             builderResult.weightKg = Float(0)
             return self
        }
        public var hasIndividualAttack:Bool {
             get {
                  return builderResult.hasIndividualAttack
             }
        }
        public var individualAttack:Int32 {
             get {
                  return builderResult.individualAttack
             }
             set (value) {
                 builderResult.hasIndividualAttack = true
                 builderResult.individualAttack = value
             }
        }
        public func setIndividualAttack(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.individualAttack = value
          return self
        }
        public func clearIndividualAttack() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasIndividualAttack = false
             builderResult.individualAttack = Int32(0)
             return self
        }
        public var hasIndividualDefense:Bool {
             get {
                  return builderResult.hasIndividualDefense
             }
        }
        public var individualDefense:Int32 {
             get {
                  return builderResult.individualDefense
             }
             set (value) {
                 builderResult.hasIndividualDefense = true
                 builderResult.individualDefense = value
             }
        }
        public func setIndividualDefense(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.individualDefense = value
          return self
        }
        public func clearIndividualDefense() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasIndividualDefense = false
             builderResult.individualDefense = Int32(0)
             return self
        }
        public var hasIndividualStamina:Bool {
             get {
                  return builderResult.hasIndividualStamina
             }
        }
        public var individualStamina:Int32 {
             get {
                  return builderResult.individualStamina
             }
             set (value) {
                 builderResult.hasIndividualStamina = true
                 builderResult.individualStamina = value
             }
        }
        public func setIndividualStamina(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.individualStamina = value
          return self
        }
        public func clearIndividualStamina() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasIndividualStamina = false
             builderResult.individualStamina = Int32(0)
             return self
        }
        public var hasCpMultiplier:Bool {
             get {
                  return builderResult.hasCpMultiplier
             }
        }
        public var cpMultiplier:Int32 {
             get {
                  return builderResult.cpMultiplier
             }
             set (value) {
                 builderResult.hasCpMultiplier = true
                 builderResult.cpMultiplier = value
             }
        }
        public func setCpMultiplier(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.cpMultiplier = value
          return self
        }
        public func clearCpMultiplier() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasCpMultiplier = false
             builderResult.cpMultiplier = Int32(0)
             return self
        }
        public var hasPokeball:Bool {
             get {
                  return builderResult.hasPokeball
             }
        }
        public var pokeball:Int32 {
             get {
                  return builderResult.pokeball
             }
             set (value) {
                 builderResult.hasPokeball = true
                 builderResult.pokeball = value
             }
        }
        public func setPokeball(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.pokeball = value
          return self
        }
        public func clearPokeball() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasPokeball = false
             builderResult.pokeball = Int32(0)
             return self
        }
        public var hasCapturedCellId:Bool {
             get {
                  return builderResult.hasCapturedCellId
             }
        }
        public var capturedCellId:UInt64 {
             get {
                  return builderResult.capturedCellId
             }
             set (value) {
                 builderResult.hasCapturedCellId = true
                 builderResult.capturedCellId = value
             }
        }
        public func setCapturedCellId(value:UInt64) -> ResponseEnvelop.Pokemon.Builder {
          self.capturedCellId = value
          return self
        }
        public func clearCapturedCellId() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasCapturedCellId = false
             builderResult.capturedCellId = UInt64(0)
             return self
        }
        public var hasBattlesAttacked:Bool {
             get {
                  return builderResult.hasBattlesAttacked
             }
        }
        public var battlesAttacked:Int32 {
             get {
                  return builderResult.battlesAttacked
             }
             set (value) {
                 builderResult.hasBattlesAttacked = true
                 builderResult.battlesAttacked = value
             }
        }
        public func setBattlesAttacked(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.battlesAttacked = value
          return self
        }
        public func clearBattlesAttacked() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasBattlesAttacked = false
             builderResult.battlesAttacked = Int32(0)
             return self
        }
        public var hasBattlesDefended:Bool {
             get {
                  return builderResult.hasBattlesDefended
             }
        }
        public var battlesDefended:Int32 {
             get {
                  return builderResult.battlesDefended
             }
             set (value) {
                 builderResult.hasBattlesDefended = true
                 builderResult.battlesDefended = value
             }
        }
        public func setBattlesDefended(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.battlesDefended = value
          return self
        }
        public func clearBattlesDefended() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasBattlesDefended = false
             builderResult.battlesDefended = Int32(0)
             return self
        }
        public var hasEggIncubatorId:Bool {
             get {
                  return builderResult.hasEggIncubatorId
             }
        }
        public var eggIncubatorId:Int32 {
             get {
                  return builderResult.eggIncubatorId
             }
             set (value) {
                 builderResult.hasEggIncubatorId = true
                 builderResult.eggIncubatorId = value
             }
        }
        public func setEggIncubatorId(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.eggIncubatorId = value
          return self
        }
        public func clearEggIncubatorId() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasEggIncubatorId = false
             builderResult.eggIncubatorId = Int32(0)
             return self
        }
        public var hasCreationTimeMs:Bool {
             get {
                  return builderResult.hasCreationTimeMs
             }
        }
        public var creationTimeMs:UInt64 {
             get {
                  return builderResult.creationTimeMs
             }
             set (value) {
                 builderResult.hasCreationTimeMs = true
                 builderResult.creationTimeMs = value
             }
        }
        public func setCreationTimeMs(value:UInt64) -> ResponseEnvelop.Pokemon.Builder {
          self.creationTimeMs = value
          return self
        }
        public func clearCreationTimeMs() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasCreationTimeMs = false
             builderResult.creationTimeMs = UInt64(0)
             return self
        }
        public var hasNumUpgrades:Bool {
             get {
                  return builderResult.hasNumUpgrades
             }
        }
        public var numUpgrades:Int32 {
             get {
                  return builderResult.numUpgrades
             }
             set (value) {
                 builderResult.hasNumUpgrades = true
                 builderResult.numUpgrades = value
             }
        }
        public func setNumUpgrades(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.numUpgrades = value
          return self
        }
        public func clearNumUpgrades() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasNumUpgrades = false
             builderResult.numUpgrades = Int32(0)
             return self
        }
        public var hasAdditionalCpMultiplier:Bool {
             get {
                  return builderResult.hasAdditionalCpMultiplier
             }
        }
        public var additionalCpMultiplier:Int32 {
             get {
                  return builderResult.additionalCpMultiplier
             }
             set (value) {
                 builderResult.hasAdditionalCpMultiplier = true
                 builderResult.additionalCpMultiplier = value
             }
        }
        public func setAdditionalCpMultiplier(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.additionalCpMultiplier = value
          return self
        }
        public func clearAdditionalCpMultiplier() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasAdditionalCpMultiplier = false
             builderResult.additionalCpMultiplier = Int32(0)
             return self
        }
        public var hasFavorite:Bool {
             get {
                  return builderResult.hasFavorite
             }
        }
        public var favorite:Int32 {
             get {
                  return builderResult.favorite
             }
             set (value) {
                 builderResult.hasFavorite = true
                 builderResult.favorite = value
             }
        }
        public func setFavorite(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.favorite = value
          return self
        }
        public func clearFavorite() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasFavorite = false
             builderResult.favorite = Int32(0)
             return self
        }
        public var hasNickname:Bool {
             get {
                  return builderResult.hasNickname
             }
        }
        public var nickname:String {
             get {
                  return builderResult.nickname
             }
             set (value) {
                 builderResult.hasNickname = true
                 builderResult.nickname = value
             }
        }
        public func setNickname(value:String) -> ResponseEnvelop.Pokemon.Builder {
          self.nickname = value
          return self
        }
        public func clearNickname() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasNickname = false
             builderResult.nickname = ""
             return self
        }
        public var hasFromFort:Bool {
             get {
                  return builderResult.hasFromFort
             }
        }
        public var fromFort:Int32 {
             get {
                  return builderResult.fromFort
             }
             set (value) {
                 builderResult.hasFromFort = true
                 builderResult.fromFort = value
             }
        }
        public func setFromFort(value:Int32) -> ResponseEnvelop.Pokemon.Builder {
          self.fromFort = value
          return self
        }
        public func clearFromFort() -> ResponseEnvelop.Pokemon.Builder{
             builderResult.hasFromFort = false
             builderResult.fromFort = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.Pokemon.Builder {
          builderResult = ResponseEnvelop.Pokemon()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.Pokemon.Builder {
          return try ResponseEnvelop.Pokemon.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.Pokemon {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.Pokemon {
          let returnMe:ResponseEnvelop.Pokemon = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.Pokemon) throws -> ResponseEnvelop.Pokemon.Builder {
          if other == ResponseEnvelop.Pokemon() {
           return self
          }
          if other.hasId {
               id = other.id
          }
          if other.hasPokemonType {
               pokemonType = other.pokemonType
          }
          if other.hasCp {
               cp = other.cp
          }
          if other.hasStamina {
               stamina = other.stamina
          }
          if other.hasStaminaMax {
               staminaMax = other.staminaMax
          }
          if other.hasMove1 {
               move1 = other.move1
          }
          if other.hasMove2 {
               move2 = other.move2
          }
          if other.hasDeployedFortId {
               deployedFortId = other.deployedFortId
          }
          if other.hasOwnerName {
               ownerName = other.ownerName
          }
          if other.hasIsEgg {
               isEgg = other.isEgg
          }
          if other.hasEggKmWalkedTarget {
               eggKmWalkedTarget = other.eggKmWalkedTarget
          }
          if other.hasEggKmWalkedStart {
               eggKmWalkedStart = other.eggKmWalkedStart
          }
          if other.hasOrigin {
               origin = other.origin
          }
          if other.hasHeightM {
               heightM = other.heightM
          }
          if other.hasWeightKg {
               weightKg = other.weightKg
          }
          if other.hasIndividualAttack {
               individualAttack = other.individualAttack
          }
          if other.hasIndividualDefense {
               individualDefense = other.individualDefense
          }
          if other.hasIndividualStamina {
               individualStamina = other.individualStamina
          }
          if other.hasCpMultiplier {
               cpMultiplier = other.cpMultiplier
          }
          if other.hasPokeball {
               pokeball = other.pokeball
          }
          if other.hasCapturedCellId {
               capturedCellId = other.capturedCellId
          }
          if other.hasBattlesAttacked {
               battlesAttacked = other.battlesAttacked
          }
          if other.hasBattlesDefended {
               battlesDefended = other.battlesDefended
          }
          if other.hasEggIncubatorId {
               eggIncubatorId = other.eggIncubatorId
          }
          if other.hasCreationTimeMs {
               creationTimeMs = other.creationTimeMs
          }
          if other.hasNumUpgrades {
               numUpgrades = other.numUpgrades
          }
          if other.hasAdditionalCpMultiplier {
               additionalCpMultiplier = other.additionalCpMultiplier
          }
          if other.hasFavorite {
               favorite = other.favorite
          }
          if other.hasNickname {
               nickname = other.nickname
          }
          if other.hasFromFort {
               fromFort = other.fromFort
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Pokemon.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Pokemon.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              id = try input.readInt32()

            case 16 :
              let valueIntpokemonType = try input.readEnum()
              if let enumspokemonType = ResponseEnvelop.PokemonId(rawValue:valueIntpokemonType){
                   pokemonType = enumspokemonType
              } else {
                   try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntpokemonType))
              }

            case 24 :
              cp = try input.readInt32()

            case 32 :
              stamina = try input.readInt32()

            case 40 :
              staminaMax = try input.readInt32()

            case 48 :
              let valueIntmove1 = try input.readEnum()
              if let enumsmove1 = ResponseEnvelop.PokemonMove(rawValue:valueIntmove1){
                   move1 = enumsmove1
              } else {
                   try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntmove1))
              }

            case 56 :
              let valueIntmove2 = try input.readEnum()
              if let enumsmove2 = ResponseEnvelop.PokemonMove(rawValue:valueIntmove2){
                   move2 = enumsmove2
              } else {
                   try unknownFieldsBuilder.mergeVarintField(7, value:Int64(valueIntmove2))
              }

            case 66 :
              deployedFortId = try input.readString()

            case 74 :
              ownerName = try input.readString()

            case 80 :
              isEgg = try input.readBool()

            case 88 :
              eggKmWalkedTarget = try input.readInt32()

            case 96 :
              eggKmWalkedStart = try input.readInt32()

            case 112 :
              origin = try input.readInt32()

            case 125 :
              heightM = try input.readFloat()

            case 133 :
              weightKg = try input.readFloat()

            case 136 :
              individualAttack = try input.readInt32()

            case 144 :
              individualDefense = try input.readInt32()

            case 152 :
              individualStamina = try input.readInt32()

            case 160 :
              cpMultiplier = try input.readInt32()

            case 168 :
              pokeball = try input.readInt32()

            case 176 :
              capturedCellId = try input.readUInt64()

            case 184 :
              battlesAttacked = try input.readInt32()

            case 192 :
              battlesDefended = try input.readInt32()

            case 200 :
              eggIncubatorId = try input.readInt32()

            case 208 :
              creationTimeMs = try input.readUInt64()

            case 216 :
              numUpgrades = try input.readInt32()

            case 224 :
              additionalCpMultiplier = try input.readInt32()

            case 232 :
              favorite = try input.readInt32()

            case 242 :
              nickname = try input.readString()

            case 248 :
              fromFort = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class Item : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var item:ResponseEnvelop.ItemType = ResponseEnvelop.ItemType.ItemTypeNone
      public private(set) var hasItem:Bool = false
      public private(set) var count:Int32 = Int32(0)

      public private(set) var hasCount:Bool = false
      public private(set) var unseen:Bool = false

      public private(set) var hasUnseen:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasItem {
          try output.writeEnum(1, value:item.rawValue)
        }
        if hasCount {
          try output.writeInt32(2, value:count)
        }
        if hasUnseen {
          try output.writeBool(3, value:unseen)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasItem) {
          serialize_size += item.rawValue.computeEnumSize(1)
        }
        if hasCount {
          serialize_size += count.computeInt32Size(2)
        }
        if hasUnseen {
          serialize_size += unseen.computeBoolSize(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.Item> {
        var mergedArray = Array<ResponseEnvelop.Item>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Item? {
        return try ResponseEnvelop.Item.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.Item {
        return try ResponseEnvelop.Item.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Item {
        return try ResponseEnvelop.Item.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.Item {
        return try ResponseEnvelop.Item.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Item {
        return try ResponseEnvelop.Item.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Item {
        return try ResponseEnvelop.Item.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Item {
        return try ResponseEnvelop.Item.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.Item.Builder {
        return ResponseEnvelop.Item.classBuilder() as! ResponseEnvelop.Item.Builder
      }
      public func getBuilder() -> ResponseEnvelop.Item.Builder {
        return classBuilder() as! ResponseEnvelop.Item.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.Item.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.Item.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.Item.Builder {
        return try ResponseEnvelop.Item.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.Item) throws -> ResponseEnvelop.Item.Builder {
        return try ResponseEnvelop.Item.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasItem) {
          output += "\(indent) item: \(item.description)\n"
        }
        if hasCount {
          output += "\(indent) count: \(count) \n"
        }
        if hasUnseen {
          output += "\(indent) unseen: \(unseen) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasItem {
                 hashCode = (hashCode &* 31) &+ Int(item.rawValue)
              }
              if hasCount {
                 hashCode = (hashCode &* 31) &+ count.hashValue
              }
              if hasUnseen {
                 hashCode = (hashCode &* 31) &+ unseen.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.Item"
      }
      override public func className() -> String {
          return "ResponseEnvelop.Item"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.Item.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.Item = ResponseEnvelop.Item()
        public func getMessage() -> ResponseEnvelop.Item {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasItem:Bool{
              get {
                  return builderResult.hasItem
              }
          }
          public var item:ResponseEnvelop.ItemType {
              get {
                  return builderResult.item
              }
              set (value) {
                  builderResult.hasItem = true
                  builderResult.item = value
              }
          }
          public func setItem(value:ResponseEnvelop.ItemType) -> ResponseEnvelop.Item.Builder {
            self.item = value
            return self
          }
          public func clearItem() -> ResponseEnvelop.Item.Builder {
             builderResult.hasItem = false
             builderResult.item = .ItemTypeNone
             return self
          }
        public var hasCount:Bool {
             get {
                  return builderResult.hasCount
             }
        }
        public var count:Int32 {
             get {
                  return builderResult.count
             }
             set (value) {
                 builderResult.hasCount = true
                 builderResult.count = value
             }
        }
        public func setCount(value:Int32) -> ResponseEnvelop.Item.Builder {
          self.count = value
          return self
        }
        public func clearCount() -> ResponseEnvelop.Item.Builder{
             builderResult.hasCount = false
             builderResult.count = Int32(0)
             return self
        }
        public var hasUnseen:Bool {
             get {
                  return builderResult.hasUnseen
             }
        }
        public var unseen:Bool {
             get {
                  return builderResult.unseen
             }
             set (value) {
                 builderResult.hasUnseen = true
                 builderResult.unseen = value
             }
        }
        public func setUnseen(value:Bool) -> ResponseEnvelop.Item.Builder {
          self.unseen = value
          return self
        }
        public func clearUnseen() -> ResponseEnvelop.Item.Builder{
             builderResult.hasUnseen = false
             builderResult.unseen = false
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.Item.Builder {
          builderResult = ResponseEnvelop.Item()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.Item.Builder {
          return try ResponseEnvelop.Item.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.Item {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.Item {
          let returnMe:ResponseEnvelop.Item = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.Item) throws -> ResponseEnvelop.Item.Builder {
          if other == ResponseEnvelop.Item() {
           return self
          }
          if other.hasItem {
               item = other.item
          }
          if other.hasCount {
               count = other.count
          }
          if other.hasUnseen {
               unseen = other.unseen
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Item.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Item.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntitem = try input.readEnum()
              if let enumsitem = ResponseEnvelop.ItemType(rawValue:valueIntitem){
                   item = enumsitem
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntitem))
              }

            case 16 :
              count = try input.readInt32()

            case 24 :
              unseen = try input.readBool()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class PokedexEntry : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var pokedexEntryNumber:Int32 = Int32(0)

      public private(set) var hasPokedexEntryNumber:Bool = false
      public private(set) var timesEncountered:Int32 = Int32(0)

      public private(set) var hasTimesEncountered:Bool = false
      public private(set) var timesCaptured:Int32 = Int32(0)

      public private(set) var hasTimesCaptured:Bool = false
      public private(set) var evolutionStonePieces:Int32 = Int32(0)

      public private(set) var hasEvolutionStonePieces:Bool = false
      public private(set) var evolutionStones:Int32 = Int32(0)

      public private(set) var hasEvolutionStones:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasPokedexEntryNumber {
          try output.writeInt32(1, value:pokedexEntryNumber)
        }
        if hasTimesEncountered {
          try output.writeInt32(2, value:timesEncountered)
        }
        if hasTimesCaptured {
          try output.writeInt32(3, value:timesCaptured)
        }
        if hasEvolutionStonePieces {
          try output.writeInt32(4, value:evolutionStonePieces)
        }
        if hasEvolutionStones {
          try output.writeInt32(5, value:evolutionStones)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasPokedexEntryNumber {
          serialize_size += pokedexEntryNumber.computeInt32Size(1)
        }
        if hasTimesEncountered {
          serialize_size += timesEncountered.computeInt32Size(2)
        }
        if hasTimesCaptured {
          serialize_size += timesCaptured.computeInt32Size(3)
        }
        if hasEvolutionStonePieces {
          serialize_size += evolutionStonePieces.computeInt32Size(4)
        }
        if hasEvolutionStones {
          serialize_size += evolutionStones.computeInt32Size(5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.PokedexEntry> {
        var mergedArray = Array<ResponseEnvelop.PokedexEntry>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokedexEntry? {
        return try ResponseEnvelop.PokedexEntry.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.PokedexEntry {
        return try ResponseEnvelop.PokedexEntry.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokedexEntry {
        return try ResponseEnvelop.PokedexEntry.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokedexEntry {
        return try ResponseEnvelop.PokedexEntry.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokedexEntry {
        return try ResponseEnvelop.PokedexEntry.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokedexEntry {
        return try ResponseEnvelop.PokedexEntry.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokedexEntry {
        return try ResponseEnvelop.PokedexEntry.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.PokedexEntry.Builder {
        return ResponseEnvelop.PokedexEntry.classBuilder() as! ResponseEnvelop.PokedexEntry.Builder
      }
      public func getBuilder() -> ResponseEnvelop.PokedexEntry.Builder {
        return classBuilder() as! ResponseEnvelop.PokedexEntry.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokedexEntry.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokedexEntry.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.PokedexEntry.Builder {
        return try ResponseEnvelop.PokedexEntry.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.PokedexEntry) throws -> ResponseEnvelop.PokedexEntry.Builder {
        return try ResponseEnvelop.PokedexEntry.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasPokedexEntryNumber {
          output += "\(indent) pokedexEntryNumber: \(pokedexEntryNumber) \n"
        }
        if hasTimesEncountered {
          output += "\(indent) timesEncountered: \(timesEncountered) \n"
        }
        if hasTimesCaptured {
          output += "\(indent) timesCaptured: \(timesCaptured) \n"
        }
        if hasEvolutionStonePieces {
          output += "\(indent) evolutionStonePieces: \(evolutionStonePieces) \n"
        }
        if hasEvolutionStones {
          output += "\(indent) evolutionStones: \(evolutionStones) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasPokedexEntryNumber {
                 hashCode = (hashCode &* 31) &+ pokedexEntryNumber.hashValue
              }
              if hasTimesEncountered {
                 hashCode = (hashCode &* 31) &+ timesEncountered.hashValue
              }
              if hasTimesCaptured {
                 hashCode = (hashCode &* 31) &+ timesCaptured.hashValue
              }
              if hasEvolutionStonePieces {
                 hashCode = (hashCode &* 31) &+ evolutionStonePieces.hashValue
              }
              if hasEvolutionStones {
                 hashCode = (hashCode &* 31) &+ evolutionStones.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.PokedexEntry"
      }
      override public func className() -> String {
          return "ResponseEnvelop.PokedexEntry"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.PokedexEntry.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.PokedexEntry = ResponseEnvelop.PokedexEntry()
        public func getMessage() -> ResponseEnvelop.PokedexEntry {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasPokedexEntryNumber:Bool {
             get {
                  return builderResult.hasPokedexEntryNumber
             }
        }
        public var pokedexEntryNumber:Int32 {
             get {
                  return builderResult.pokedexEntryNumber
             }
             set (value) {
                 builderResult.hasPokedexEntryNumber = true
                 builderResult.pokedexEntryNumber = value
             }
        }
        public func setPokedexEntryNumber(value:Int32) -> ResponseEnvelop.PokedexEntry.Builder {
          self.pokedexEntryNumber = value
          return self
        }
        public func clearPokedexEntryNumber() -> ResponseEnvelop.PokedexEntry.Builder{
             builderResult.hasPokedexEntryNumber = false
             builderResult.pokedexEntryNumber = Int32(0)
             return self
        }
        public var hasTimesEncountered:Bool {
             get {
                  return builderResult.hasTimesEncountered
             }
        }
        public var timesEncountered:Int32 {
             get {
                  return builderResult.timesEncountered
             }
             set (value) {
                 builderResult.hasTimesEncountered = true
                 builderResult.timesEncountered = value
             }
        }
        public func setTimesEncountered(value:Int32) -> ResponseEnvelop.PokedexEntry.Builder {
          self.timesEncountered = value
          return self
        }
        public func clearTimesEncountered() -> ResponseEnvelop.PokedexEntry.Builder{
             builderResult.hasTimesEncountered = false
             builderResult.timesEncountered = Int32(0)
             return self
        }
        public var hasTimesCaptured:Bool {
             get {
                  return builderResult.hasTimesCaptured
             }
        }
        public var timesCaptured:Int32 {
             get {
                  return builderResult.timesCaptured
             }
             set (value) {
                 builderResult.hasTimesCaptured = true
                 builderResult.timesCaptured = value
             }
        }
        public func setTimesCaptured(value:Int32) -> ResponseEnvelop.PokedexEntry.Builder {
          self.timesCaptured = value
          return self
        }
        public func clearTimesCaptured() -> ResponseEnvelop.PokedexEntry.Builder{
             builderResult.hasTimesCaptured = false
             builderResult.timesCaptured = Int32(0)
             return self
        }
        public var hasEvolutionStonePieces:Bool {
             get {
                  return builderResult.hasEvolutionStonePieces
             }
        }
        public var evolutionStonePieces:Int32 {
             get {
                  return builderResult.evolutionStonePieces
             }
             set (value) {
                 builderResult.hasEvolutionStonePieces = true
                 builderResult.evolutionStonePieces = value
             }
        }
        public func setEvolutionStonePieces(value:Int32) -> ResponseEnvelop.PokedexEntry.Builder {
          self.evolutionStonePieces = value
          return self
        }
        public func clearEvolutionStonePieces() -> ResponseEnvelop.PokedexEntry.Builder{
             builderResult.hasEvolutionStonePieces = false
             builderResult.evolutionStonePieces = Int32(0)
             return self
        }
        public var hasEvolutionStones:Bool {
             get {
                  return builderResult.hasEvolutionStones
             }
        }
        public var evolutionStones:Int32 {
             get {
                  return builderResult.evolutionStones
             }
             set (value) {
                 builderResult.hasEvolutionStones = true
                 builderResult.evolutionStones = value
             }
        }
        public func setEvolutionStones(value:Int32) -> ResponseEnvelop.PokedexEntry.Builder {
          self.evolutionStones = value
          return self
        }
        public func clearEvolutionStones() -> ResponseEnvelop.PokedexEntry.Builder{
             builderResult.hasEvolutionStones = false
             builderResult.evolutionStones = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.PokedexEntry.Builder {
          builderResult = ResponseEnvelop.PokedexEntry()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.PokedexEntry.Builder {
          return try ResponseEnvelop.PokedexEntry.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.PokedexEntry {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.PokedexEntry {
          let returnMe:ResponseEnvelop.PokedexEntry = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.PokedexEntry) throws -> ResponseEnvelop.PokedexEntry.Builder {
          if other == ResponseEnvelop.PokedexEntry() {
           return self
          }
          if other.hasPokedexEntryNumber {
               pokedexEntryNumber = other.pokedexEntryNumber
          }
          if other.hasTimesEncountered {
               timesEncountered = other.timesEncountered
          }
          if other.hasTimesCaptured {
               timesCaptured = other.timesCaptured
          }
          if other.hasEvolutionStonePieces {
               evolutionStonePieces = other.evolutionStonePieces
          }
          if other.hasEvolutionStones {
               evolutionStones = other.evolutionStones
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokedexEntry.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokedexEntry.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              pokedexEntryNumber = try input.readInt32()

            case 16 :
              timesEncountered = try input.readInt32()

            case 24 :
              timesCaptured = try input.readInt32()

            case 32 :
              evolutionStonePieces = try input.readInt32()

            case 40 :
              evolutionStones = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class PlayerStats : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var level:Int32 = Int32(0)

      public private(set) var hasLevel:Bool = false
      public private(set) var experience:Int64 = Int64(0)

      public private(set) var hasExperience:Bool = false
      public private(set) var prevLevelXp:Int64 = Int64(0)

      public private(set) var hasPrevLevelXp:Bool = false
      public private(set) var nextLevelXp:Int64 = Int64(0)

      public private(set) var hasNextLevelXp:Bool = false
      public private(set) var kmWalked:Float = Float(0)

      public private(set) var hasKmWalked:Bool = false
      public private(set) var pokemonsEncountered:Int32 = Int32(0)

      public private(set) var hasPokemonsEncountered:Bool = false
      public private(set) var uniquePokedexEntries:Int32 = Int32(0)

      public private(set) var hasUniquePokedexEntries:Bool = false
      public private(set) var pokemonsCaptured:Int32 = Int32(0)

      public private(set) var hasPokemonsCaptured:Bool = false
      public private(set) var evolutions:Int32 = Int32(0)

      public private(set) var hasEvolutions:Bool = false
      public private(set) var pokeStopVisits:Int32 = Int32(0)

      public private(set) var hasPokeStopVisits:Bool = false
      public private(set) var pokeballsThrown:Int32 = Int32(0)

      public private(set) var hasPokeballsThrown:Bool = false
      public private(set) var eggsHatched:Int32 = Int32(0)

      public private(set) var hasEggsHatched:Bool = false
      public private(set) var bigMagikarpCaught:Int32 = Int32(0)

      public private(set) var hasBigMagikarpCaught:Bool = false
      public private(set) var battleAttackWon:Int32 = Int32(0)

      public private(set) var hasBattleAttackWon:Bool = false
      public private(set) var battleAttackTotal:Int32 = Int32(0)

      public private(set) var hasBattleAttackTotal:Bool = false
      public private(set) var battleDefendedWon:Int32 = Int32(0)

      public private(set) var hasBattleDefendedWon:Bool = false
      public private(set) var battleTrainingWon:Int32 = Int32(0)

      public private(set) var hasBattleTrainingWon:Bool = false
      public private(set) var battleTrainingTotal:Int32 = Int32(0)

      public private(set) var hasBattleTrainingTotal:Bool = false
      public private(set) var prestigeRaisedTotal:Int32 = Int32(0)

      public private(set) var hasPrestigeRaisedTotal:Bool = false
      public private(set) var prestigeDroppedTotal:Int32 = Int32(0)

      public private(set) var hasPrestigeDroppedTotal:Bool = false
      public private(set) var pokemonDeployed:Int32 = Int32(0)

      public private(set) var hasPokemonDeployed:Bool = false
      // TODO: repeated PokemonType ??
      public private(set) var pokemonCaughtByType:NSData = NSData()

      public private(set) var hasPokemonCaughtByType:Bool = false
      public private(set) var smallRattataCaught:Int32 = Int32(0)

      public private(set) var hasSmallRattataCaught:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasLevel {
          try output.writeInt32(1, value:level)
        }
        if hasExperience {
          try output.writeInt64(2, value:experience)
        }
        if hasPrevLevelXp {
          try output.writeInt64(3, value:prevLevelXp)
        }
        if hasNextLevelXp {
          try output.writeInt64(4, value:nextLevelXp)
        }
        if hasKmWalked {
          try output.writeFloat(5, value:kmWalked)
        }
        if hasPokemonsEncountered {
          try output.writeInt32(6, value:pokemonsEncountered)
        }
        if hasUniquePokedexEntries {
          try output.writeInt32(7, value:uniquePokedexEntries)
        }
        if hasPokemonsCaptured {
          try output.writeInt32(8, value:pokemonsCaptured)
        }
        if hasEvolutions {
          try output.writeInt32(9, value:evolutions)
        }
        if hasPokeStopVisits {
          try output.writeInt32(10, value:pokeStopVisits)
        }
        if hasPokeballsThrown {
          try output.writeInt32(11, value:pokeballsThrown)
        }
        if hasEggsHatched {
          try output.writeInt32(12, value:eggsHatched)
        }
        if hasBigMagikarpCaught {
          try output.writeInt32(13, value:bigMagikarpCaught)
        }
        if hasBattleAttackWon {
          try output.writeInt32(14, value:battleAttackWon)
        }
        if hasBattleAttackTotal {
          try output.writeInt32(15, value:battleAttackTotal)
        }
        if hasBattleDefendedWon {
          try output.writeInt32(16, value:battleDefendedWon)
        }
        if hasBattleTrainingWon {
          try output.writeInt32(17, value:battleTrainingWon)
        }
        if hasBattleTrainingTotal {
          try output.writeInt32(18, value:battleTrainingTotal)
        }
        if hasPrestigeRaisedTotal {
          try output.writeInt32(19, value:prestigeRaisedTotal)
        }
        if hasPrestigeDroppedTotal {
          try output.writeInt32(20, value:prestigeDroppedTotal)
        }
        if hasPokemonDeployed {
          try output.writeInt32(21, value:pokemonDeployed)
        }
        if hasPokemonCaughtByType {
          try output.writeData(22, value:pokemonCaughtByType)
        }
        if hasSmallRattataCaught {
          try output.writeInt32(23, value:smallRattataCaught)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasLevel {
          serialize_size += level.computeInt32Size(1)
        }
        if hasExperience {
          serialize_size += experience.computeInt64Size(2)
        }
        if hasPrevLevelXp {
          serialize_size += prevLevelXp.computeInt64Size(3)
        }
        if hasNextLevelXp {
          serialize_size += nextLevelXp.computeInt64Size(4)
        }
        if hasKmWalked {
          serialize_size += kmWalked.computeFloatSize(5)
        }
        if hasPokemonsEncountered {
          serialize_size += pokemonsEncountered.computeInt32Size(6)
        }
        if hasUniquePokedexEntries {
          serialize_size += uniquePokedexEntries.computeInt32Size(7)
        }
        if hasPokemonsCaptured {
          serialize_size += pokemonsCaptured.computeInt32Size(8)
        }
        if hasEvolutions {
          serialize_size += evolutions.computeInt32Size(9)
        }
        if hasPokeStopVisits {
          serialize_size += pokeStopVisits.computeInt32Size(10)
        }
        if hasPokeballsThrown {
          serialize_size += pokeballsThrown.computeInt32Size(11)
        }
        if hasEggsHatched {
          serialize_size += eggsHatched.computeInt32Size(12)
        }
        if hasBigMagikarpCaught {
          serialize_size += bigMagikarpCaught.computeInt32Size(13)
        }
        if hasBattleAttackWon {
          serialize_size += battleAttackWon.computeInt32Size(14)
        }
        if hasBattleAttackTotal {
          serialize_size += battleAttackTotal.computeInt32Size(15)
        }
        if hasBattleDefendedWon {
          serialize_size += battleDefendedWon.computeInt32Size(16)
        }
        if hasBattleTrainingWon {
          serialize_size += battleTrainingWon.computeInt32Size(17)
        }
        if hasBattleTrainingTotal {
          serialize_size += battleTrainingTotal.computeInt32Size(18)
        }
        if hasPrestigeRaisedTotal {
          serialize_size += prestigeRaisedTotal.computeInt32Size(19)
        }
        if hasPrestigeDroppedTotal {
          serialize_size += prestigeDroppedTotal.computeInt32Size(20)
        }
        if hasPokemonDeployed {
          serialize_size += pokemonDeployed.computeInt32Size(21)
        }
        if hasPokemonCaughtByType {
          serialize_size += pokemonCaughtByType.computeDataSize(22)
        }
        if hasSmallRattataCaught {
          serialize_size += smallRattataCaught.computeInt32Size(23)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.PlayerStats> {
        var mergedArray = Array<ResponseEnvelop.PlayerStats>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PlayerStats? {
        return try ResponseEnvelop.PlayerStats.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.PlayerStats {
        return try ResponseEnvelop.PlayerStats.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerStats {
        return try ResponseEnvelop.PlayerStats.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PlayerStats {
        return try ResponseEnvelop.PlayerStats.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerStats {
        return try ResponseEnvelop.PlayerStats.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PlayerStats {
        return try ResponseEnvelop.PlayerStats.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerStats {
        return try ResponseEnvelop.PlayerStats.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.PlayerStats.Builder {
        return ResponseEnvelop.PlayerStats.classBuilder() as! ResponseEnvelop.PlayerStats.Builder
      }
      public func getBuilder() -> ResponseEnvelop.PlayerStats.Builder {
        return classBuilder() as! ResponseEnvelop.PlayerStats.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PlayerStats.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PlayerStats.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.PlayerStats.Builder {
        return try ResponseEnvelop.PlayerStats.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.PlayerStats) throws -> ResponseEnvelop.PlayerStats.Builder {
        return try ResponseEnvelop.PlayerStats.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasLevel {
          output += "\(indent) level: \(level) \n"
        }
        if hasExperience {
          output += "\(indent) experience: \(experience) \n"
        }
        if hasPrevLevelXp {
          output += "\(indent) prevLevelXp: \(prevLevelXp) \n"
        }
        if hasNextLevelXp {
          output += "\(indent) nextLevelXp: \(nextLevelXp) \n"
        }
        if hasKmWalked {
          output += "\(indent) kmWalked: \(kmWalked) \n"
        }
        if hasPokemonsEncountered {
          output += "\(indent) pokemonsEncountered: \(pokemonsEncountered) \n"
        }
        if hasUniquePokedexEntries {
          output += "\(indent) uniquePokedexEntries: \(uniquePokedexEntries) \n"
        }
        if hasPokemonsCaptured {
          output += "\(indent) pokemonsCaptured: \(pokemonsCaptured) \n"
        }
        if hasEvolutions {
          output += "\(indent) evolutions: \(evolutions) \n"
        }
        if hasPokeStopVisits {
          output += "\(indent) pokeStopVisits: \(pokeStopVisits) \n"
        }
        if hasPokeballsThrown {
          output += "\(indent) pokeballsThrown: \(pokeballsThrown) \n"
        }
        if hasEggsHatched {
          output += "\(indent) eggsHatched: \(eggsHatched) \n"
        }
        if hasBigMagikarpCaught {
          output += "\(indent) bigMagikarpCaught: \(bigMagikarpCaught) \n"
        }
        if hasBattleAttackWon {
          output += "\(indent) battleAttackWon: \(battleAttackWon) \n"
        }
        if hasBattleAttackTotal {
          output += "\(indent) battleAttackTotal: \(battleAttackTotal) \n"
        }
        if hasBattleDefendedWon {
          output += "\(indent) battleDefendedWon: \(battleDefendedWon) \n"
        }
        if hasBattleTrainingWon {
          output += "\(indent) battleTrainingWon: \(battleTrainingWon) \n"
        }
        if hasBattleTrainingTotal {
          output += "\(indent) battleTrainingTotal: \(battleTrainingTotal) \n"
        }
        if hasPrestigeRaisedTotal {
          output += "\(indent) prestigeRaisedTotal: \(prestigeRaisedTotal) \n"
        }
        if hasPrestigeDroppedTotal {
          output += "\(indent) prestigeDroppedTotal: \(prestigeDroppedTotal) \n"
        }
        if hasPokemonDeployed {
          output += "\(indent) pokemonDeployed: \(pokemonDeployed) \n"
        }
        if hasPokemonCaughtByType {
          output += "\(indent) pokemonCaughtByType: \(pokemonCaughtByType) \n"
        }
        if hasSmallRattataCaught {
          output += "\(indent) smallRattataCaught: \(smallRattataCaught) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasLevel {
                 hashCode = (hashCode &* 31) &+ level.hashValue
              }
              if hasExperience {
                 hashCode = (hashCode &* 31) &+ experience.hashValue
              }
              if hasPrevLevelXp {
                 hashCode = (hashCode &* 31) &+ prevLevelXp.hashValue
              }
              if hasNextLevelXp {
                 hashCode = (hashCode &* 31) &+ nextLevelXp.hashValue
              }
              if hasKmWalked {
                 hashCode = (hashCode &* 31) &+ kmWalked.hashValue
              }
              if hasPokemonsEncountered {
                 hashCode = (hashCode &* 31) &+ pokemonsEncountered.hashValue
              }
              if hasUniquePokedexEntries {
                 hashCode = (hashCode &* 31) &+ uniquePokedexEntries.hashValue
              }
              if hasPokemonsCaptured {
                 hashCode = (hashCode &* 31) &+ pokemonsCaptured.hashValue
              }
              if hasEvolutions {
                 hashCode = (hashCode &* 31) &+ evolutions.hashValue
              }
              if hasPokeStopVisits {
                 hashCode = (hashCode &* 31) &+ pokeStopVisits.hashValue
              }
              if hasPokeballsThrown {
                 hashCode = (hashCode &* 31) &+ pokeballsThrown.hashValue
              }
              if hasEggsHatched {
                 hashCode = (hashCode &* 31) &+ eggsHatched.hashValue
              }
              if hasBigMagikarpCaught {
                 hashCode = (hashCode &* 31) &+ bigMagikarpCaught.hashValue
              }
              if hasBattleAttackWon {
                 hashCode = (hashCode &* 31) &+ battleAttackWon.hashValue
              }
              if hasBattleAttackTotal {
                 hashCode = (hashCode &* 31) &+ battleAttackTotal.hashValue
              }
              if hasBattleDefendedWon {
                 hashCode = (hashCode &* 31) &+ battleDefendedWon.hashValue
              }
              if hasBattleTrainingWon {
                 hashCode = (hashCode &* 31) &+ battleTrainingWon.hashValue
              }
              if hasBattleTrainingTotal {
                 hashCode = (hashCode &* 31) &+ battleTrainingTotal.hashValue
              }
              if hasPrestigeRaisedTotal {
                 hashCode = (hashCode &* 31) &+ prestigeRaisedTotal.hashValue
              }
              if hasPrestigeDroppedTotal {
                 hashCode = (hashCode &* 31) &+ prestigeDroppedTotal.hashValue
              }
              if hasPokemonDeployed {
                 hashCode = (hashCode &* 31) &+ pokemonDeployed.hashValue
              }
              if hasPokemonCaughtByType {
                 hashCode = (hashCode &* 31) &+ pokemonCaughtByType.hashValue
              }
              if hasSmallRattataCaught {
                 hashCode = (hashCode &* 31) &+ smallRattataCaught.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.PlayerStats"
      }
      override public func className() -> String {
          return "ResponseEnvelop.PlayerStats"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.PlayerStats.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.PlayerStats = ResponseEnvelop.PlayerStats()
        public func getMessage() -> ResponseEnvelop.PlayerStats {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasLevel:Bool {
             get {
                  return builderResult.hasLevel
             }
        }
        public var level:Int32 {
             get {
                  return builderResult.level
             }
             set (value) {
                 builderResult.hasLevel = true
                 builderResult.level = value
             }
        }
        public func setLevel(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.level = value
          return self
        }
        public func clearLevel() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasLevel = false
             builderResult.level = Int32(0)
             return self
        }
        public var hasExperience:Bool {
             get {
                  return builderResult.hasExperience
             }
        }
        public var experience:Int64 {
             get {
                  return builderResult.experience
             }
             set (value) {
                 builderResult.hasExperience = true
                 builderResult.experience = value
             }
        }
        public func setExperience(value:Int64) -> ResponseEnvelop.PlayerStats.Builder {
          self.experience = value
          return self
        }
        public func clearExperience() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasExperience = false
             builderResult.experience = Int64(0)
             return self
        }
        public var hasPrevLevelXp:Bool {
             get {
                  return builderResult.hasPrevLevelXp
             }
        }
        public var prevLevelXp:Int64 {
             get {
                  return builderResult.prevLevelXp
             }
             set (value) {
                 builderResult.hasPrevLevelXp = true
                 builderResult.prevLevelXp = value
             }
        }
        public func setPrevLevelXp(value:Int64) -> ResponseEnvelop.PlayerStats.Builder {
          self.prevLevelXp = value
          return self
        }
        public func clearPrevLevelXp() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPrevLevelXp = false
             builderResult.prevLevelXp = Int64(0)
             return self
        }
        public var hasNextLevelXp:Bool {
             get {
                  return builderResult.hasNextLevelXp
             }
        }
        public var nextLevelXp:Int64 {
             get {
                  return builderResult.nextLevelXp
             }
             set (value) {
                 builderResult.hasNextLevelXp = true
                 builderResult.nextLevelXp = value
             }
        }
        public func setNextLevelXp(value:Int64) -> ResponseEnvelop.PlayerStats.Builder {
          self.nextLevelXp = value
          return self
        }
        public func clearNextLevelXp() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasNextLevelXp = false
             builderResult.nextLevelXp = Int64(0)
             return self
        }
        public var hasKmWalked:Bool {
             get {
                  return builderResult.hasKmWalked
             }
        }
        public var kmWalked:Float {
             get {
                  return builderResult.kmWalked
             }
             set (value) {
                 builderResult.hasKmWalked = true
                 builderResult.kmWalked = value
             }
        }
        public func setKmWalked(value:Float) -> ResponseEnvelop.PlayerStats.Builder {
          self.kmWalked = value
          return self
        }
        public func clearKmWalked() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasKmWalked = false
             builderResult.kmWalked = Float(0)
             return self
        }
        public var hasPokemonsEncountered:Bool {
             get {
                  return builderResult.hasPokemonsEncountered
             }
        }
        public var pokemonsEncountered:Int32 {
             get {
                  return builderResult.pokemonsEncountered
             }
             set (value) {
                 builderResult.hasPokemonsEncountered = true
                 builderResult.pokemonsEncountered = value
             }
        }
        public func setPokemonsEncountered(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.pokemonsEncountered = value
          return self
        }
        public func clearPokemonsEncountered() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPokemonsEncountered = false
             builderResult.pokemonsEncountered = Int32(0)
             return self
        }
        public var hasUniquePokedexEntries:Bool {
             get {
                  return builderResult.hasUniquePokedexEntries
             }
        }
        public var uniquePokedexEntries:Int32 {
             get {
                  return builderResult.uniquePokedexEntries
             }
             set (value) {
                 builderResult.hasUniquePokedexEntries = true
                 builderResult.uniquePokedexEntries = value
             }
        }
        public func setUniquePokedexEntries(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.uniquePokedexEntries = value
          return self
        }
        public func clearUniquePokedexEntries() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasUniquePokedexEntries = false
             builderResult.uniquePokedexEntries = Int32(0)
             return self
        }
        public var hasPokemonsCaptured:Bool {
             get {
                  return builderResult.hasPokemonsCaptured
             }
        }
        public var pokemonsCaptured:Int32 {
             get {
                  return builderResult.pokemonsCaptured
             }
             set (value) {
                 builderResult.hasPokemonsCaptured = true
                 builderResult.pokemonsCaptured = value
             }
        }
        public func setPokemonsCaptured(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.pokemonsCaptured = value
          return self
        }
        public func clearPokemonsCaptured() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPokemonsCaptured = false
             builderResult.pokemonsCaptured = Int32(0)
             return self
        }
        public var hasEvolutions:Bool {
             get {
                  return builderResult.hasEvolutions
             }
        }
        public var evolutions:Int32 {
             get {
                  return builderResult.evolutions
             }
             set (value) {
                 builderResult.hasEvolutions = true
                 builderResult.evolutions = value
             }
        }
        public func setEvolutions(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.evolutions = value
          return self
        }
        public func clearEvolutions() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasEvolutions = false
             builderResult.evolutions = Int32(0)
             return self
        }
        public var hasPokeStopVisits:Bool {
             get {
                  return builderResult.hasPokeStopVisits
             }
        }
        public var pokeStopVisits:Int32 {
             get {
                  return builderResult.pokeStopVisits
             }
             set (value) {
                 builderResult.hasPokeStopVisits = true
                 builderResult.pokeStopVisits = value
             }
        }
        public func setPokeStopVisits(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.pokeStopVisits = value
          return self
        }
        public func clearPokeStopVisits() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPokeStopVisits = false
             builderResult.pokeStopVisits = Int32(0)
             return self
        }
        public var hasPokeballsThrown:Bool {
             get {
                  return builderResult.hasPokeballsThrown
             }
        }
        public var pokeballsThrown:Int32 {
             get {
                  return builderResult.pokeballsThrown
             }
             set (value) {
                 builderResult.hasPokeballsThrown = true
                 builderResult.pokeballsThrown = value
             }
        }
        public func setPokeballsThrown(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.pokeballsThrown = value
          return self
        }
        public func clearPokeballsThrown() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPokeballsThrown = false
             builderResult.pokeballsThrown = Int32(0)
             return self
        }
        public var hasEggsHatched:Bool {
             get {
                  return builderResult.hasEggsHatched
             }
        }
        public var eggsHatched:Int32 {
             get {
                  return builderResult.eggsHatched
             }
             set (value) {
                 builderResult.hasEggsHatched = true
                 builderResult.eggsHatched = value
             }
        }
        public func setEggsHatched(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.eggsHatched = value
          return self
        }
        public func clearEggsHatched() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasEggsHatched = false
             builderResult.eggsHatched = Int32(0)
             return self
        }
        public var hasBigMagikarpCaught:Bool {
             get {
                  return builderResult.hasBigMagikarpCaught
             }
        }
        public var bigMagikarpCaught:Int32 {
             get {
                  return builderResult.bigMagikarpCaught
             }
             set (value) {
                 builderResult.hasBigMagikarpCaught = true
                 builderResult.bigMagikarpCaught = value
             }
        }
        public func setBigMagikarpCaught(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.bigMagikarpCaught = value
          return self
        }
        public func clearBigMagikarpCaught() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasBigMagikarpCaught = false
             builderResult.bigMagikarpCaught = Int32(0)
             return self
        }
        public var hasBattleAttackWon:Bool {
             get {
                  return builderResult.hasBattleAttackWon
             }
        }
        public var battleAttackWon:Int32 {
             get {
                  return builderResult.battleAttackWon
             }
             set (value) {
                 builderResult.hasBattleAttackWon = true
                 builderResult.battleAttackWon = value
             }
        }
        public func setBattleAttackWon(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.battleAttackWon = value
          return self
        }
        public func clearBattleAttackWon() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasBattleAttackWon = false
             builderResult.battleAttackWon = Int32(0)
             return self
        }
        public var hasBattleAttackTotal:Bool {
             get {
                  return builderResult.hasBattleAttackTotal
             }
        }
        public var battleAttackTotal:Int32 {
             get {
                  return builderResult.battleAttackTotal
             }
             set (value) {
                 builderResult.hasBattleAttackTotal = true
                 builderResult.battleAttackTotal = value
             }
        }
        public func setBattleAttackTotal(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.battleAttackTotal = value
          return self
        }
        public func clearBattleAttackTotal() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasBattleAttackTotal = false
             builderResult.battleAttackTotal = Int32(0)
             return self
        }
        public var hasBattleDefendedWon:Bool {
             get {
                  return builderResult.hasBattleDefendedWon
             }
        }
        public var battleDefendedWon:Int32 {
             get {
                  return builderResult.battleDefendedWon
             }
             set (value) {
                 builderResult.hasBattleDefendedWon = true
                 builderResult.battleDefendedWon = value
             }
        }
        public func setBattleDefendedWon(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.battleDefendedWon = value
          return self
        }
        public func clearBattleDefendedWon() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasBattleDefendedWon = false
             builderResult.battleDefendedWon = Int32(0)
             return self
        }
        public var hasBattleTrainingWon:Bool {
             get {
                  return builderResult.hasBattleTrainingWon
             }
        }
        public var battleTrainingWon:Int32 {
             get {
                  return builderResult.battleTrainingWon
             }
             set (value) {
                 builderResult.hasBattleTrainingWon = true
                 builderResult.battleTrainingWon = value
             }
        }
        public func setBattleTrainingWon(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.battleTrainingWon = value
          return self
        }
        public func clearBattleTrainingWon() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasBattleTrainingWon = false
             builderResult.battleTrainingWon = Int32(0)
             return self
        }
        public var hasBattleTrainingTotal:Bool {
             get {
                  return builderResult.hasBattleTrainingTotal
             }
        }
        public var battleTrainingTotal:Int32 {
             get {
                  return builderResult.battleTrainingTotal
             }
             set (value) {
                 builderResult.hasBattleTrainingTotal = true
                 builderResult.battleTrainingTotal = value
             }
        }
        public func setBattleTrainingTotal(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.battleTrainingTotal = value
          return self
        }
        public func clearBattleTrainingTotal() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasBattleTrainingTotal = false
             builderResult.battleTrainingTotal = Int32(0)
             return self
        }
        public var hasPrestigeRaisedTotal:Bool {
             get {
                  return builderResult.hasPrestigeRaisedTotal
             }
        }
        public var prestigeRaisedTotal:Int32 {
             get {
                  return builderResult.prestigeRaisedTotal
             }
             set (value) {
                 builderResult.hasPrestigeRaisedTotal = true
                 builderResult.prestigeRaisedTotal = value
             }
        }
        public func setPrestigeRaisedTotal(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.prestigeRaisedTotal = value
          return self
        }
        public func clearPrestigeRaisedTotal() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPrestigeRaisedTotal = false
             builderResult.prestigeRaisedTotal = Int32(0)
             return self
        }
        public var hasPrestigeDroppedTotal:Bool {
             get {
                  return builderResult.hasPrestigeDroppedTotal
             }
        }
        public var prestigeDroppedTotal:Int32 {
             get {
                  return builderResult.prestigeDroppedTotal
             }
             set (value) {
                 builderResult.hasPrestigeDroppedTotal = true
                 builderResult.prestigeDroppedTotal = value
             }
        }
        public func setPrestigeDroppedTotal(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.prestigeDroppedTotal = value
          return self
        }
        public func clearPrestigeDroppedTotal() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPrestigeDroppedTotal = false
             builderResult.prestigeDroppedTotal = Int32(0)
             return self
        }
        public var hasPokemonDeployed:Bool {
             get {
                  return builderResult.hasPokemonDeployed
             }
        }
        public var pokemonDeployed:Int32 {
             get {
                  return builderResult.pokemonDeployed
             }
             set (value) {
                 builderResult.hasPokemonDeployed = true
                 builderResult.pokemonDeployed = value
             }
        }
        public func setPokemonDeployed(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.pokemonDeployed = value
          return self
        }
        public func clearPokemonDeployed() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPokemonDeployed = false
             builderResult.pokemonDeployed = Int32(0)
             return self
        }
        public var hasPokemonCaughtByType:Bool {
             get {
                  return builderResult.hasPokemonCaughtByType
             }
        }
        public var pokemonCaughtByType:NSData {
             get {
                  return builderResult.pokemonCaughtByType
             }
             set (value) {
                 builderResult.hasPokemonCaughtByType = true
                 builderResult.pokemonCaughtByType = value
             }
        }
        public func setPokemonCaughtByType(value:NSData) -> ResponseEnvelop.PlayerStats.Builder {
          self.pokemonCaughtByType = value
          return self
        }
        public func clearPokemonCaughtByType() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasPokemonCaughtByType = false
             builderResult.pokemonCaughtByType = NSData()
             return self
        }
        public var hasSmallRattataCaught:Bool {
             get {
                  return builderResult.hasSmallRattataCaught
             }
        }
        public var smallRattataCaught:Int32 {
             get {
                  return builderResult.smallRattataCaught
             }
             set (value) {
                 builderResult.hasSmallRattataCaught = true
                 builderResult.smallRattataCaught = value
             }
        }
        public func setSmallRattataCaught(value:Int32) -> ResponseEnvelop.PlayerStats.Builder {
          self.smallRattataCaught = value
          return self
        }
        public func clearSmallRattataCaught() -> ResponseEnvelop.PlayerStats.Builder{
             builderResult.hasSmallRattataCaught = false
             builderResult.smallRattataCaught = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.PlayerStats.Builder {
          builderResult = ResponseEnvelop.PlayerStats()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.PlayerStats.Builder {
          return try ResponseEnvelop.PlayerStats.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.PlayerStats {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.PlayerStats {
          let returnMe:ResponseEnvelop.PlayerStats = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.PlayerStats) throws -> ResponseEnvelop.PlayerStats.Builder {
          if other == ResponseEnvelop.PlayerStats() {
           return self
          }
          if other.hasLevel {
               level = other.level
          }
          if other.hasExperience {
               experience = other.experience
          }
          if other.hasPrevLevelXp {
               prevLevelXp = other.prevLevelXp
          }
          if other.hasNextLevelXp {
               nextLevelXp = other.nextLevelXp
          }
          if other.hasKmWalked {
               kmWalked = other.kmWalked
          }
          if other.hasPokemonsEncountered {
               pokemonsEncountered = other.pokemonsEncountered
          }
          if other.hasUniquePokedexEntries {
               uniquePokedexEntries = other.uniquePokedexEntries
          }
          if other.hasPokemonsCaptured {
               pokemonsCaptured = other.pokemonsCaptured
          }
          if other.hasEvolutions {
               evolutions = other.evolutions
          }
          if other.hasPokeStopVisits {
               pokeStopVisits = other.pokeStopVisits
          }
          if other.hasPokeballsThrown {
               pokeballsThrown = other.pokeballsThrown
          }
          if other.hasEggsHatched {
               eggsHatched = other.eggsHatched
          }
          if other.hasBigMagikarpCaught {
               bigMagikarpCaught = other.bigMagikarpCaught
          }
          if other.hasBattleAttackWon {
               battleAttackWon = other.battleAttackWon
          }
          if other.hasBattleAttackTotal {
               battleAttackTotal = other.battleAttackTotal
          }
          if other.hasBattleDefendedWon {
               battleDefendedWon = other.battleDefendedWon
          }
          if other.hasBattleTrainingWon {
               battleTrainingWon = other.battleTrainingWon
          }
          if other.hasBattleTrainingTotal {
               battleTrainingTotal = other.battleTrainingTotal
          }
          if other.hasPrestigeRaisedTotal {
               prestigeRaisedTotal = other.prestigeRaisedTotal
          }
          if other.hasPrestigeDroppedTotal {
               prestigeDroppedTotal = other.prestigeDroppedTotal
          }
          if other.hasPokemonDeployed {
               pokemonDeployed = other.pokemonDeployed
          }
          if other.hasPokemonCaughtByType {
               pokemonCaughtByType = other.pokemonCaughtByType
          }
          if other.hasSmallRattataCaught {
               smallRattataCaught = other.smallRattataCaught
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PlayerStats.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerStats.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              level = try input.readInt32()

            case 16 :
              experience = try input.readInt64()

            case 24 :
              prevLevelXp = try input.readInt64()

            case 32 :
              nextLevelXp = try input.readInt64()

            case 45 :
              kmWalked = try input.readFloat()

            case 48 :
              pokemonsEncountered = try input.readInt32()

            case 56 :
              uniquePokedexEntries = try input.readInt32()

            case 64 :
              pokemonsCaptured = try input.readInt32()

            case 72 :
              evolutions = try input.readInt32()

            case 80 :
              pokeStopVisits = try input.readInt32()

            case 88 :
              pokeballsThrown = try input.readInt32()

            case 96 :
              eggsHatched = try input.readInt32()

            case 104 :
              bigMagikarpCaught = try input.readInt32()

            case 112 :
              battleAttackWon = try input.readInt32()

            case 120 :
              battleAttackTotal = try input.readInt32()

            case 128 :
              battleDefendedWon = try input.readInt32()

            case 136 :
              battleTrainingWon = try input.readInt32()

            case 144 :
              battleTrainingTotal = try input.readInt32()

            case 152 :
              prestigeRaisedTotal = try input.readInt32()

            case 160 :
              prestigeDroppedTotal = try input.readInt32()

            case 168 :
              pokemonDeployed = try input.readInt32()

            case 178 :
              pokemonCaughtByType = try input.readData()

            case 184 :
              smallRattataCaught = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class PlayerCurrency : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var gems:Int32 = Int32(0)

      public private(set) var hasGems:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasGems {
          try output.writeInt32(1, value:gems)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasGems {
          serialize_size += gems.computeInt32Size(1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.PlayerCurrency> {
        var mergedArray = Array<ResponseEnvelop.PlayerCurrency>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PlayerCurrency? {
        return try ResponseEnvelop.PlayerCurrency.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.PlayerCurrency {
        return try ResponseEnvelop.PlayerCurrency.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerCurrency {
        return try ResponseEnvelop.PlayerCurrency.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PlayerCurrency {
        return try ResponseEnvelop.PlayerCurrency.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerCurrency {
        return try ResponseEnvelop.PlayerCurrency.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PlayerCurrency {
        return try ResponseEnvelop.PlayerCurrency.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerCurrency {
        return try ResponseEnvelop.PlayerCurrency.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.PlayerCurrency.Builder {
        return ResponseEnvelop.PlayerCurrency.classBuilder() as! ResponseEnvelop.PlayerCurrency.Builder
      }
      public func getBuilder() -> ResponseEnvelop.PlayerCurrency.Builder {
        return classBuilder() as! ResponseEnvelop.PlayerCurrency.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PlayerCurrency.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PlayerCurrency.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.PlayerCurrency.Builder {
        return try ResponseEnvelop.PlayerCurrency.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.PlayerCurrency) throws -> ResponseEnvelop.PlayerCurrency.Builder {
        return try ResponseEnvelop.PlayerCurrency.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasGems {
          output += "\(indent) gems: \(gems) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasGems {
                 hashCode = (hashCode &* 31) &+ gems.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.PlayerCurrency"
      }
      override public func className() -> String {
          return "ResponseEnvelop.PlayerCurrency"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.PlayerCurrency.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.PlayerCurrency = ResponseEnvelop.PlayerCurrency()
        public func getMessage() -> ResponseEnvelop.PlayerCurrency {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasGems:Bool {
             get {
                  return builderResult.hasGems
             }
        }
        public var gems:Int32 {
             get {
                  return builderResult.gems
             }
             set (value) {
                 builderResult.hasGems = true
                 builderResult.gems = value
             }
        }
        public func setGems(value:Int32) -> ResponseEnvelop.PlayerCurrency.Builder {
          self.gems = value
          return self
        }
        public func clearGems() -> ResponseEnvelop.PlayerCurrency.Builder{
             builderResult.hasGems = false
             builderResult.gems = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.PlayerCurrency.Builder {
          builderResult = ResponseEnvelop.PlayerCurrency()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.PlayerCurrency.Builder {
          return try ResponseEnvelop.PlayerCurrency.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.PlayerCurrency {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.PlayerCurrency {
          let returnMe:ResponseEnvelop.PlayerCurrency = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.PlayerCurrency) throws -> ResponseEnvelop.PlayerCurrency.Builder {
          if other == ResponseEnvelop.PlayerCurrency() {
           return self
          }
          if other.hasGems {
               gems = other.gems
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PlayerCurrency.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerCurrency.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              gems = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class PlayerCamera : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var isDefaultCamera:Bool = false

      public private(set) var hasIsDefaultCamera:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasIsDefaultCamera {
          try output.writeBool(1, value:isDefaultCamera)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasIsDefaultCamera {
          serialize_size += isDefaultCamera.computeBoolSize(1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.PlayerCamera> {
        var mergedArray = Array<ResponseEnvelop.PlayerCamera>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PlayerCamera? {
        return try ResponseEnvelop.PlayerCamera.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.PlayerCamera {
        return try ResponseEnvelop.PlayerCamera.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerCamera {
        return try ResponseEnvelop.PlayerCamera.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PlayerCamera {
        return try ResponseEnvelop.PlayerCamera.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerCamera {
        return try ResponseEnvelop.PlayerCamera.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PlayerCamera {
        return try ResponseEnvelop.PlayerCamera.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerCamera {
        return try ResponseEnvelop.PlayerCamera.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.PlayerCamera.Builder {
        return ResponseEnvelop.PlayerCamera.classBuilder() as! ResponseEnvelop.PlayerCamera.Builder
      }
      public func getBuilder() -> ResponseEnvelop.PlayerCamera.Builder {
        return classBuilder() as! ResponseEnvelop.PlayerCamera.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PlayerCamera.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PlayerCamera.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.PlayerCamera.Builder {
        return try ResponseEnvelop.PlayerCamera.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.PlayerCamera) throws -> ResponseEnvelop.PlayerCamera.Builder {
        return try ResponseEnvelop.PlayerCamera.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasIsDefaultCamera {
          output += "\(indent) isDefaultCamera: \(isDefaultCamera) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasIsDefaultCamera {
                 hashCode = (hashCode &* 31) &+ isDefaultCamera.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.PlayerCamera"
      }
      override public func className() -> String {
          return "ResponseEnvelop.PlayerCamera"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.PlayerCamera.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.PlayerCamera = ResponseEnvelop.PlayerCamera()
        public func getMessage() -> ResponseEnvelop.PlayerCamera {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasIsDefaultCamera:Bool {
             get {
                  return builderResult.hasIsDefaultCamera
             }
        }
        public var isDefaultCamera:Bool {
             get {
                  return builderResult.isDefaultCamera
             }
             set (value) {
                 builderResult.hasIsDefaultCamera = true
                 builderResult.isDefaultCamera = value
             }
        }
        public func setIsDefaultCamera(value:Bool) -> ResponseEnvelop.PlayerCamera.Builder {
          self.isDefaultCamera = value
          return self
        }
        public func clearIsDefaultCamera() -> ResponseEnvelop.PlayerCamera.Builder{
             builderResult.hasIsDefaultCamera = false
             builderResult.isDefaultCamera = false
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.PlayerCamera.Builder {
          builderResult = ResponseEnvelop.PlayerCamera()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.PlayerCamera.Builder {
          return try ResponseEnvelop.PlayerCamera.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.PlayerCamera {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.PlayerCamera {
          let returnMe:ResponseEnvelop.PlayerCamera = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.PlayerCamera) throws -> ResponseEnvelop.PlayerCamera.Builder {
          if other == ResponseEnvelop.PlayerCamera() {
           return self
          }
          if other.hasIsDefaultCamera {
               isDefaultCamera = other.isDefaultCamera
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PlayerCamera.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PlayerCamera.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              isDefaultCamera = try input.readBool()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class InventoryUpgrades : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var inventoryUpgrades:Array<ResponseEnvelop.InventoryUpgrade>  = Array<ResponseEnvelop.InventoryUpgrade>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        for oneElementinventoryUpgrades in inventoryUpgrades {
            try output.writeMessage(1, value:oneElementinventoryUpgrades)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        for oneElementinventoryUpgrades in inventoryUpgrades {
            serialize_size += oneElementinventoryUpgrades.computeMessageSize(1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.InventoryUpgrades> {
        var mergedArray = Array<ResponseEnvelop.InventoryUpgrades>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryUpgrades? {
        return try ResponseEnvelop.InventoryUpgrades.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.InventoryUpgrades {
        return try ResponseEnvelop.InventoryUpgrades.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryUpgrades {
        return try ResponseEnvelop.InventoryUpgrades.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryUpgrades {
        return try ResponseEnvelop.InventoryUpgrades.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryUpgrades {
        return try ResponseEnvelop.InventoryUpgrades.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryUpgrades {
        return try ResponseEnvelop.InventoryUpgrades.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryUpgrades {
        return try ResponseEnvelop.InventoryUpgrades.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.InventoryUpgrades.Builder {
        return ResponseEnvelop.InventoryUpgrades.classBuilder() as! ResponseEnvelop.InventoryUpgrades.Builder
      }
      public func getBuilder() -> ResponseEnvelop.InventoryUpgrades.Builder {
        return classBuilder() as! ResponseEnvelop.InventoryUpgrades.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryUpgrades.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryUpgrades.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.InventoryUpgrades.Builder {
        return try ResponseEnvelop.InventoryUpgrades.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.InventoryUpgrades) throws -> ResponseEnvelop.InventoryUpgrades.Builder {
        return try ResponseEnvelop.InventoryUpgrades.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        var inventoryUpgradesElementIndex:Int = 0
        for oneElementinventoryUpgrades in inventoryUpgrades {
            output += "\(indent) inventoryUpgrades[\(inventoryUpgradesElementIndex)] {\n"
            output += try oneElementinventoryUpgrades.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            inventoryUpgradesElementIndex += 1
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for oneElementinventoryUpgrades in inventoryUpgrades {
                  hashCode = (hashCode &* 31) &+ oneElementinventoryUpgrades.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.InventoryUpgrades"
      }
      override public func className() -> String {
          return "ResponseEnvelop.InventoryUpgrades"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.InventoryUpgrades.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.InventoryUpgrades = ResponseEnvelop.InventoryUpgrades()
        public func getMessage() -> ResponseEnvelop.InventoryUpgrades {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var inventoryUpgrades:Array<ResponseEnvelop.InventoryUpgrade> {
             get {
                 return builderResult.inventoryUpgrades
             }
             set (value) {
                 builderResult.inventoryUpgrades = value
             }
        }
        public func setInventoryUpgrades(value:Array<ResponseEnvelop.InventoryUpgrade>) -> ResponseEnvelop.InventoryUpgrades.Builder {
          self.inventoryUpgrades = value
          return self
        }
        public func clearInventoryUpgrades() -> ResponseEnvelop.InventoryUpgrades.Builder {
          builderResult.inventoryUpgrades.removeAll(keepCapacity: false)
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.InventoryUpgrades.Builder {
          builderResult = ResponseEnvelop.InventoryUpgrades()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.InventoryUpgrades.Builder {
          return try ResponseEnvelop.InventoryUpgrades.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.InventoryUpgrades {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.InventoryUpgrades {
          let returnMe:ResponseEnvelop.InventoryUpgrades = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.InventoryUpgrades) throws -> ResponseEnvelop.InventoryUpgrades.Builder {
          if other == ResponseEnvelop.InventoryUpgrades() {
           return self
          }
          if !other.inventoryUpgrades.isEmpty  {
             builderResult.inventoryUpgrades += other.inventoryUpgrades
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryUpgrades.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryUpgrades.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              let subBuilder = ResponseEnvelop.InventoryUpgrade.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              inventoryUpgrades += [subBuilder.buildPartial()]

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class InventoryUpgrade : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var item:ResponseEnvelop.ItemType = ResponseEnvelop.ItemType.ItemTypeNone
      public private(set) var hasItem:Bool = false
      public private(set) var upgradeType:ResponseEnvelop.InventoryUpgradeType = ResponseEnvelop.InventoryUpgradeType.UpgradeUnset
      public private(set) var hasUpgradeType:Bool = false
      public private(set) var additionalStorage:Int32 = Int32(0)

      public private(set) var hasAdditionalStorage:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasItem {
          try output.writeEnum(1, value:item.rawValue)
        }
        if hasUpgradeType {
          try output.writeEnum(2, value:upgradeType.rawValue)
        }
        if hasAdditionalStorage {
          try output.writeInt32(3, value:additionalStorage)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasItem) {
          serialize_size += item.rawValue.computeEnumSize(1)
        }
        if (hasUpgradeType) {
          serialize_size += upgradeType.rawValue.computeEnumSize(2)
        }
        if hasAdditionalStorage {
          serialize_size += additionalStorage.computeInt32Size(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.InventoryUpgrade> {
        var mergedArray = Array<ResponseEnvelop.InventoryUpgrade>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryUpgrade? {
        return try ResponseEnvelop.InventoryUpgrade.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.InventoryUpgrade {
        return try ResponseEnvelop.InventoryUpgrade.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryUpgrade {
        return try ResponseEnvelop.InventoryUpgrade.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.InventoryUpgrade {
        return try ResponseEnvelop.InventoryUpgrade.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryUpgrade {
        return try ResponseEnvelop.InventoryUpgrade.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryUpgrade {
        return try ResponseEnvelop.InventoryUpgrade.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryUpgrade {
        return try ResponseEnvelop.InventoryUpgrade.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.InventoryUpgrade.Builder {
        return ResponseEnvelop.InventoryUpgrade.classBuilder() as! ResponseEnvelop.InventoryUpgrade.Builder
      }
      public func getBuilder() -> ResponseEnvelop.InventoryUpgrade.Builder {
        return classBuilder() as! ResponseEnvelop.InventoryUpgrade.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryUpgrade.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.InventoryUpgrade.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.InventoryUpgrade.Builder {
        return try ResponseEnvelop.InventoryUpgrade.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.InventoryUpgrade) throws -> ResponseEnvelop.InventoryUpgrade.Builder {
        return try ResponseEnvelop.InventoryUpgrade.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasItem) {
          output += "\(indent) item: \(item.description)\n"
        }
        if (hasUpgradeType) {
          output += "\(indent) upgradeType: \(upgradeType.description)\n"
        }
        if hasAdditionalStorage {
          output += "\(indent) additionalStorage: \(additionalStorage) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasItem {
                 hashCode = (hashCode &* 31) &+ Int(item.rawValue)
              }
              if hasUpgradeType {
                 hashCode = (hashCode &* 31) &+ Int(upgradeType.rawValue)
              }
              if hasAdditionalStorage {
                 hashCode = (hashCode &* 31) &+ additionalStorage.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.InventoryUpgrade"
      }
      override public func className() -> String {
          return "ResponseEnvelop.InventoryUpgrade"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.InventoryUpgrade.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.InventoryUpgrade = ResponseEnvelop.InventoryUpgrade()
        public func getMessage() -> ResponseEnvelop.InventoryUpgrade {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasItem:Bool{
              get {
                  return builderResult.hasItem
              }
          }
          public var item:ResponseEnvelop.ItemType {
              get {
                  return builderResult.item
              }
              set (value) {
                  builderResult.hasItem = true
                  builderResult.item = value
              }
          }
          public func setItem(value:ResponseEnvelop.ItemType) -> ResponseEnvelop.InventoryUpgrade.Builder {
            self.item = value
            return self
          }
          public func clearItem() -> ResponseEnvelop.InventoryUpgrade.Builder {
             builderResult.hasItem = false
             builderResult.item = .ItemTypeNone
             return self
          }
          public var hasUpgradeType:Bool{
              get {
                  return builderResult.hasUpgradeType
              }
          }
          public var upgradeType:ResponseEnvelop.InventoryUpgradeType {
              get {
                  return builderResult.upgradeType
              }
              set (value) {
                  builderResult.hasUpgradeType = true
                  builderResult.upgradeType = value
              }
          }
          public func setUpgradeType(value:ResponseEnvelop.InventoryUpgradeType) -> ResponseEnvelop.InventoryUpgrade.Builder {
            self.upgradeType = value
            return self
          }
          public func clearUpgradeType() -> ResponseEnvelop.InventoryUpgrade.Builder {
             builderResult.hasUpgradeType = false
             builderResult.upgradeType = .UpgradeUnset
             return self
          }
        public var hasAdditionalStorage:Bool {
             get {
                  return builderResult.hasAdditionalStorage
             }
        }
        public var additionalStorage:Int32 {
             get {
                  return builderResult.additionalStorage
             }
             set (value) {
                 builderResult.hasAdditionalStorage = true
                 builderResult.additionalStorage = value
             }
        }
        public func setAdditionalStorage(value:Int32) -> ResponseEnvelop.InventoryUpgrade.Builder {
          self.additionalStorage = value
          return self
        }
        public func clearAdditionalStorage() -> ResponseEnvelop.InventoryUpgrade.Builder{
             builderResult.hasAdditionalStorage = false
             builderResult.additionalStorage = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.InventoryUpgrade.Builder {
          builderResult = ResponseEnvelop.InventoryUpgrade()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.InventoryUpgrade.Builder {
          return try ResponseEnvelop.InventoryUpgrade.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.InventoryUpgrade {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.InventoryUpgrade {
          let returnMe:ResponseEnvelop.InventoryUpgrade = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.InventoryUpgrade) throws -> ResponseEnvelop.InventoryUpgrade.Builder {
          if other == ResponseEnvelop.InventoryUpgrade() {
           return self
          }
          if other.hasItem {
               item = other.item
          }
          if other.hasUpgradeType {
               upgradeType = other.upgradeType
          }
          if other.hasAdditionalStorage {
               additionalStorage = other.additionalStorage
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.InventoryUpgrade.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.InventoryUpgrade.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntitem = try input.readEnum()
              if let enumsitem = ResponseEnvelop.ItemType(rawValue:valueIntitem){
                   item = enumsitem
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntitem))
              }

            case 16 :
              let valueIntupgradeType = try input.readEnum()
              if let enumsupgradeType = ResponseEnvelop.InventoryUpgradeType(rawValue:valueIntupgradeType){
                   upgradeType = enumsupgradeType
              } else {
                   try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntupgradeType))
              }

            case 24 :
              additionalStorage = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class AppliedItems : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var item:ResponseEnvelop.AppliedItem!
      public private(set) var hasItem:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasItem {
          try output.writeMessage(4, value:item)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasItem {
            if let varSizeitem = item?.computeMessageSize(4) {
                serialize_size += varSizeitem
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.AppliedItems> {
        var mergedArray = Array<ResponseEnvelop.AppliedItems>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.AppliedItems? {
        return try ResponseEnvelop.AppliedItems.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.AppliedItems {
        return try ResponseEnvelop.AppliedItems.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AppliedItems {
        return try ResponseEnvelop.AppliedItems.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.AppliedItems {
        return try ResponseEnvelop.AppliedItems.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AppliedItems {
        return try ResponseEnvelop.AppliedItems.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.AppliedItems {
        return try ResponseEnvelop.AppliedItems.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AppliedItems {
        return try ResponseEnvelop.AppliedItems.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.AppliedItems.Builder {
        return ResponseEnvelop.AppliedItems.classBuilder() as! ResponseEnvelop.AppliedItems.Builder
      }
      public func getBuilder() -> ResponseEnvelop.AppliedItems.Builder {
        return classBuilder() as! ResponseEnvelop.AppliedItems.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.AppliedItems.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.AppliedItems.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.AppliedItems.Builder {
        return try ResponseEnvelop.AppliedItems.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.AppliedItems) throws -> ResponseEnvelop.AppliedItems.Builder {
        return try ResponseEnvelop.AppliedItems.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasItem {
          output += "\(indent) item {\n"
          if let outDescItem = item {
            output += try outDescItem.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasItem {
                  if let hashValueitem = item?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueitem
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.AppliedItems"
      }
      override public func className() -> String {
          return "ResponseEnvelop.AppliedItems"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.AppliedItems.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.AppliedItems = ResponseEnvelop.AppliedItems()
        public func getMessage() -> ResponseEnvelop.AppliedItems {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasItem:Bool {
             get {
                 return builderResult.hasItem
             }
        }
        public var item:ResponseEnvelop.AppliedItem! {
             get {
                 if itemBuilder_ != nil {
                    builderResult.item = itemBuilder_.getMessage()
                 }
                 return builderResult.item
             }
             set (value) {
                 builderResult.hasItem = true
                 builderResult.item = value
             }
        }
        private var itemBuilder_:ResponseEnvelop.AppliedItem.Builder! {
             didSet {
                builderResult.hasItem = true
             }
        }
        public func getItemBuilder() -> ResponseEnvelop.AppliedItem.Builder {
          if itemBuilder_ == nil {
             itemBuilder_ = ResponseEnvelop.AppliedItem.Builder()
             builderResult.item = itemBuilder_.getMessage()
             if item != nil {
                try! itemBuilder_.mergeFrom(item)
             }
          }
          return itemBuilder_
        }
        public func setItem(value:ResponseEnvelop.AppliedItem!) -> ResponseEnvelop.AppliedItems.Builder {
          self.item = value
          return self
        }
        public func mergeItem(value:ResponseEnvelop.AppliedItem) throws -> ResponseEnvelop.AppliedItems.Builder {
          if builderResult.hasItem {
            builderResult.item = try ResponseEnvelop.AppliedItem.builderWithPrototype(builderResult.item).mergeFrom(value).buildPartial()
          } else {
            builderResult.item = value
          }
          builderResult.hasItem = true
          return self
        }
        public func clearItem() -> ResponseEnvelop.AppliedItems.Builder {
          itemBuilder_ = nil
          builderResult.hasItem = false
          builderResult.item = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.AppliedItems.Builder {
          builderResult = ResponseEnvelop.AppliedItems()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.AppliedItems.Builder {
          return try ResponseEnvelop.AppliedItems.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.AppliedItems {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.AppliedItems {
          let returnMe:ResponseEnvelop.AppliedItems = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.AppliedItems) throws -> ResponseEnvelop.AppliedItems.Builder {
          if other == ResponseEnvelop.AppliedItems() {
           return self
          }
          if (other.hasItem) {
              try mergeItem(other.item)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.AppliedItems.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AppliedItems.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 34 :
              let subBuilder:ResponseEnvelop.AppliedItem.Builder = ResponseEnvelop.AppliedItem.Builder()
              if hasItem {
                try subBuilder.mergeFrom(item)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              item = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class AppliedItem : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var itemType:ResponseEnvelop.ItemId = ResponseEnvelop.ItemId.ItemUnknown
      public private(set) var hasItemType:Bool = false
      public private(set) var itemTypeCategory:ResponseEnvelop.ItemType = ResponseEnvelop.ItemType.ItemTypeNone
      public private(set) var hasItemTypeCategory:Bool = false
      public private(set) var expireMs:Int64 = Int64(0)

      public private(set) var hasExpireMs:Bool = false
      public private(set) var appliedMs:Int64 = Int64(0)

      public private(set) var hasAppliedMs:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasItemType {
          try output.writeEnum(1, value:itemType.rawValue)
        }
        if hasItemTypeCategory {
          try output.writeEnum(2, value:itemTypeCategory.rawValue)
        }
        if hasExpireMs {
          try output.writeInt64(3, value:expireMs)
        }
        if hasAppliedMs {
          try output.writeInt64(4, value:appliedMs)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasItemType) {
          serialize_size += itemType.rawValue.computeEnumSize(1)
        }
        if (hasItemTypeCategory) {
          serialize_size += itemTypeCategory.rawValue.computeEnumSize(2)
        }
        if hasExpireMs {
          serialize_size += expireMs.computeInt64Size(3)
        }
        if hasAppliedMs {
          serialize_size += appliedMs.computeInt64Size(4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.AppliedItem> {
        var mergedArray = Array<ResponseEnvelop.AppliedItem>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.AppliedItem? {
        return try ResponseEnvelop.AppliedItem.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.AppliedItem {
        return try ResponseEnvelop.AppliedItem.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AppliedItem {
        return try ResponseEnvelop.AppliedItem.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.AppliedItem {
        return try ResponseEnvelop.AppliedItem.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AppliedItem {
        return try ResponseEnvelop.AppliedItem.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.AppliedItem {
        return try ResponseEnvelop.AppliedItem.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AppliedItem {
        return try ResponseEnvelop.AppliedItem.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.AppliedItem.Builder {
        return ResponseEnvelop.AppliedItem.classBuilder() as! ResponseEnvelop.AppliedItem.Builder
      }
      public func getBuilder() -> ResponseEnvelop.AppliedItem.Builder {
        return classBuilder() as! ResponseEnvelop.AppliedItem.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.AppliedItem.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.AppliedItem.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.AppliedItem.Builder {
        return try ResponseEnvelop.AppliedItem.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.AppliedItem) throws -> ResponseEnvelop.AppliedItem.Builder {
        return try ResponseEnvelop.AppliedItem.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasItemType) {
          output += "\(indent) itemType: \(itemType.description)\n"
        }
        if (hasItemTypeCategory) {
          output += "\(indent) itemTypeCategory: \(itemTypeCategory.description)\n"
        }
        if hasExpireMs {
          output += "\(indent) expireMs: \(expireMs) \n"
        }
        if hasAppliedMs {
          output += "\(indent) appliedMs: \(appliedMs) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasItemType {
                 hashCode = (hashCode &* 31) &+ Int(itemType.rawValue)
              }
              if hasItemTypeCategory {
                 hashCode = (hashCode &* 31) &+ Int(itemTypeCategory.rawValue)
              }
              if hasExpireMs {
                 hashCode = (hashCode &* 31) &+ expireMs.hashValue
              }
              if hasAppliedMs {
                 hashCode = (hashCode &* 31) &+ appliedMs.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.AppliedItem"
      }
      override public func className() -> String {
          return "ResponseEnvelop.AppliedItem"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.AppliedItem.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.AppliedItem = ResponseEnvelop.AppliedItem()
        public func getMessage() -> ResponseEnvelop.AppliedItem {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasItemType:Bool{
              get {
                  return builderResult.hasItemType
              }
          }
          public var itemType:ResponseEnvelop.ItemId {
              get {
                  return builderResult.itemType
              }
              set (value) {
                  builderResult.hasItemType = true
                  builderResult.itemType = value
              }
          }
          public func setItemType(value:ResponseEnvelop.ItemId) -> ResponseEnvelop.AppliedItem.Builder {
            self.itemType = value
            return self
          }
          public func clearItemType() -> ResponseEnvelop.AppliedItem.Builder {
             builderResult.hasItemType = false
             builderResult.itemType = .ItemUnknown
             return self
          }
          public var hasItemTypeCategory:Bool{
              get {
                  return builderResult.hasItemTypeCategory
              }
          }
          public var itemTypeCategory:ResponseEnvelop.ItemType {
              get {
                  return builderResult.itemTypeCategory
              }
              set (value) {
                  builderResult.hasItemTypeCategory = true
                  builderResult.itemTypeCategory = value
              }
          }
          public func setItemTypeCategory(value:ResponseEnvelop.ItemType) -> ResponseEnvelop.AppliedItem.Builder {
            self.itemTypeCategory = value
            return self
          }
          public func clearItemTypeCategory() -> ResponseEnvelop.AppliedItem.Builder {
             builderResult.hasItemTypeCategory = false
             builderResult.itemTypeCategory = .ItemTypeNone
             return self
          }
        public var hasExpireMs:Bool {
             get {
                  return builderResult.hasExpireMs
             }
        }
        public var expireMs:Int64 {
             get {
                  return builderResult.expireMs
             }
             set (value) {
                 builderResult.hasExpireMs = true
                 builderResult.expireMs = value
             }
        }
        public func setExpireMs(value:Int64) -> ResponseEnvelop.AppliedItem.Builder {
          self.expireMs = value
          return self
        }
        public func clearExpireMs() -> ResponseEnvelop.AppliedItem.Builder{
             builderResult.hasExpireMs = false
             builderResult.expireMs = Int64(0)
             return self
        }
        public var hasAppliedMs:Bool {
             get {
                  return builderResult.hasAppliedMs
             }
        }
        public var appliedMs:Int64 {
             get {
                  return builderResult.appliedMs
             }
             set (value) {
                 builderResult.hasAppliedMs = true
                 builderResult.appliedMs = value
             }
        }
        public func setAppliedMs(value:Int64) -> ResponseEnvelop.AppliedItem.Builder {
          self.appliedMs = value
          return self
        }
        public func clearAppliedMs() -> ResponseEnvelop.AppliedItem.Builder{
             builderResult.hasAppliedMs = false
             builderResult.appliedMs = Int64(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.AppliedItem.Builder {
          builderResult = ResponseEnvelop.AppliedItem()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.AppliedItem.Builder {
          return try ResponseEnvelop.AppliedItem.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.AppliedItem {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.AppliedItem {
          let returnMe:ResponseEnvelop.AppliedItem = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.AppliedItem) throws -> ResponseEnvelop.AppliedItem.Builder {
          if other == ResponseEnvelop.AppliedItem() {
           return self
          }
          if other.hasItemType {
               itemType = other.itemType
          }
          if other.hasItemTypeCategory {
               itemTypeCategory = other.itemTypeCategory
          }
          if other.hasExpireMs {
               expireMs = other.expireMs
          }
          if other.hasAppliedMs {
               appliedMs = other.appliedMs
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.AppliedItem.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.AppliedItem.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntitemType = try input.readEnum()
              if let enumsitemType = ResponseEnvelop.ItemId(rawValue:valueIntitemType){
                   itemType = enumsitemType
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntitemType))
              }

            case 16 :
              let valueIntitemTypeCategory = try input.readEnum()
              if let enumsitemTypeCategory = ResponseEnvelop.ItemType(rawValue:valueIntitemTypeCategory){
                   itemTypeCategory = enumsitemTypeCategory
              } else {
                   try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntitemTypeCategory))
              }

            case 24 :
              expireMs = try input.readInt64()

            case 32 :
              appliedMs = try input.readInt64()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class EggIncubators : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var eggIncubator:ResponseEnvelop.EggIncubator!
      public private(set) var hasEggIncubator:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasEggIncubator {
          try output.writeMessage(1, value:eggIncubator)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasEggIncubator {
            if let varSizeeggIncubator = eggIncubator?.computeMessageSize(1) {
                serialize_size += varSizeeggIncubator
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.EggIncubators> {
        var mergedArray = Array<ResponseEnvelop.EggIncubators>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.EggIncubators? {
        return try ResponseEnvelop.EggIncubators.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.EggIncubators {
        return try ResponseEnvelop.EggIncubators.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EggIncubators {
        return try ResponseEnvelop.EggIncubators.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.EggIncubators {
        return try ResponseEnvelop.EggIncubators.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EggIncubators {
        return try ResponseEnvelop.EggIncubators.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.EggIncubators {
        return try ResponseEnvelop.EggIncubators.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EggIncubators {
        return try ResponseEnvelop.EggIncubators.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.EggIncubators.Builder {
        return ResponseEnvelop.EggIncubators.classBuilder() as! ResponseEnvelop.EggIncubators.Builder
      }
      public func getBuilder() -> ResponseEnvelop.EggIncubators.Builder {
        return classBuilder() as! ResponseEnvelop.EggIncubators.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.EggIncubators.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.EggIncubators.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.EggIncubators.Builder {
        return try ResponseEnvelop.EggIncubators.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.EggIncubators) throws -> ResponseEnvelop.EggIncubators.Builder {
        return try ResponseEnvelop.EggIncubators.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasEggIncubator {
          output += "\(indent) eggIncubator {\n"
          if let outDescEggIncubator = eggIncubator {
            output += try outDescEggIncubator.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasEggIncubator {
                  if let hashValueeggIncubator = eggIncubator?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueeggIncubator
                  }
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.EggIncubators"
      }
      override public func className() -> String {
          return "ResponseEnvelop.EggIncubators"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.EggIncubators.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.EggIncubators = ResponseEnvelop.EggIncubators()
        public func getMessage() -> ResponseEnvelop.EggIncubators {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasEggIncubator:Bool {
             get {
                 return builderResult.hasEggIncubator
             }
        }
        public var eggIncubator:ResponseEnvelop.EggIncubator! {
             get {
                 if eggIncubatorBuilder_ != nil {
                    builderResult.eggIncubator = eggIncubatorBuilder_.getMessage()
                 }
                 return builderResult.eggIncubator
             }
             set (value) {
                 builderResult.hasEggIncubator = true
                 builderResult.eggIncubator = value
             }
        }
        private var eggIncubatorBuilder_:ResponseEnvelop.EggIncubator.Builder! {
             didSet {
                builderResult.hasEggIncubator = true
             }
        }
        public func getEggIncubatorBuilder() -> ResponseEnvelop.EggIncubator.Builder {
          if eggIncubatorBuilder_ == nil {
             eggIncubatorBuilder_ = ResponseEnvelop.EggIncubator.Builder()
             builderResult.eggIncubator = eggIncubatorBuilder_.getMessage()
             if eggIncubator != nil {
                try! eggIncubatorBuilder_.mergeFrom(eggIncubator)
             }
          }
          return eggIncubatorBuilder_
        }
        public func setEggIncubator(value:ResponseEnvelop.EggIncubator!) -> ResponseEnvelop.EggIncubators.Builder {
          self.eggIncubator = value
          return self
        }
        public func mergeEggIncubator(value:ResponseEnvelop.EggIncubator) throws -> ResponseEnvelop.EggIncubators.Builder {
          if builderResult.hasEggIncubator {
            builderResult.eggIncubator = try ResponseEnvelop.EggIncubator.builderWithPrototype(builderResult.eggIncubator).mergeFrom(value).buildPartial()
          } else {
            builderResult.eggIncubator = value
          }
          builderResult.hasEggIncubator = true
          return self
        }
        public func clearEggIncubator() -> ResponseEnvelop.EggIncubators.Builder {
          eggIncubatorBuilder_ = nil
          builderResult.hasEggIncubator = false
          builderResult.eggIncubator = nil
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.EggIncubators.Builder {
          builderResult = ResponseEnvelop.EggIncubators()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.EggIncubators.Builder {
          return try ResponseEnvelop.EggIncubators.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.EggIncubators {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.EggIncubators {
          let returnMe:ResponseEnvelop.EggIncubators = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.EggIncubators) throws -> ResponseEnvelop.EggIncubators.Builder {
          if other == ResponseEnvelop.EggIncubators() {
           return self
          }
          if (other.hasEggIncubator) {
              try mergeEggIncubator(other.eggIncubator)
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.EggIncubators.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EggIncubators.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              let subBuilder:ResponseEnvelop.EggIncubator.Builder = ResponseEnvelop.EggIncubator.Builder()
              if hasEggIncubator {
                try subBuilder.mergeFrom(eggIncubator)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              eggIncubator = subBuilder.buildPartial()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class EggIncubator : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var itemId:String = ""

      public private(set) var hasItemId:Bool = false
      public private(set) var itemType:ResponseEnvelop.ItemType = ResponseEnvelop.ItemType.ItemTypeNone
      public private(set) var hasItemType:Bool = false
      public private(set) var incubatorType:ResponseEnvelop.EggIncubatorType = ResponseEnvelop.EggIncubatorType.IncubatorUnset
      public private(set) var hasIncubatorType:Bool = false
      public private(set) var usesRemaining:Int32 = Int32(0)

      public private(set) var hasUsesRemaining:Bool = false
      // TODO: Check if is PokemonType
      public private(set) var pokemonId:Int64 = Int64(0)

      public private(set) var hasPokemonId:Bool = false
      public private(set) var startKmWalked:Double = Double(0)

      public private(set) var hasStartKmWalked:Bool = false
      public private(set) var targetKmWalked:Double = Double(0)

      public private(set) var hasTargetKmWalked:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasItemId {
          try output.writeString(1, value:itemId)
        }
        if hasItemType {
          try output.writeEnum(2, value:itemType.rawValue)
        }
        if hasIncubatorType {
          try output.writeEnum(3, value:incubatorType.rawValue)
        }
        if hasUsesRemaining {
          try output.writeInt32(4, value:usesRemaining)
        }
        if hasPokemonId {
          try output.writeInt64(5, value:pokemonId)
        }
        if hasStartKmWalked {
          try output.writeDouble(6, value:startKmWalked)
        }
        if hasTargetKmWalked {
          try output.writeDouble(7, value:targetKmWalked)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasItemId {
          serialize_size += itemId.computeStringSize(1)
        }
        if (hasItemType) {
          serialize_size += itemType.rawValue.computeEnumSize(2)
        }
        if (hasIncubatorType) {
          serialize_size += incubatorType.rawValue.computeEnumSize(3)
        }
        if hasUsesRemaining {
          serialize_size += usesRemaining.computeInt32Size(4)
        }
        if hasPokemonId {
          serialize_size += pokemonId.computeInt64Size(5)
        }
        if hasStartKmWalked {
          serialize_size += startKmWalked.computeDoubleSize(6)
        }
        if hasTargetKmWalked {
          serialize_size += targetKmWalked.computeDoubleSize(7)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.EggIncubator> {
        var mergedArray = Array<ResponseEnvelop.EggIncubator>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.EggIncubator? {
        return try ResponseEnvelop.EggIncubator.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.EggIncubator {
        return try ResponseEnvelop.EggIncubator.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EggIncubator {
        return try ResponseEnvelop.EggIncubator.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.EggIncubator {
        return try ResponseEnvelop.EggIncubator.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EggIncubator {
        return try ResponseEnvelop.EggIncubator.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.EggIncubator {
        return try ResponseEnvelop.EggIncubator.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EggIncubator {
        return try ResponseEnvelop.EggIncubator.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.EggIncubator.Builder {
        return ResponseEnvelop.EggIncubator.classBuilder() as! ResponseEnvelop.EggIncubator.Builder
      }
      public func getBuilder() -> ResponseEnvelop.EggIncubator.Builder {
        return classBuilder() as! ResponseEnvelop.EggIncubator.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.EggIncubator.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.EggIncubator.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.EggIncubator.Builder {
        return try ResponseEnvelop.EggIncubator.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.EggIncubator) throws -> ResponseEnvelop.EggIncubator.Builder {
        return try ResponseEnvelop.EggIncubator.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasItemId {
          output += "\(indent) itemId: \(itemId) \n"
        }
        if (hasItemType) {
          output += "\(indent) itemType: \(itemType.description)\n"
        }
        if (hasIncubatorType) {
          output += "\(indent) incubatorType: \(incubatorType.description)\n"
        }
        if hasUsesRemaining {
          output += "\(indent) usesRemaining: \(usesRemaining) \n"
        }
        if hasPokemonId {
          output += "\(indent) pokemonId: \(pokemonId) \n"
        }
        if hasStartKmWalked {
          output += "\(indent) startKmWalked: \(startKmWalked) \n"
        }
        if hasTargetKmWalked {
          output += "\(indent) targetKmWalked: \(targetKmWalked) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasItemId {
                 hashCode = (hashCode &* 31) &+ itemId.hashValue
              }
              if hasItemType {
                 hashCode = (hashCode &* 31) &+ Int(itemType.rawValue)
              }
              if hasIncubatorType {
                 hashCode = (hashCode &* 31) &+ Int(incubatorType.rawValue)
              }
              if hasUsesRemaining {
                 hashCode = (hashCode &* 31) &+ usesRemaining.hashValue
              }
              if hasPokemonId {
                 hashCode = (hashCode &* 31) &+ pokemonId.hashValue
              }
              if hasStartKmWalked {
                 hashCode = (hashCode &* 31) &+ startKmWalked.hashValue
              }
              if hasTargetKmWalked {
                 hashCode = (hashCode &* 31) &+ targetKmWalked.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.EggIncubator"
      }
      override public func className() -> String {
          return "ResponseEnvelop.EggIncubator"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.EggIncubator.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.EggIncubator = ResponseEnvelop.EggIncubator()
        public func getMessage() -> ResponseEnvelop.EggIncubator {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasItemId:Bool {
             get {
                  return builderResult.hasItemId
             }
        }
        public var itemId:String {
             get {
                  return builderResult.itemId
             }
             set (value) {
                 builderResult.hasItemId = true
                 builderResult.itemId = value
             }
        }
        public func setItemId(value:String) -> ResponseEnvelop.EggIncubator.Builder {
          self.itemId = value
          return self
        }
        public func clearItemId() -> ResponseEnvelop.EggIncubator.Builder{
             builderResult.hasItemId = false
             builderResult.itemId = ""
             return self
        }
          public var hasItemType:Bool{
              get {
                  return builderResult.hasItemType
              }
          }
          public var itemType:ResponseEnvelop.ItemType {
              get {
                  return builderResult.itemType
              }
              set (value) {
                  builderResult.hasItemType = true
                  builderResult.itemType = value
              }
          }
          public func setItemType(value:ResponseEnvelop.ItemType) -> ResponseEnvelop.EggIncubator.Builder {
            self.itemType = value
            return self
          }
          public func clearItemType() -> ResponseEnvelop.EggIncubator.Builder {
             builderResult.hasItemType = false
             builderResult.itemType = .ItemTypeNone
             return self
          }
          public var hasIncubatorType:Bool{
              get {
                  return builderResult.hasIncubatorType
              }
          }
          public var incubatorType:ResponseEnvelop.EggIncubatorType {
              get {
                  return builderResult.incubatorType
              }
              set (value) {
                  builderResult.hasIncubatorType = true
                  builderResult.incubatorType = value
              }
          }
          public func setIncubatorType(value:ResponseEnvelop.EggIncubatorType) -> ResponseEnvelop.EggIncubator.Builder {
            self.incubatorType = value
            return self
          }
          public func clearIncubatorType() -> ResponseEnvelop.EggIncubator.Builder {
             builderResult.hasIncubatorType = false
             builderResult.incubatorType = .IncubatorUnset
             return self
          }
        public var hasUsesRemaining:Bool {
             get {
                  return builderResult.hasUsesRemaining
             }
        }
        public var usesRemaining:Int32 {
             get {
                  return builderResult.usesRemaining
             }
             set (value) {
                 builderResult.hasUsesRemaining = true
                 builderResult.usesRemaining = value
             }
        }
        public func setUsesRemaining(value:Int32) -> ResponseEnvelop.EggIncubator.Builder {
          self.usesRemaining = value
          return self
        }
        public func clearUsesRemaining() -> ResponseEnvelop.EggIncubator.Builder{
             builderResult.hasUsesRemaining = false
             builderResult.usesRemaining = Int32(0)
             return self
        }
        public var hasPokemonId:Bool {
             get {
                  return builderResult.hasPokemonId
             }
        }
        public var pokemonId:Int64 {
             get {
                  return builderResult.pokemonId
             }
             set (value) {
                 builderResult.hasPokemonId = true
                 builderResult.pokemonId = value
             }
        }
        public func setPokemonId(value:Int64) -> ResponseEnvelop.EggIncubator.Builder {
          self.pokemonId = value
          return self
        }
        public func clearPokemonId() -> ResponseEnvelop.EggIncubator.Builder{
             builderResult.hasPokemonId = false
             builderResult.pokemonId = Int64(0)
             return self
        }
        public var hasStartKmWalked:Bool {
             get {
                  return builderResult.hasStartKmWalked
             }
        }
        public var startKmWalked:Double {
             get {
                  return builderResult.startKmWalked
             }
             set (value) {
                 builderResult.hasStartKmWalked = true
                 builderResult.startKmWalked = value
             }
        }
        public func setStartKmWalked(value:Double) -> ResponseEnvelop.EggIncubator.Builder {
          self.startKmWalked = value
          return self
        }
        public func clearStartKmWalked() -> ResponseEnvelop.EggIncubator.Builder{
             builderResult.hasStartKmWalked = false
             builderResult.startKmWalked = Double(0)
             return self
        }
        public var hasTargetKmWalked:Bool {
             get {
                  return builderResult.hasTargetKmWalked
             }
        }
        public var targetKmWalked:Double {
             get {
                  return builderResult.targetKmWalked
             }
             set (value) {
                 builderResult.hasTargetKmWalked = true
                 builderResult.targetKmWalked = value
             }
        }
        public func setTargetKmWalked(value:Double) -> ResponseEnvelop.EggIncubator.Builder {
          self.targetKmWalked = value
          return self
        }
        public func clearTargetKmWalked() -> ResponseEnvelop.EggIncubator.Builder{
             builderResult.hasTargetKmWalked = false
             builderResult.targetKmWalked = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.EggIncubator.Builder {
          builderResult = ResponseEnvelop.EggIncubator()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.EggIncubator.Builder {
          return try ResponseEnvelop.EggIncubator.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.EggIncubator {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.EggIncubator {
          let returnMe:ResponseEnvelop.EggIncubator = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.EggIncubator) throws -> ResponseEnvelop.EggIncubator.Builder {
          if other == ResponseEnvelop.EggIncubator() {
           return self
          }
          if other.hasItemId {
               itemId = other.itemId
          }
          if other.hasItemType {
               itemType = other.itemType
          }
          if other.hasIncubatorType {
               incubatorType = other.incubatorType
          }
          if other.hasUsesRemaining {
               usesRemaining = other.usesRemaining
          }
          if other.hasPokemonId {
               pokemonId = other.pokemonId
          }
          if other.hasStartKmWalked {
               startKmWalked = other.startKmWalked
          }
          if other.hasTargetKmWalked {
               targetKmWalked = other.targetKmWalked
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.EggIncubator.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EggIncubator.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              itemId = try input.readString()

            case 16 :
              let valueIntitemType = try input.readEnum()
              if let enumsitemType = ResponseEnvelop.ItemType(rawValue:valueIntitemType){
                   itemType = enumsitemType
              } else {
                   try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntitemType))
              }

            case 24 :
              let valueIntincubatorType = try input.readEnum()
              if let enumsincubatorType = ResponseEnvelop.EggIncubatorType(rawValue:valueIntincubatorType){
                   incubatorType = enumsincubatorType
              } else {
                   try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntincubatorType))
              }

            case 32 :
              usesRemaining = try input.readInt32()

            case 40 :
              pokemonId = try input.readInt64()

            case 49 :
              startKmWalked = try input.readDouble()

            case 57 :
              targetKmWalked = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class PokemonFamily : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var familyId:ResponseEnvelop.PokemonFamilyId = ResponseEnvelop.PokemonFamilyId.FamilyUnset
      public private(set) var hasFamilyId:Bool = false
      public private(set) var candy:Int32 = Int32(0)

      public private(set) var hasCandy:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasFamilyId {
          try output.writeEnum(1, value:familyId.rawValue)
        }
        if hasCandy {
          try output.writeInt32(2, value:candy)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasFamilyId) {
          serialize_size += familyId.rawValue.computeEnumSize(1)
        }
        if hasCandy {
          serialize_size += candy.computeInt32Size(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.PokemonFamily> {
        var mergedArray = Array<ResponseEnvelop.PokemonFamily>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokemonFamily? {
        return try ResponseEnvelop.PokemonFamily.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.PokemonFamily {
        return try ResponseEnvelop.PokemonFamily.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonFamily {
        return try ResponseEnvelop.PokemonFamily.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.PokemonFamily {
        return try ResponseEnvelop.PokemonFamily.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonFamily {
        return try ResponseEnvelop.PokemonFamily.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokemonFamily {
        return try ResponseEnvelop.PokemonFamily.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonFamily {
        return try ResponseEnvelop.PokemonFamily.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.PokemonFamily.Builder {
        return ResponseEnvelop.PokemonFamily.classBuilder() as! ResponseEnvelop.PokemonFamily.Builder
      }
      public func getBuilder() -> ResponseEnvelop.PokemonFamily.Builder {
        return classBuilder() as! ResponseEnvelop.PokemonFamily.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokemonFamily.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.PokemonFamily.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.PokemonFamily.Builder {
        return try ResponseEnvelop.PokemonFamily.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.PokemonFamily) throws -> ResponseEnvelop.PokemonFamily.Builder {
        return try ResponseEnvelop.PokemonFamily.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasFamilyId) {
          output += "\(indent) familyId: \(familyId.description)\n"
        }
        if hasCandy {
          output += "\(indent) candy: \(candy) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasFamilyId {
                 hashCode = (hashCode &* 31) &+ Int(familyId.rawValue)
              }
              if hasCandy {
                 hashCode = (hashCode &* 31) &+ candy.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.PokemonFamily"
      }
      override public func className() -> String {
          return "ResponseEnvelop.PokemonFamily"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.PokemonFamily.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.PokemonFamily = ResponseEnvelop.PokemonFamily()
        public func getMessage() -> ResponseEnvelop.PokemonFamily {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasFamilyId:Bool{
              get {
                  return builderResult.hasFamilyId
              }
          }
          public var familyId:ResponseEnvelop.PokemonFamilyId {
              get {
                  return builderResult.familyId
              }
              set (value) {
                  builderResult.hasFamilyId = true
                  builderResult.familyId = value
              }
          }
          public func setFamilyId(value:ResponseEnvelop.PokemonFamilyId) -> ResponseEnvelop.PokemonFamily.Builder {
            self.familyId = value
            return self
          }
          public func clearFamilyId() -> ResponseEnvelop.PokemonFamily.Builder {
             builderResult.hasFamilyId = false
             builderResult.familyId = .FamilyUnset
             return self
          }
        public var hasCandy:Bool {
             get {
                  return builderResult.hasCandy
             }
        }
        public var candy:Int32 {
             get {
                  return builderResult.candy
             }
             set (value) {
                 builderResult.hasCandy = true
                 builderResult.candy = value
             }
        }
        public func setCandy(value:Int32) -> ResponseEnvelop.PokemonFamily.Builder {
          self.candy = value
          return self
        }
        public func clearCandy() -> ResponseEnvelop.PokemonFamily.Builder{
             builderResult.hasCandy = false
             builderResult.candy = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.PokemonFamily.Builder {
          builderResult = ResponseEnvelop.PokemonFamily()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.PokemonFamily.Builder {
          return try ResponseEnvelop.PokemonFamily.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.PokemonFamily {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.PokemonFamily {
          let returnMe:ResponseEnvelop.PokemonFamily = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.PokemonFamily) throws -> ResponseEnvelop.PokemonFamily.Builder {
          if other == ResponseEnvelop.PokemonFamily() {
           return self
          }
          if other.hasFamilyId {
               familyId = other.familyId
          }
          if other.hasCandy {
               candy = other.candy
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.PokemonFamily.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.PokemonFamily.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntfamilyId = try input.readEnum()
              if let enumsfamilyId = ResponseEnvelop.PokemonFamilyId(rawValue:valueIntfamilyId){
                   familyId = enumsfamilyId
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntfamilyId))
              }

            case 16 :
              candy = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class CatchPokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


        //Enum type declaration start 

        public enum CatchStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case CatchError = 0
          case CatchSuccess = 1
          case CatchEscape = 2
          case CatchFlee = 3
          case CatchMissed = 4

          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          private func getDescription() -> String { 
              switch self {
                  case .CatchError: return ".CatchError"
                  case .CatchSuccess: return ".CatchSuccess"
                  case .CatchEscape: return ".CatchEscape"
                  case .CatchFlee: return ".CatchFlee"
                  case .CatchMissed: return ".CatchMissed"
              }
          }
        }

        //Enum type declaration end 

      public private(set) var status:ResponseEnvelop.CatchPokemonResponse.CatchStatus = ResponseEnvelop.CatchPokemonResponse.CatchStatus.CatchError
      public private(set) var hasStatus:Bool = false
      //optional uint64 CapturedPokemonId = 3;
      //optional CaptureAward CaptureAward = 4;
      public private(set) var missPercent:Double = Double(0)

      public private(set) var hasMissPercent:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasStatus {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasStatus {
          try output.writeEnum(1, value:status.rawValue)
        }
        if hasMissPercent {
          try output.writeDouble(2, value:missPercent)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasStatus) {
          serialize_size += status.rawValue.computeEnumSize(1)
        }
        if hasMissPercent {
          serialize_size += missPercent.computeDoubleSize(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.CatchPokemonResponse> {
        var mergedArray = Array<ResponseEnvelop.CatchPokemonResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.CatchPokemonResponse? {
        return try ResponseEnvelop.CatchPokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.CatchPokemonResponse {
        return try ResponseEnvelop.CatchPokemonResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CatchPokemonResponse {
        return try ResponseEnvelop.CatchPokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.CatchPokemonResponse {
        return try ResponseEnvelop.CatchPokemonResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CatchPokemonResponse {
        return try ResponseEnvelop.CatchPokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.CatchPokemonResponse {
        return try ResponseEnvelop.CatchPokemonResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CatchPokemonResponse {
        return try ResponseEnvelop.CatchPokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.CatchPokemonResponse.Builder {
        return ResponseEnvelop.CatchPokemonResponse.classBuilder() as! ResponseEnvelop.CatchPokemonResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.CatchPokemonResponse.Builder {
        return classBuilder() as! ResponseEnvelop.CatchPokemonResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.CatchPokemonResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.CatchPokemonResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.CatchPokemonResponse.Builder {
        return try ResponseEnvelop.CatchPokemonResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.CatchPokemonResponse) throws -> ResponseEnvelop.CatchPokemonResponse.Builder {
        return try ResponseEnvelop.CatchPokemonResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasStatus) {
          output += "\(indent) status: \(status.description)\n"
        }
        if hasMissPercent {
          output += "\(indent) missPercent: \(missPercent) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasStatus {
                 hashCode = (hashCode &* 31) &+ Int(status.rawValue)
              }
              if hasMissPercent {
                 hashCode = (hashCode &* 31) &+ missPercent.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.CatchPokemonResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.CatchPokemonResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.CatchPokemonResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.CatchPokemonResponse = ResponseEnvelop.CatchPokemonResponse()
        public func getMessage() -> ResponseEnvelop.CatchPokemonResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasStatus:Bool{
              get {
                  return builderResult.hasStatus
              }
          }
          public var status:ResponseEnvelop.CatchPokemonResponse.CatchStatus {
              get {
                  return builderResult.status
              }
              set (value) {
                  builderResult.hasStatus = true
                  builderResult.status = value
              }
          }
          public func setStatus(value:ResponseEnvelop.CatchPokemonResponse.CatchStatus) -> ResponseEnvelop.CatchPokemonResponse.Builder {
            self.status = value
            return self
          }
          public func clearStatus() -> ResponseEnvelop.CatchPokemonResponse.Builder {
             builderResult.hasStatus = false
             builderResult.status = .CatchError
             return self
          }
        public var hasMissPercent:Bool {
             get {
                  return builderResult.hasMissPercent
             }
        }
        public var missPercent:Double {
             get {
                  return builderResult.missPercent
             }
             set (value) {
                 builderResult.hasMissPercent = true
                 builderResult.missPercent = value
             }
        }
        public func setMissPercent(value:Double) -> ResponseEnvelop.CatchPokemonResponse.Builder {
          self.missPercent = value
          return self
        }
        public func clearMissPercent() -> ResponseEnvelop.CatchPokemonResponse.Builder{
             builderResult.hasMissPercent = false
             builderResult.missPercent = Double(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.CatchPokemonResponse.Builder {
          builderResult = ResponseEnvelop.CatchPokemonResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.CatchPokemonResponse.Builder {
          return try ResponseEnvelop.CatchPokemonResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.CatchPokemonResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.CatchPokemonResponse {
          let returnMe:ResponseEnvelop.CatchPokemonResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.CatchPokemonResponse) throws -> ResponseEnvelop.CatchPokemonResponse.Builder {
          if other == ResponseEnvelop.CatchPokemonResponse() {
           return self
          }
          if other.hasStatus {
               status = other.status
          }
          if other.hasMissPercent {
               missPercent = other.missPercent
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.CatchPokemonResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CatchPokemonResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntstatus = try input.readEnum()
              if let enumsstatus = ResponseEnvelop.CatchPokemonResponse.CatchStatus(rawValue:valueIntstatus){
                   status = enumsstatus
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntstatus))
              }

            case 17 :
              missPercent = try input.readDouble()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class CaptureAward : GeneratedMessage, GeneratedMessageProtocol {
      private var activityTypeMemoizedSerializedSize:Int32 = 0
      public private(set) var activityType:Array<ResponseEnvelop.ActivityType> = Array<ResponseEnvelop.ActivityType>()
      public private(set) var xp:Array<Int32> = Array<Int32>()
      public private(set) var candy:Array<Int32> = Array<Int32>()
      public private(set) var stardust:Array<Int32> = Array<Int32>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        for oneValueOfactivityType in activityType {
            try output.writeEnum(1, value:oneValueOfactivityType.rawValue)
        }
        if !xp.isEmpty {
          for oneValuexp in xp {
            try output.writeInt32(2, value:oneValuexp)
          }
        }
        if !candy.isEmpty {
          for oneValuecandy in candy {
            try output.writeInt32(3, value:oneValuecandy)
          }
        }
        if !stardust.isEmpty {
          for oneValuestardust in stardust {
            try output.writeInt32(4, value:oneValuestardust)
          }
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        var dataSizeactivityType:Int32 = 0
        for oneValueOfactivityType in activityType {
            dataSizeactivityType += oneValueOfactivityType.rawValue.computeEnumSizeNoTag()
        }
        serialize_size += dataSizeactivityType
        serialize_size += (1 * Int32(activityType.count))
        var dataSizeXp:Int32 = 0
        for oneValuexp in xp {
            dataSizeXp += oneValuexp.computeInt32SizeNoTag()
        }
        serialize_size += dataSizeXp
        serialize_size += 1 * Int32(xp.count)
        var dataSizeCandy:Int32 = 0
        for oneValuecandy in candy {
            dataSizeCandy += oneValuecandy.computeInt32SizeNoTag()
        }
        serialize_size += dataSizeCandy
        serialize_size += 1 * Int32(candy.count)
        var dataSizeStardust:Int32 = 0
        for oneValuestardust in stardust {
            dataSizeStardust += oneValuestardust.computeInt32SizeNoTag()
        }
        serialize_size += dataSizeStardust
        serialize_size += 1 * Int32(stardust.count)
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.CaptureAward> {
        var mergedArray = Array<ResponseEnvelop.CaptureAward>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.CaptureAward? {
        return try ResponseEnvelop.CaptureAward.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.CaptureAward {
        return try ResponseEnvelop.CaptureAward.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CaptureAward {
        return try ResponseEnvelop.CaptureAward.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.CaptureAward {
        return try ResponseEnvelop.CaptureAward.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CaptureAward {
        return try ResponseEnvelop.CaptureAward.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.CaptureAward {
        return try ResponseEnvelop.CaptureAward.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CaptureAward {
        return try ResponseEnvelop.CaptureAward.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.CaptureAward.Builder {
        return ResponseEnvelop.CaptureAward.classBuilder() as! ResponseEnvelop.CaptureAward.Builder
      }
      public func getBuilder() -> ResponseEnvelop.CaptureAward.Builder {
        return classBuilder() as! ResponseEnvelop.CaptureAward.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.CaptureAward.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.CaptureAward.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.CaptureAward.Builder {
        return try ResponseEnvelop.CaptureAward.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.CaptureAward) throws -> ResponseEnvelop.CaptureAward.Builder {
        return try ResponseEnvelop.CaptureAward.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        var activityTypeElementIndex:Int = 0
        for oneValueOfactivityType in activityType {
            output += "\(indent) activityType[\(activityTypeElementIndex)]: \(oneValueOfactivityType.description)\n"
            activityTypeElementIndex += 1
        }
        var xpElementIndex:Int = 0
        for oneValuexp in xp  {
            output += "\(indent) xp[\(xpElementIndex)]: \(oneValuexp)\n"
            xpElementIndex += 1
        }
        var candyElementIndex:Int = 0
        for oneValuecandy in candy  {
            output += "\(indent) candy[\(candyElementIndex)]: \(oneValuecandy)\n"
            candyElementIndex += 1
        }
        var stardustElementIndex:Int = 0
        for oneValuestardust in stardust  {
            output += "\(indent) stardust[\(stardustElementIndex)]: \(oneValuestardust)\n"
            stardustElementIndex += 1
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for oneValueOfactivityType in activityType {
                  hashCode = (hashCode &* 31) &+ Int(oneValueOfactivityType.rawValue)
              }
              for oneValuexp in xp {
                  hashCode = (hashCode &* 31) &+ oneValuexp.hashValue
              }
              for oneValuecandy in candy {
                  hashCode = (hashCode &* 31) &+ oneValuecandy.hashValue
              }
              for oneValuestardust in stardust {
                  hashCode = (hashCode &* 31) &+ oneValuestardust.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.CaptureAward"
      }
      override public func className() -> String {
          return "ResponseEnvelop.CaptureAward"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.CaptureAward.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.CaptureAward = ResponseEnvelop.CaptureAward()
        public func getMessage() -> ResponseEnvelop.CaptureAward {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var activityType:Array<ResponseEnvelop.ActivityType> {
            get {
                return builderResult.activityType
            }
            set (value) {
                builderResult.activityType = value
            }
        }
        public func setActivityType(value:Array<ResponseEnvelop.ActivityType>) -> ResponseEnvelop.CaptureAward.Builder {
          self.activityType = value
          return self
        }
        public func clearActivityType() -> ResponseEnvelop.CaptureAward.Builder {
          builderResult.activityType.removeAll(keepCapacity: false)
          return self
        }
        public var xp:Array<Int32> {
             get {
                 return builderResult.xp
             }
             set (array) {
                 builderResult.xp = array
             }
        }
        public func setXp(value:Array<Int32>) -> ResponseEnvelop.CaptureAward.Builder {
          self.xp = value
          return self
        }
        public func clearXp() -> ResponseEnvelop.CaptureAward.Builder {
           builderResult.xp.removeAll(keepCapacity: false)
           return self
        }
        public var candy:Array<Int32> {
             get {
                 return builderResult.candy
             }
             set (array) {
                 builderResult.candy = array
             }
        }
        public func setCandy(value:Array<Int32>) -> ResponseEnvelop.CaptureAward.Builder {
          self.candy = value
          return self
        }
        public func clearCandy() -> ResponseEnvelop.CaptureAward.Builder {
           builderResult.candy.removeAll(keepCapacity: false)
           return self
        }
        public var stardust:Array<Int32> {
             get {
                 return builderResult.stardust
             }
             set (array) {
                 builderResult.stardust = array
             }
        }
        public func setStardust(value:Array<Int32>) -> ResponseEnvelop.CaptureAward.Builder {
          self.stardust = value
          return self
        }
        public func clearStardust() -> ResponseEnvelop.CaptureAward.Builder {
           builderResult.stardust.removeAll(keepCapacity: false)
           return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.CaptureAward.Builder {
          builderResult = ResponseEnvelop.CaptureAward()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.CaptureAward.Builder {
          return try ResponseEnvelop.CaptureAward.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.CaptureAward {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.CaptureAward {
          let returnMe:ResponseEnvelop.CaptureAward = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.CaptureAward) throws -> ResponseEnvelop.CaptureAward.Builder {
          if other == ResponseEnvelop.CaptureAward() {
           return self
          }
          if !other.activityType.isEmpty {
             builderResult.activityType += other.activityType
          }
          if !other.xp.isEmpty {
              builderResult.xp += other.xp
          }
          if !other.candy.isEmpty {
              builderResult.candy += other.candy
          }
          if !other.stardust.isEmpty {
              builderResult.stardust += other.stardust
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.CaptureAward.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CaptureAward.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntactivityType = try input.readEnum()
              if let enumsactivityType = ResponseEnvelop.ActivityType(rawValue:valueIntactivityType) {
                   builderResult.activityType += [enumsactivityType]
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntactivityType))
              }

            case 16 :
              xp += [try input.readInt32()]

            case 24 :
              candy += [try input.readInt32()]

            case 32 :
              stardust += [try input.readInt32()]

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class CaptureProbability : GeneratedMessage, GeneratedMessageProtocol {
      private var pokeballTypeMemoizedSerializedSize:Int32 = 0
      public private(set) var pokeballType:Array<ResponseEnvelop.ItemId> = Array<ResponseEnvelop.ItemId>()
      public private(set) var captureProbability:Array<Float> = Array<Float>()
      public private(set) var reticleDifficultySize:Float = Float(0)

      public private(set) var hasReticleDifficultySize:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        for oneValueOfpokeballType in pokeballType {
            try output.writeEnum(1, value:oneValueOfpokeballType.rawValue)
        }
        if !captureProbability.isEmpty {
          for oneValuecaptureProbability in captureProbability {
            try output.writeFloat(2, value:oneValuecaptureProbability)
          }
        }
        if hasReticleDifficultySize {
          try output.writeFloat(12, value:reticleDifficultySize)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        var dataSizepokeballType:Int32 = 0
        for oneValueOfpokeballType in pokeballType {
            dataSizepokeballType += oneValueOfpokeballType.rawValue.computeEnumSizeNoTag()
        }
        serialize_size += dataSizepokeballType
        serialize_size += (1 * Int32(pokeballType.count))
        var dataSizeCaptureProbability:Int32 = 0
        dataSizeCaptureProbability = 4 * Int32(captureProbability.count)
        serialize_size += dataSizeCaptureProbability
        serialize_size += 1 * Int32(captureProbability.count)
        if hasReticleDifficultySize {
          serialize_size += reticleDifficultySize.computeFloatSize(12)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.CaptureProbability> {
        var mergedArray = Array<ResponseEnvelop.CaptureProbability>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.CaptureProbability? {
        return try ResponseEnvelop.CaptureProbability.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.CaptureProbability {
        return try ResponseEnvelop.CaptureProbability.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CaptureProbability {
        return try ResponseEnvelop.CaptureProbability.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.CaptureProbability {
        return try ResponseEnvelop.CaptureProbability.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CaptureProbability {
        return try ResponseEnvelop.CaptureProbability.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.CaptureProbability {
        return try ResponseEnvelop.CaptureProbability.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CaptureProbability {
        return try ResponseEnvelop.CaptureProbability.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.CaptureProbability.Builder {
        return ResponseEnvelop.CaptureProbability.classBuilder() as! ResponseEnvelop.CaptureProbability.Builder
      }
      public func getBuilder() -> ResponseEnvelop.CaptureProbability.Builder {
        return classBuilder() as! ResponseEnvelop.CaptureProbability.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.CaptureProbability.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.CaptureProbability.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.CaptureProbability.Builder {
        return try ResponseEnvelop.CaptureProbability.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.CaptureProbability) throws -> ResponseEnvelop.CaptureProbability.Builder {
        return try ResponseEnvelop.CaptureProbability.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        var pokeballTypeElementIndex:Int = 0
        for oneValueOfpokeballType in pokeballType {
            output += "\(indent) pokeballType[\(pokeballTypeElementIndex)]: \(oneValueOfpokeballType.description)\n"
            pokeballTypeElementIndex += 1
        }
        var captureProbabilityElementIndex:Int = 0
        for oneValuecaptureProbability in captureProbability  {
            output += "\(indent) captureProbability[\(captureProbabilityElementIndex)]: \(oneValuecaptureProbability)\n"
            captureProbabilityElementIndex += 1
        }
        if hasReticleDifficultySize {
          output += "\(indent) reticleDifficultySize: \(reticleDifficultySize) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              for oneValueOfpokeballType in pokeballType {
                  hashCode = (hashCode &* 31) &+ Int(oneValueOfpokeballType.rawValue)
              }
              for oneValuecaptureProbability in captureProbability {
                  hashCode = (hashCode &* 31) &+ oneValuecaptureProbability.hashValue
              }
              if hasReticleDifficultySize {
                 hashCode = (hashCode &* 31) &+ reticleDifficultySize.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.CaptureProbability"
      }
      override public func className() -> String {
          return "ResponseEnvelop.CaptureProbability"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.CaptureProbability.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.CaptureProbability = ResponseEnvelop.CaptureProbability()
        public func getMessage() -> ResponseEnvelop.CaptureProbability {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var pokeballType:Array<ResponseEnvelop.ItemId> {
            get {
                return builderResult.pokeballType
            }
            set (value) {
                builderResult.pokeballType = value
            }
        }
        public func setPokeballType(value:Array<ResponseEnvelop.ItemId>) -> ResponseEnvelop.CaptureProbability.Builder {
          self.pokeballType = value
          return self
        }
        public func clearPokeballType() -> ResponseEnvelop.CaptureProbability.Builder {
          builderResult.pokeballType.removeAll(keepCapacity: false)
          return self
        }
        public var captureProbability:Array<Float> {
             get {
                 return builderResult.captureProbability
             }
             set (array) {
                 builderResult.captureProbability = array
             }
        }
        public func setCaptureProbability(value:Array<Float>) -> ResponseEnvelop.CaptureProbability.Builder {
          self.captureProbability = value
          return self
        }
        public func clearCaptureProbability() -> ResponseEnvelop.CaptureProbability.Builder {
           builderResult.captureProbability.removeAll(keepCapacity: false)
           return self
        }
        public var hasReticleDifficultySize:Bool {
             get {
                  return builderResult.hasReticleDifficultySize
             }
        }
        public var reticleDifficultySize:Float {
             get {
                  return builderResult.reticleDifficultySize
             }
             set (value) {
                 builderResult.hasReticleDifficultySize = true
                 builderResult.reticleDifficultySize = value
             }
        }
        public func setReticleDifficultySize(value:Float) -> ResponseEnvelop.CaptureProbability.Builder {
          self.reticleDifficultySize = value
          return self
        }
        public func clearReticleDifficultySize() -> ResponseEnvelop.CaptureProbability.Builder{
             builderResult.hasReticleDifficultySize = false
             builderResult.reticleDifficultySize = Float(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.CaptureProbability.Builder {
          builderResult = ResponseEnvelop.CaptureProbability()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.CaptureProbability.Builder {
          return try ResponseEnvelop.CaptureProbability.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.CaptureProbability {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.CaptureProbability {
          let returnMe:ResponseEnvelop.CaptureProbability = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.CaptureProbability) throws -> ResponseEnvelop.CaptureProbability.Builder {
          if other == ResponseEnvelop.CaptureProbability() {
           return self
          }
          if !other.pokeballType.isEmpty {
             builderResult.pokeballType += other.pokeballType
          }
          if !other.captureProbability.isEmpty {
              builderResult.captureProbability += other.captureProbability
          }
          if other.hasReticleDifficultySize {
               reticleDifficultySize = other.reticleDifficultySize
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.CaptureProbability.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.CaptureProbability.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntpokeballType = try input.readEnum()
              if let enumspokeballType = ResponseEnvelop.ItemId(rawValue:valueIntpokeballType) {
                   builderResult.pokeballType += [enumspokeballType]
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntpokeballType))
              }

            case 21 :
              captureProbability += [try input.readFloat()]

            case 101 :
              reticleDifficultySize = try input.readFloat()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class EncounterResponse : GeneratedMessage, GeneratedMessageProtocol {


        //Enum type declaration start 

        public enum Background:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case Park = 0
          case Desert = 1

          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          private func getDescription() -> String { 
              switch self {
                  case .Park: return ".Park"
                  case .Desert: return ".Desert"
              }
          }
        }

        //Enum type declaration end 



        //Enum type declaration start 

        public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case EncounterError = 0
          case EncounterSuccess = 1
          case EncounterNotFound = 2
          case EncounterClosed = 3
          case EncounterPokemonFled = 4
          case EncounterNotInRange = 5
          case EncounterAlreadyHappened = 6
          case PokemonInventoryFull = 7

          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          private func getDescription() -> String { 
              switch self {
                  case .EncounterError: return ".EncounterError"
                  case .EncounterSuccess: return ".EncounterSuccess"
                  case .EncounterNotFound: return ".EncounterNotFound"
                  case .EncounterClosed: return ".EncounterClosed"
                  case .EncounterPokemonFled: return ".EncounterPokemonFled"
                  case .EncounterNotInRange: return ".EncounterNotInRange"
                  case .EncounterAlreadyHappened: return ".EncounterAlreadyHappened"
                  case .PokemonInventoryFull: return ".PokemonInventoryFull"
              }
          }
        }

        //Enum type declaration end 

      public private(set) var wildPokemon:ResponseEnvelop.WildPokemonProto!
      public private(set) var hasWildPokemon:Bool = false
      public private(set) var encounterBackground:ResponseEnvelop.EncounterResponse.Background = ResponseEnvelop.EncounterResponse.Background.Park
      public private(set) var hasEncounterBackground:Bool = false
      public private(set) var encounterStatus:ResponseEnvelop.EncounterResponse.Status = ResponseEnvelop.EncounterResponse.Status.EncounterError
      public private(set) var hasEncounterStatus:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasWildPokemon {
          try output.writeMessage(1, value:wildPokemon)
        }
        if hasEncounterBackground {
          try output.writeEnum(2, value:encounterBackground.rawValue)
        }
        if hasEncounterStatus {
          try output.writeEnum(3, value:encounterStatus.rawValue)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasWildPokemon {
            if let varSizewildPokemon = wildPokemon?.computeMessageSize(1) {
                serialize_size += varSizewildPokemon
            }
        }
        if (hasEncounterBackground) {
          serialize_size += encounterBackground.rawValue.computeEnumSize(2)
        }
        if (hasEncounterStatus) {
          serialize_size += encounterStatus.rawValue.computeEnumSize(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.EncounterResponse> {
        var mergedArray = Array<ResponseEnvelop.EncounterResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.EncounterResponse? {
        return try ResponseEnvelop.EncounterResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.EncounterResponse {
        return try ResponseEnvelop.EncounterResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EncounterResponse {
        return try ResponseEnvelop.EncounterResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.EncounterResponse {
        return try ResponseEnvelop.EncounterResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EncounterResponse {
        return try ResponseEnvelop.EncounterResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.EncounterResponse {
        return try ResponseEnvelop.EncounterResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EncounterResponse {
        return try ResponseEnvelop.EncounterResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.EncounterResponse.Builder {
        return ResponseEnvelop.EncounterResponse.classBuilder() as! ResponseEnvelop.EncounterResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.EncounterResponse.Builder {
        return classBuilder() as! ResponseEnvelop.EncounterResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.EncounterResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.EncounterResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.EncounterResponse.Builder {
        return try ResponseEnvelop.EncounterResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.EncounterResponse) throws -> ResponseEnvelop.EncounterResponse.Builder {
        return try ResponseEnvelop.EncounterResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasWildPokemon {
          output += "\(indent) wildPokemon {\n"
          if let outDescWildPokemon = wildPokemon {
            output += try outDescWildPokemon.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if (hasEncounterBackground) {
          output += "\(indent) encounterBackground: \(encounterBackground.description)\n"
        }
        if (hasEncounterStatus) {
          output += "\(indent) encounterStatus: \(encounterStatus.description)\n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasWildPokemon {
                  if let hashValuewildPokemon = wildPokemon?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuewildPokemon
                  }
              }
              if hasEncounterBackground {
                 hashCode = (hashCode &* 31) &+ Int(encounterBackground.rawValue)
              }
              if hasEncounterStatus {
                 hashCode = (hashCode &* 31) &+ Int(encounterStatus.rawValue)
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.EncounterResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.EncounterResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.EncounterResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.EncounterResponse = ResponseEnvelop.EncounterResponse()
        public func getMessage() -> ResponseEnvelop.EncounterResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasWildPokemon:Bool {
             get {
                 return builderResult.hasWildPokemon
             }
        }
        public var wildPokemon:ResponseEnvelop.WildPokemonProto! {
             get {
                 if wildPokemonBuilder_ != nil {
                    builderResult.wildPokemon = wildPokemonBuilder_.getMessage()
                 }
                 return builderResult.wildPokemon
             }
             set (value) {
                 builderResult.hasWildPokemon = true
                 builderResult.wildPokemon = value
             }
        }
        private var wildPokemonBuilder_:ResponseEnvelop.WildPokemonProto.Builder! {
             didSet {
                builderResult.hasWildPokemon = true
             }
        }
        public func getWildPokemonBuilder() -> ResponseEnvelop.WildPokemonProto.Builder {
          if wildPokemonBuilder_ == nil {
             wildPokemonBuilder_ = ResponseEnvelop.WildPokemonProto.Builder()
             builderResult.wildPokemon = wildPokemonBuilder_.getMessage()
             if wildPokemon != nil {
                try! wildPokemonBuilder_.mergeFrom(wildPokemon)
             }
          }
          return wildPokemonBuilder_
        }
        public func setWildPokemon(value:ResponseEnvelop.WildPokemonProto!) -> ResponseEnvelop.EncounterResponse.Builder {
          self.wildPokemon = value
          return self
        }
        public func mergeWildPokemon(value:ResponseEnvelop.WildPokemonProto) throws -> ResponseEnvelop.EncounterResponse.Builder {
          if builderResult.hasWildPokemon {
            builderResult.wildPokemon = try ResponseEnvelop.WildPokemonProto.builderWithPrototype(builderResult.wildPokemon).mergeFrom(value).buildPartial()
          } else {
            builderResult.wildPokemon = value
          }
          builderResult.hasWildPokemon = true
          return self
        }
        public func clearWildPokemon() -> ResponseEnvelop.EncounterResponse.Builder {
          wildPokemonBuilder_ = nil
          builderResult.hasWildPokemon = false
          builderResult.wildPokemon = nil
          return self
        }
          public var hasEncounterBackground:Bool{
              get {
                  return builderResult.hasEncounterBackground
              }
          }
          public var encounterBackground:ResponseEnvelop.EncounterResponse.Background {
              get {
                  return builderResult.encounterBackground
              }
              set (value) {
                  builderResult.hasEncounterBackground = true
                  builderResult.encounterBackground = value
              }
          }
          public func setEncounterBackground(value:ResponseEnvelop.EncounterResponse.Background) -> ResponseEnvelop.EncounterResponse.Builder {
            self.encounterBackground = value
            return self
          }
          public func clearEncounterBackground() -> ResponseEnvelop.EncounterResponse.Builder {
             builderResult.hasEncounterBackground = false
             builderResult.encounterBackground = .Park
             return self
          }
          public var hasEncounterStatus:Bool{
              get {
                  return builderResult.hasEncounterStatus
              }
          }
          public var encounterStatus:ResponseEnvelop.EncounterResponse.Status {
              get {
                  return builderResult.encounterStatus
              }
              set (value) {
                  builderResult.hasEncounterStatus = true
                  builderResult.encounterStatus = value
              }
          }
          public func setEncounterStatus(value:ResponseEnvelop.EncounterResponse.Status) -> ResponseEnvelop.EncounterResponse.Builder {
            self.encounterStatus = value
            return self
          }
          public func clearEncounterStatus() -> ResponseEnvelop.EncounterResponse.Builder {
             builderResult.hasEncounterStatus = false
             builderResult.encounterStatus = .EncounterError
             return self
          }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.EncounterResponse.Builder {
          builderResult = ResponseEnvelop.EncounterResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.EncounterResponse.Builder {
          return try ResponseEnvelop.EncounterResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.EncounterResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.EncounterResponse {
          let returnMe:ResponseEnvelop.EncounterResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.EncounterResponse) throws -> ResponseEnvelop.EncounterResponse.Builder {
          if other == ResponseEnvelop.EncounterResponse() {
           return self
          }
          if (other.hasWildPokemon) {
              try mergeWildPokemon(other.wildPokemon)
          }
          if other.hasEncounterBackground {
               encounterBackground = other.encounterBackground
          }
          if other.hasEncounterStatus {
               encounterStatus = other.encounterStatus
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.EncounterResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EncounterResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              let subBuilder:ResponseEnvelop.WildPokemonProto.Builder = ResponseEnvelop.WildPokemonProto.Builder()
              if hasWildPokemon {
                try subBuilder.mergeFrom(wildPokemon)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              wildPokemon = subBuilder.buildPartial()

            case 16 :
              let valueIntencounterBackground = try input.readEnum()
              if let enumsencounterBackground = ResponseEnvelop.EncounterResponse.Background(rawValue:valueIntencounterBackground){
                   encounterBackground = enumsencounterBackground
              } else {
                   try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntencounterBackground))
              }

            case 24 :
              let valueIntencounterStatus = try input.readEnum()
              if let enumsencounterStatus = ResponseEnvelop.EncounterResponse.Status(rawValue:valueIntencounterStatus){
                   encounterStatus = enumsencounterStatus
              } else {
                   try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntencounterStatus))
              }

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class FortSearchResponse : GeneratedMessage, GeneratedMessageProtocol {


        //Enum type declaration start 

        public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case NoResultSet = 0
          case Success = 1
          case OutOfRange = 2
          case InCooldownPeriod = 3
          case InventoryFull = 4

          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          private func getDescription() -> String { 
              switch self {
                  case .NoResultSet: return ".NoResultSet"
                  case .Success: return ".Success"
                  case .OutOfRange: return ".OutOfRange"
                  case .InCooldownPeriod: return ".InCooldownPeriod"
                  case .InventoryFull: return ".InventoryFull"
              }
          }
        }

        //Enum type declaration end 

      public private(set) var result:ResponseEnvelop.FortSearchResponse.Result = ResponseEnvelop.FortSearchResponse.Result.NoResultSet
      public private(set) var hasResult:Bool = false
      public private(set) var itemsAwarded:Array<ResponseEnvelop.ItemAward>  = Array<ResponseEnvelop.ItemAward>()
      public private(set) var gemsAwarded:Int32 = Int32(0)

      public private(set) var hasGemsAwarded:Bool = false
      public private(set) var pokemonDataEgg:ResponseEnvelop.PokemonData!
      public private(set) var hasPokemonDataEgg:Bool = false
      public private(set) var experienceAwarded:Int32 = Int32(0)

      public private(set) var hasExperienceAwarded:Bool = false
      public private(set) var cooldownCompleteTimestampMs:Int64 = Int64(0)

      public private(set) var hasCooldownCompleteTimestampMs:Bool = false
      public private(set) var chainHackSequenceNumber:Int32 = Int32(0)

      public private(set) var hasChainHackSequenceNumber:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasResult {
          try output.writeEnum(1, value:result.rawValue)
        }
        for oneElementitemsAwarded in itemsAwarded {
            try output.writeMessage(2, value:oneElementitemsAwarded)
        }
        if hasGemsAwarded {
          try output.writeInt32(3, value:gemsAwarded)
        }
        if hasPokemonDataEgg {
          try output.writeMessage(4, value:pokemonDataEgg)
        }
        if hasExperienceAwarded {
          try output.writeInt32(5, value:experienceAwarded)
        }
        if hasCooldownCompleteTimestampMs {
          try output.writeInt64(6, value:cooldownCompleteTimestampMs)
        }
        if hasChainHackSequenceNumber {
          try output.writeInt32(7, value:chainHackSequenceNumber)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasResult) {
          serialize_size += result.rawValue.computeEnumSize(1)
        }
        for oneElementitemsAwarded in itemsAwarded {
            serialize_size += oneElementitemsAwarded.computeMessageSize(2)
        }
        if hasGemsAwarded {
          serialize_size += gemsAwarded.computeInt32Size(3)
        }
        if hasPokemonDataEgg {
            if let varSizepokemonDataEgg = pokemonDataEgg?.computeMessageSize(4) {
                serialize_size += varSizepokemonDataEgg
            }
        }
        if hasExperienceAwarded {
          serialize_size += experienceAwarded.computeInt32Size(5)
        }
        if hasCooldownCompleteTimestampMs {
          serialize_size += cooldownCompleteTimestampMs.computeInt64Size(6)
        }
        if hasChainHackSequenceNumber {
          serialize_size += chainHackSequenceNumber.computeInt32Size(7)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.FortSearchResponse> {
        var mergedArray = Array<ResponseEnvelop.FortSearchResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.FortSearchResponse? {
        return try ResponseEnvelop.FortSearchResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.FortSearchResponse {
        return try ResponseEnvelop.FortSearchResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortSearchResponse {
        return try ResponseEnvelop.FortSearchResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.FortSearchResponse {
        return try ResponseEnvelop.FortSearchResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortSearchResponse {
        return try ResponseEnvelop.FortSearchResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.FortSearchResponse {
        return try ResponseEnvelop.FortSearchResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortSearchResponse {
        return try ResponseEnvelop.FortSearchResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.FortSearchResponse.Builder {
        return ResponseEnvelop.FortSearchResponse.classBuilder() as! ResponseEnvelop.FortSearchResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.FortSearchResponse.Builder {
        return classBuilder() as! ResponseEnvelop.FortSearchResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.FortSearchResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.FortSearchResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.FortSearchResponse.Builder {
        return try ResponseEnvelop.FortSearchResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.FortSearchResponse) throws -> ResponseEnvelop.FortSearchResponse.Builder {
        return try ResponseEnvelop.FortSearchResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasResult) {
          output += "\(indent) result: \(result.description)\n"
        }
        var itemsAwardedElementIndex:Int = 0
        for oneElementitemsAwarded in itemsAwarded {
            output += "\(indent) itemsAwarded[\(itemsAwardedElementIndex)] {\n"
            output += try oneElementitemsAwarded.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            itemsAwardedElementIndex += 1
        }
        if hasGemsAwarded {
          output += "\(indent) gemsAwarded: \(gemsAwarded) \n"
        }
        if hasPokemonDataEgg {
          output += "\(indent) pokemonDataEgg {\n"
          if let outDescPokemonDataEgg = pokemonDataEgg {
            output += try outDescPokemonDataEgg.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasExperienceAwarded {
          output += "\(indent) experienceAwarded: \(experienceAwarded) \n"
        }
        if hasCooldownCompleteTimestampMs {
          output += "\(indent) cooldownCompleteTimestampMs: \(cooldownCompleteTimestampMs) \n"
        }
        if hasChainHackSequenceNumber {
          output += "\(indent) chainHackSequenceNumber: \(chainHackSequenceNumber) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasResult {
                 hashCode = (hashCode &* 31) &+ Int(result.rawValue)
              }
              for oneElementitemsAwarded in itemsAwarded {
                  hashCode = (hashCode &* 31) &+ oneElementitemsAwarded.hashValue
              }
              if hasGemsAwarded {
                 hashCode = (hashCode &* 31) &+ gemsAwarded.hashValue
              }
              if hasPokemonDataEgg {
                  if let hashValuepokemonDataEgg = pokemonDataEgg?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuepokemonDataEgg
                  }
              }
              if hasExperienceAwarded {
                 hashCode = (hashCode &* 31) &+ experienceAwarded.hashValue
              }
              if hasCooldownCompleteTimestampMs {
                 hashCode = (hashCode &* 31) &+ cooldownCompleteTimestampMs.hashValue
              }
              if hasChainHackSequenceNumber {
                 hashCode = (hashCode &* 31) &+ chainHackSequenceNumber.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.FortSearchResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.FortSearchResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.FortSearchResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.FortSearchResponse = ResponseEnvelop.FortSearchResponse()
        public func getMessage() -> ResponseEnvelop.FortSearchResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasResult:Bool{
              get {
                  return builderResult.hasResult
              }
          }
          public var result:ResponseEnvelop.FortSearchResponse.Result {
              get {
                  return builderResult.result
              }
              set (value) {
                  builderResult.hasResult = true
                  builderResult.result = value
              }
          }
          public func setResult(value:ResponseEnvelop.FortSearchResponse.Result) -> ResponseEnvelop.FortSearchResponse.Builder {
            self.result = value
            return self
          }
          public func clearResult() -> ResponseEnvelop.FortSearchResponse.Builder {
             builderResult.hasResult = false
             builderResult.result = .NoResultSet
             return self
          }
        public var itemsAwarded:Array<ResponseEnvelop.ItemAward> {
             get {
                 return builderResult.itemsAwarded
             }
             set (value) {
                 builderResult.itemsAwarded = value
             }
        }
        public func setItemsAwarded(value:Array<ResponseEnvelop.ItemAward>) -> ResponseEnvelop.FortSearchResponse.Builder {
          self.itemsAwarded = value
          return self
        }
        public func clearItemsAwarded() -> ResponseEnvelop.FortSearchResponse.Builder {
          builderResult.itemsAwarded.removeAll(keepCapacity: false)
          return self
        }
        public var hasGemsAwarded:Bool {
             get {
                  return builderResult.hasGemsAwarded
             }
        }
        public var gemsAwarded:Int32 {
             get {
                  return builderResult.gemsAwarded
             }
             set (value) {
                 builderResult.hasGemsAwarded = true
                 builderResult.gemsAwarded = value
             }
        }
        public func setGemsAwarded(value:Int32) -> ResponseEnvelop.FortSearchResponse.Builder {
          self.gemsAwarded = value
          return self
        }
        public func clearGemsAwarded() -> ResponseEnvelop.FortSearchResponse.Builder{
             builderResult.hasGemsAwarded = false
             builderResult.gemsAwarded = Int32(0)
             return self
        }
        public var hasPokemonDataEgg:Bool {
             get {
                 return builderResult.hasPokemonDataEgg
             }
        }
        public var pokemonDataEgg:ResponseEnvelop.PokemonData! {
             get {
                 if pokemonDataEggBuilder_ != nil {
                    builderResult.pokemonDataEgg = pokemonDataEggBuilder_.getMessage()
                 }
                 return builderResult.pokemonDataEgg
             }
             set (value) {
                 builderResult.hasPokemonDataEgg = true
                 builderResult.pokemonDataEgg = value
             }
        }
        private var pokemonDataEggBuilder_:ResponseEnvelop.PokemonData.Builder! {
             didSet {
                builderResult.hasPokemonDataEgg = true
             }
        }
        public func getPokemonDataEggBuilder() -> ResponseEnvelop.PokemonData.Builder {
          if pokemonDataEggBuilder_ == nil {
             pokemonDataEggBuilder_ = ResponseEnvelop.PokemonData.Builder()
             builderResult.pokemonDataEgg = pokemonDataEggBuilder_.getMessage()
             if pokemonDataEgg != nil {
                try! pokemonDataEggBuilder_.mergeFrom(pokemonDataEgg)
             }
          }
          return pokemonDataEggBuilder_
        }
        public func setPokemonDataEgg(value:ResponseEnvelop.PokemonData!) -> ResponseEnvelop.FortSearchResponse.Builder {
          self.pokemonDataEgg = value
          return self
        }
        public func mergePokemonDataEgg(value:ResponseEnvelop.PokemonData) throws -> ResponseEnvelop.FortSearchResponse.Builder {
          if builderResult.hasPokemonDataEgg {
            builderResult.pokemonDataEgg = try ResponseEnvelop.PokemonData.builderWithPrototype(builderResult.pokemonDataEgg).mergeFrom(value).buildPartial()
          } else {
            builderResult.pokemonDataEgg = value
          }
          builderResult.hasPokemonDataEgg = true
          return self
        }
        public func clearPokemonDataEgg() -> ResponseEnvelop.FortSearchResponse.Builder {
          pokemonDataEggBuilder_ = nil
          builderResult.hasPokemonDataEgg = false
          builderResult.pokemonDataEgg = nil
          return self
        }
        public var hasExperienceAwarded:Bool {
             get {
                  return builderResult.hasExperienceAwarded
             }
        }
        public var experienceAwarded:Int32 {
             get {
                  return builderResult.experienceAwarded
             }
             set (value) {
                 builderResult.hasExperienceAwarded = true
                 builderResult.experienceAwarded = value
             }
        }
        public func setExperienceAwarded(value:Int32) -> ResponseEnvelop.FortSearchResponse.Builder {
          self.experienceAwarded = value
          return self
        }
        public func clearExperienceAwarded() -> ResponseEnvelop.FortSearchResponse.Builder{
             builderResult.hasExperienceAwarded = false
             builderResult.experienceAwarded = Int32(0)
             return self
        }
        public var hasCooldownCompleteTimestampMs:Bool {
             get {
                  return builderResult.hasCooldownCompleteTimestampMs
             }
        }
        public var cooldownCompleteTimestampMs:Int64 {
             get {
                  return builderResult.cooldownCompleteTimestampMs
             }
             set (value) {
                 builderResult.hasCooldownCompleteTimestampMs = true
                 builderResult.cooldownCompleteTimestampMs = value
             }
        }
        public func setCooldownCompleteTimestampMs(value:Int64) -> ResponseEnvelop.FortSearchResponse.Builder {
          self.cooldownCompleteTimestampMs = value
          return self
        }
        public func clearCooldownCompleteTimestampMs() -> ResponseEnvelop.FortSearchResponse.Builder{
             builderResult.hasCooldownCompleteTimestampMs = false
             builderResult.cooldownCompleteTimestampMs = Int64(0)
             return self
        }
        public var hasChainHackSequenceNumber:Bool {
             get {
                  return builderResult.hasChainHackSequenceNumber
             }
        }
        public var chainHackSequenceNumber:Int32 {
             get {
                  return builderResult.chainHackSequenceNumber
             }
             set (value) {
                 builderResult.hasChainHackSequenceNumber = true
                 builderResult.chainHackSequenceNumber = value
             }
        }
        public func setChainHackSequenceNumber(value:Int32) -> ResponseEnvelop.FortSearchResponse.Builder {
          self.chainHackSequenceNumber = value
          return self
        }
        public func clearChainHackSequenceNumber() -> ResponseEnvelop.FortSearchResponse.Builder{
             builderResult.hasChainHackSequenceNumber = false
             builderResult.chainHackSequenceNumber = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.FortSearchResponse.Builder {
          builderResult = ResponseEnvelop.FortSearchResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.FortSearchResponse.Builder {
          return try ResponseEnvelop.FortSearchResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.FortSearchResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.FortSearchResponse {
          let returnMe:ResponseEnvelop.FortSearchResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.FortSearchResponse) throws -> ResponseEnvelop.FortSearchResponse.Builder {
          if other == ResponseEnvelop.FortSearchResponse() {
           return self
          }
          if other.hasResult {
               result = other.result
          }
          if !other.itemsAwarded.isEmpty  {
             builderResult.itemsAwarded += other.itemsAwarded
          }
          if other.hasGemsAwarded {
               gemsAwarded = other.gemsAwarded
          }
          if (other.hasPokemonDataEgg) {
              try mergePokemonDataEgg(other.pokemonDataEgg)
          }
          if other.hasExperienceAwarded {
               experienceAwarded = other.experienceAwarded
          }
          if other.hasCooldownCompleteTimestampMs {
               cooldownCompleteTimestampMs = other.cooldownCompleteTimestampMs
          }
          if other.hasChainHackSequenceNumber {
               chainHackSequenceNumber = other.chainHackSequenceNumber
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.FortSearchResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortSearchResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntresult = try input.readEnum()
              if let enumsresult = ResponseEnvelop.FortSearchResponse.Result(rawValue:valueIntresult){
                   result = enumsresult
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
              }

            case 18 :
              let subBuilder = ResponseEnvelop.ItemAward.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              itemsAwarded += [subBuilder.buildPartial()]

            case 24 :
              gemsAwarded = try input.readInt32()

            case 34 :
              let subBuilder:ResponseEnvelop.PokemonData.Builder = ResponseEnvelop.PokemonData.Builder()
              if hasPokemonDataEgg {
                try subBuilder.mergeFrom(pokemonDataEgg)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              pokemonDataEgg = subBuilder.buildPartial()

            case 40 :
              experienceAwarded = try input.readInt32()

            case 48 :
              cooldownCompleteTimestampMs = try input.readInt64()

            case 56 :
              chainHackSequenceNumber = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class FortDetailsResponse : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var fortId:String = ""

      public private(set) var hasFortId:Bool = false
      public private(set) var teamColor:ResponseEnvelop.TeamColor = ResponseEnvelop.TeamColor.Neutral
      public private(set) var hasTeamColor:Bool = false
      public private(set) var pokemonData:ResponseEnvelop.PokemonData!
      public private(set) var hasPokemonData:Bool = false
      public private(set) var name:String = ""

      public private(set) var hasName:Bool = false
      public private(set) var imageUrls:Array<String> = Array<String>()
      public private(set) var fp:Int32 = Int32(0)

      public private(set) var hasFp:Bool = false
      public private(set) var stamina:Int32 = Int32(0)

      public private(set) var hasStamina:Bool = false
      public private(set) var maxStamina:Int32 = Int32(0)

      public private(set) var hasMaxStamina:Bool = false
      public private(set) var types:Int32 = Int32(0)

      public private(set) var hasTypes:Bool = false
      public private(set) var latitude:Double = Double(0)

      public private(set) var hasLatitude:Bool = false
      public private(set) var longitude:Double = Double(0)

      public private(set) var hasLongitude:Bool = false
      public private(set) var description_:String = ""

      public private(set) var hasDescription:Bool = false
      public private(set) var modifiers:Array<ResponseEnvelop.FortModifier>  = Array<ResponseEnvelop.FortModifier>()
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasFortId {
          try output.writeString(1, value:fortId)
        }
        if hasTeamColor {
          try output.writeEnum(2, value:teamColor.rawValue)
        }
        if hasPokemonData {
          try output.writeMessage(3, value:pokemonData)
        }
        if hasName {
          try output.writeString(4, value:name)
        }
        if !imageUrls.isEmpty {
          for oneValueimageUrls in imageUrls {
            try output.writeString(5, value:oneValueimageUrls)
          }
        }
        if hasFp {
          try output.writeInt32(6, value:fp)
        }
        if hasStamina {
          try output.writeInt32(7, value:stamina)
        }
        if hasMaxStamina {
          try output.writeInt32(8, value:maxStamina)
        }
        if hasTypes {
          try output.writeInt32(9, value:types)
        }
        if hasLatitude {
          try output.writeDouble(10, value:latitude)
        }
        if hasLongitude {
          try output.writeDouble(11, value:longitude)
        }
        if hasDescription {
          try output.writeString(12, value:description_)
        }
        for oneElementmodifiers in modifiers {
            try output.writeMessage(13, value:oneElementmodifiers)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasFortId {
          serialize_size += fortId.computeStringSize(1)
        }
        if (hasTeamColor) {
          serialize_size += teamColor.rawValue.computeEnumSize(2)
        }
        if hasPokemonData {
            if let varSizepokemonData = pokemonData?.computeMessageSize(3) {
                serialize_size += varSizepokemonData
            }
        }
        if hasName {
          serialize_size += name.computeStringSize(4)
        }
        var dataSizeImageUrls:Int32 = 0
        for oneValueimageUrls in imageUrls {
            dataSizeImageUrls += oneValueimageUrls.computeStringSizeNoTag()
        }
        serialize_size += dataSizeImageUrls
        serialize_size += 1 * Int32(imageUrls.count)
        if hasFp {
          serialize_size += fp.computeInt32Size(6)
        }
        if hasStamina {
          serialize_size += stamina.computeInt32Size(7)
        }
        if hasMaxStamina {
          serialize_size += maxStamina.computeInt32Size(8)
        }
        if hasTypes {
          serialize_size += types.computeInt32Size(9)
        }
        if hasLatitude {
          serialize_size += latitude.computeDoubleSize(10)
        }
        if hasLongitude {
          serialize_size += longitude.computeDoubleSize(11)
        }
        if hasDescription {
          serialize_size += description_.computeStringSize(12)
        }
        for oneElementmodifiers in modifiers {
            serialize_size += oneElementmodifiers.computeMessageSize(13)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.FortDetailsResponse> {
        var mergedArray = Array<ResponseEnvelop.FortDetailsResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.FortDetailsResponse? {
        return try ResponseEnvelop.FortDetailsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.FortDetailsResponse {
        return try ResponseEnvelop.FortDetailsResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortDetailsResponse {
        return try ResponseEnvelop.FortDetailsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.FortDetailsResponse {
        return try ResponseEnvelop.FortDetailsResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortDetailsResponse {
        return try ResponseEnvelop.FortDetailsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.FortDetailsResponse {
        return try ResponseEnvelop.FortDetailsResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortDetailsResponse {
        return try ResponseEnvelop.FortDetailsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.FortDetailsResponse.Builder {
        return ResponseEnvelop.FortDetailsResponse.classBuilder() as! ResponseEnvelop.FortDetailsResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.FortDetailsResponse.Builder {
        return classBuilder() as! ResponseEnvelop.FortDetailsResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.FortDetailsResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.FortDetailsResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.FortDetailsResponse.Builder {
        return try ResponseEnvelop.FortDetailsResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.FortDetailsResponse) throws -> ResponseEnvelop.FortDetailsResponse.Builder {
        return try ResponseEnvelop.FortDetailsResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasFortId {
          output += "\(indent) fortId: \(fortId) \n"
        }
        if (hasTeamColor) {
          output += "\(indent) teamColor: \(teamColor.description)\n"
        }
        if hasPokemonData {
          output += "\(indent) pokemonData {\n"
          if let outDescPokemonData = pokemonData {
            output += try outDescPokemonData.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasName {
          output += "\(indent) name: \(name) \n"
        }
        var imageUrlsElementIndex:Int = 0
        for oneValueimageUrls in imageUrls  {
            output += "\(indent) imageUrls[\(imageUrlsElementIndex)]: \(oneValueimageUrls)\n"
            imageUrlsElementIndex += 1
        }
        if hasFp {
          output += "\(indent) fp: \(fp) \n"
        }
        if hasStamina {
          output += "\(indent) stamina: \(stamina) \n"
        }
        if hasMaxStamina {
          output += "\(indent) maxStamina: \(maxStamina) \n"
        }
        if hasTypes {
          output += "\(indent) types: \(types) \n"
        }
        if hasLatitude {
          output += "\(indent) latitude: \(latitude) \n"
        }
        if hasLongitude {
          output += "\(indent) longitude: \(longitude) \n"
        }
        if hasDescription {
          output += "\(indent) description_: \(description_) \n"
        }
        var modifiersElementIndex:Int = 0
        for oneElementmodifiers in modifiers {
            output += "\(indent) modifiers[\(modifiersElementIndex)] {\n"
            output += try oneElementmodifiers.getDescription("\(indent)  ")
            output += "\(indent)}\n"
            modifiersElementIndex += 1
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasFortId {
                 hashCode = (hashCode &* 31) &+ fortId.hashValue
              }
              if hasTeamColor {
                 hashCode = (hashCode &* 31) &+ Int(teamColor.rawValue)
              }
              if hasPokemonData {
                  if let hashValuepokemonData = pokemonData?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValuepokemonData
                  }
              }
              if hasName {
                 hashCode = (hashCode &* 31) &+ name.hashValue
              }
              for oneValueimageUrls in imageUrls {
                  hashCode = (hashCode &* 31) &+ oneValueimageUrls.hashValue
              }
              if hasFp {
                 hashCode = (hashCode &* 31) &+ fp.hashValue
              }
              if hasStamina {
                 hashCode = (hashCode &* 31) &+ stamina.hashValue
              }
              if hasMaxStamina {
                 hashCode = (hashCode &* 31) &+ maxStamina.hashValue
              }
              if hasTypes {
                 hashCode = (hashCode &* 31) &+ types.hashValue
              }
              if hasLatitude {
                 hashCode = (hashCode &* 31) &+ latitude.hashValue
              }
              if hasLongitude {
                 hashCode = (hashCode &* 31) &+ longitude.hashValue
              }
              if hasDescription {
                 hashCode = (hashCode &* 31) &+ description_.hashValue
              }
              for oneElementmodifiers in modifiers {
                  hashCode = (hashCode &* 31) &+ oneElementmodifiers.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.FortDetailsResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.FortDetailsResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.FortDetailsResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.FortDetailsResponse = ResponseEnvelop.FortDetailsResponse()
        public func getMessage() -> ResponseEnvelop.FortDetailsResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasFortId:Bool {
             get {
                  return builderResult.hasFortId
             }
        }
        public var fortId:String {
             get {
                  return builderResult.fortId
             }
             set (value) {
                 builderResult.hasFortId = true
                 builderResult.fortId = value
             }
        }
        public func setFortId(value:String) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.fortId = value
          return self
        }
        public func clearFortId() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasFortId = false
             builderResult.fortId = ""
             return self
        }
          public var hasTeamColor:Bool{
              get {
                  return builderResult.hasTeamColor
              }
          }
          public var teamColor:ResponseEnvelop.TeamColor {
              get {
                  return builderResult.teamColor
              }
              set (value) {
                  builderResult.hasTeamColor = true
                  builderResult.teamColor = value
              }
          }
          public func setTeamColor(value:ResponseEnvelop.TeamColor) -> ResponseEnvelop.FortDetailsResponse.Builder {
            self.teamColor = value
            return self
          }
          public func clearTeamColor() -> ResponseEnvelop.FortDetailsResponse.Builder {
             builderResult.hasTeamColor = false
             builderResult.teamColor = .Neutral
             return self
          }
        public var hasPokemonData:Bool {
             get {
                 return builderResult.hasPokemonData
             }
        }
        public var pokemonData:ResponseEnvelop.PokemonData! {
             get {
                 if pokemonDataBuilder_ != nil {
                    builderResult.pokemonData = pokemonDataBuilder_.getMessage()
                 }
                 return builderResult.pokemonData
             }
             set (value) {
                 builderResult.hasPokemonData = true
                 builderResult.pokemonData = value
             }
        }
        private var pokemonDataBuilder_:ResponseEnvelop.PokemonData.Builder! {
             didSet {
                builderResult.hasPokemonData = true
             }
        }
        public func getPokemonDataBuilder() -> ResponseEnvelop.PokemonData.Builder {
          if pokemonDataBuilder_ == nil {
             pokemonDataBuilder_ = ResponseEnvelop.PokemonData.Builder()
             builderResult.pokemonData = pokemonDataBuilder_.getMessage()
             if pokemonData != nil {
                try! pokemonDataBuilder_.mergeFrom(pokemonData)
             }
          }
          return pokemonDataBuilder_
        }
        public func setPokemonData(value:ResponseEnvelop.PokemonData!) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.pokemonData = value
          return self
        }
        public func mergePokemonData(value:ResponseEnvelop.PokemonData) throws -> ResponseEnvelop.FortDetailsResponse.Builder {
          if builderResult.hasPokemonData {
            builderResult.pokemonData = try ResponseEnvelop.PokemonData.builderWithPrototype(builderResult.pokemonData).mergeFrom(value).buildPartial()
          } else {
            builderResult.pokemonData = value
          }
          builderResult.hasPokemonData = true
          return self
        }
        public func clearPokemonData() -> ResponseEnvelop.FortDetailsResponse.Builder {
          pokemonDataBuilder_ = nil
          builderResult.hasPokemonData = false
          builderResult.pokemonData = nil
          return self
        }
        public var hasName:Bool {
             get {
                  return builderResult.hasName
             }
        }
        public var name:String {
             get {
                  return builderResult.name
             }
             set (value) {
                 builderResult.hasName = true
                 builderResult.name = value
             }
        }
        public func setName(value:String) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.name = value
          return self
        }
        public func clearName() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasName = false
             builderResult.name = ""
             return self
        }
        public var imageUrls:Array<String> {
             get {
                 return builderResult.imageUrls
             }
             set (array) {
                 builderResult.imageUrls = array
             }
        }
        public func setImageUrls(value:Array<String>) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.imageUrls = value
          return self
        }
        public func clearImageUrls() -> ResponseEnvelop.FortDetailsResponse.Builder {
           builderResult.imageUrls.removeAll(keepCapacity: false)
           return self
        }
        public var hasFp:Bool {
             get {
                  return builderResult.hasFp
             }
        }
        public var fp:Int32 {
             get {
                  return builderResult.fp
             }
             set (value) {
                 builderResult.hasFp = true
                 builderResult.fp = value
             }
        }
        public func setFp(value:Int32) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.fp = value
          return self
        }
        public func clearFp() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasFp = false
             builderResult.fp = Int32(0)
             return self
        }
        public var hasStamina:Bool {
             get {
                  return builderResult.hasStamina
             }
        }
        public var stamina:Int32 {
             get {
                  return builderResult.stamina
             }
             set (value) {
                 builderResult.hasStamina = true
                 builderResult.stamina = value
             }
        }
        public func setStamina(value:Int32) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.stamina = value
          return self
        }
        public func clearStamina() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasStamina = false
             builderResult.stamina = Int32(0)
             return self
        }
        public var hasMaxStamina:Bool {
             get {
                  return builderResult.hasMaxStamina
             }
        }
        public var maxStamina:Int32 {
             get {
                  return builderResult.maxStamina
             }
             set (value) {
                 builderResult.hasMaxStamina = true
                 builderResult.maxStamina = value
             }
        }
        public func setMaxStamina(value:Int32) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.maxStamina = value
          return self
        }
        public func clearMaxStamina() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasMaxStamina = false
             builderResult.maxStamina = Int32(0)
             return self
        }
        public var hasTypes:Bool {
             get {
                  return builderResult.hasTypes
             }
        }
        public var types:Int32 {
             get {
                  return builderResult.types
             }
             set (value) {
                 builderResult.hasTypes = true
                 builderResult.types = value
             }
        }
        public func setTypes(value:Int32) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.types = value
          return self
        }
        public func clearTypes() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasTypes = false
             builderResult.types = Int32(0)
             return self
        }
        public var hasLatitude:Bool {
             get {
                  return builderResult.hasLatitude
             }
        }
        public var latitude:Double {
             get {
                  return builderResult.latitude
             }
             set (value) {
                 builderResult.hasLatitude = true
                 builderResult.latitude = value
             }
        }
        public func setLatitude(value:Double) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.latitude = value
          return self
        }
        public func clearLatitude() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasLatitude = false
             builderResult.latitude = Double(0)
             return self
        }
        public var hasLongitude:Bool {
             get {
                  return builderResult.hasLongitude
             }
        }
        public var longitude:Double {
             get {
                  return builderResult.longitude
             }
             set (value) {
                 builderResult.hasLongitude = true
                 builderResult.longitude = value
             }
        }
        public func setLongitude(value:Double) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.longitude = value
          return self
        }
        public func clearLongitude() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasLongitude = false
             builderResult.longitude = Double(0)
             return self
        }
        public var hasDescription:Bool {
             get {
                  return builderResult.hasDescription
             }
        }
        public var description_:String {
             get {
                  return builderResult.description_
             }
             set (value) {
                 builderResult.hasDescription = true
                 builderResult.description_ = value
             }
        }
        public func setDescription(value:String) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.description_ = value
          return self
        }
        public func clearDescription() -> ResponseEnvelop.FortDetailsResponse.Builder{
             builderResult.hasDescription = false
             builderResult.description_ = ""
             return self
        }
        public var modifiers:Array<ResponseEnvelop.FortModifier> {
             get {
                 return builderResult.modifiers
             }
             set (value) {
                 builderResult.modifiers = value
             }
        }
        public func setModifiers(value:Array<ResponseEnvelop.FortModifier>) -> ResponseEnvelop.FortDetailsResponse.Builder {
          self.modifiers = value
          return self
        }
        public func clearModifiers() -> ResponseEnvelop.FortDetailsResponse.Builder {
          builderResult.modifiers.removeAll(keepCapacity: false)
          return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.FortDetailsResponse.Builder {
          builderResult = ResponseEnvelop.FortDetailsResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.FortDetailsResponse.Builder {
          return try ResponseEnvelop.FortDetailsResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.FortDetailsResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.FortDetailsResponse {
          let returnMe:ResponseEnvelop.FortDetailsResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.FortDetailsResponse) throws -> ResponseEnvelop.FortDetailsResponse.Builder {
          if other == ResponseEnvelop.FortDetailsResponse() {
           return self
          }
          if other.hasFortId {
               fortId = other.fortId
          }
          if other.hasTeamColor {
               teamColor = other.teamColor
          }
          if (other.hasPokemonData) {
              try mergePokemonData(other.pokemonData)
          }
          if other.hasName {
               name = other.name
          }
          if !other.imageUrls.isEmpty {
              builderResult.imageUrls += other.imageUrls
          }
          if other.hasFp {
               fp = other.fp
          }
          if other.hasStamina {
               stamina = other.stamina
          }
          if other.hasMaxStamina {
               maxStamina = other.maxStamina
          }
          if other.hasTypes {
               types = other.types
          }
          if other.hasLatitude {
               latitude = other.latitude
          }
          if other.hasLongitude {
               longitude = other.longitude
          }
          if other.hasDescription {
               description_ = other.description_
          }
          if !other.modifiers.isEmpty  {
             builderResult.modifiers += other.modifiers
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.FortDetailsResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortDetailsResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10 :
              fortId = try input.readString()

            case 16 :
              let valueIntteamColor = try input.readEnum()
              if let enumsteamColor = ResponseEnvelop.TeamColor(rawValue:valueIntteamColor){
                   teamColor = enumsteamColor
              } else {
                   try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntteamColor))
              }

            case 26 :
              let subBuilder:ResponseEnvelop.PokemonData.Builder = ResponseEnvelop.PokemonData.Builder()
              if hasPokemonData {
                try subBuilder.mergeFrom(pokemonData)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              pokemonData = subBuilder.buildPartial()

            case 34 :
              name = try input.readString()

            case 42 :
              imageUrls += [try input.readString()]

            case 48 :
              fp = try input.readInt32()

            case 56 :
              stamina = try input.readInt32()

            case 64 :
              maxStamina = try input.readInt32()

            case 72 :
              types = try input.readInt32()

            case 81 :
              latitude = try input.readDouble()

            case 89 :
              longitude = try input.readDouble()

            case 98 :
              description_ = try input.readString()

            case 106 :
              let subBuilder = ResponseEnvelop.FortModifier.Builder()
              try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
              modifiers += [subBuilder.buildPartial()]

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class FortModifier : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var itemId:ResponseEnvelop.ItemId = ResponseEnvelop.ItemId.ItemUnknown
      public private(set) var hasItemId:Bool = false
      public private(set) var expirationTimestampMs:Int64 = Int64(0)

      public private(set) var hasExpirationTimestampMs:Bool = false
      public private(set) var deployerPlayerCodename:String = ""

      public private(set) var hasDeployerPlayerCodename:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasItemId {
          try output.writeEnum(1, value:itemId.rawValue)
        }
        if hasExpirationTimestampMs {
          try output.writeInt64(2, value:expirationTimestampMs)
        }
        if hasDeployerPlayerCodename {
          try output.writeString(3, value:deployerPlayerCodename)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasItemId) {
          serialize_size += itemId.rawValue.computeEnumSize(1)
        }
        if hasExpirationTimestampMs {
          serialize_size += expirationTimestampMs.computeInt64Size(2)
        }
        if hasDeployerPlayerCodename {
          serialize_size += deployerPlayerCodename.computeStringSize(3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.FortModifier> {
        var mergedArray = Array<ResponseEnvelop.FortModifier>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.FortModifier? {
        return try ResponseEnvelop.FortModifier.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.FortModifier {
        return try ResponseEnvelop.FortModifier.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortModifier {
        return try ResponseEnvelop.FortModifier.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.FortModifier {
        return try ResponseEnvelop.FortModifier.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortModifier {
        return try ResponseEnvelop.FortModifier.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.FortModifier {
        return try ResponseEnvelop.FortModifier.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortModifier {
        return try ResponseEnvelop.FortModifier.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.FortModifier.Builder {
        return ResponseEnvelop.FortModifier.classBuilder() as! ResponseEnvelop.FortModifier.Builder
      }
      public func getBuilder() -> ResponseEnvelop.FortModifier.Builder {
        return classBuilder() as! ResponseEnvelop.FortModifier.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.FortModifier.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.FortModifier.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.FortModifier.Builder {
        return try ResponseEnvelop.FortModifier.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.FortModifier) throws -> ResponseEnvelop.FortModifier.Builder {
        return try ResponseEnvelop.FortModifier.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasItemId) {
          output += "\(indent) itemId: \(itemId.description)\n"
        }
        if hasExpirationTimestampMs {
          output += "\(indent) expirationTimestampMs: \(expirationTimestampMs) \n"
        }
        if hasDeployerPlayerCodename {
          output += "\(indent) deployerPlayerCodename: \(deployerPlayerCodename) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasItemId {
                 hashCode = (hashCode &* 31) &+ Int(itemId.rawValue)
              }
              if hasExpirationTimestampMs {
                 hashCode = (hashCode &* 31) &+ expirationTimestampMs.hashValue
              }
              if hasDeployerPlayerCodename {
                 hashCode = (hashCode &* 31) &+ deployerPlayerCodename.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.FortModifier"
      }
      override public func className() -> String {
          return "ResponseEnvelop.FortModifier"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.FortModifier.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.FortModifier = ResponseEnvelop.FortModifier()
        public func getMessage() -> ResponseEnvelop.FortModifier {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasItemId:Bool{
              get {
                  return builderResult.hasItemId
              }
          }
          public var itemId:ResponseEnvelop.ItemId {
              get {
                  return builderResult.itemId
              }
              set (value) {
                  builderResult.hasItemId = true
                  builderResult.itemId = value
              }
          }
          public func setItemId(value:ResponseEnvelop.ItemId) -> ResponseEnvelop.FortModifier.Builder {
            self.itemId = value
            return self
          }
          public func clearItemId() -> ResponseEnvelop.FortModifier.Builder {
             builderResult.hasItemId = false
             builderResult.itemId = .ItemUnknown
             return self
          }
        public var hasExpirationTimestampMs:Bool {
             get {
                  return builderResult.hasExpirationTimestampMs
             }
        }
        public var expirationTimestampMs:Int64 {
             get {
                  return builderResult.expirationTimestampMs
             }
             set (value) {
                 builderResult.hasExpirationTimestampMs = true
                 builderResult.expirationTimestampMs = value
             }
        }
        public func setExpirationTimestampMs(value:Int64) -> ResponseEnvelop.FortModifier.Builder {
          self.expirationTimestampMs = value
          return self
        }
        public func clearExpirationTimestampMs() -> ResponseEnvelop.FortModifier.Builder{
             builderResult.hasExpirationTimestampMs = false
             builderResult.expirationTimestampMs = Int64(0)
             return self
        }
        public var hasDeployerPlayerCodename:Bool {
             get {
                  return builderResult.hasDeployerPlayerCodename
             }
        }
        public var deployerPlayerCodename:String {
             get {
                  return builderResult.deployerPlayerCodename
             }
             set (value) {
                 builderResult.hasDeployerPlayerCodename = true
                 builderResult.deployerPlayerCodename = value
             }
        }
        public func setDeployerPlayerCodename(value:String) -> ResponseEnvelop.FortModifier.Builder {
          self.deployerPlayerCodename = value
          return self
        }
        public func clearDeployerPlayerCodename() -> ResponseEnvelop.FortModifier.Builder{
             builderResult.hasDeployerPlayerCodename = false
             builderResult.deployerPlayerCodename = ""
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.FortModifier.Builder {
          builderResult = ResponseEnvelop.FortModifier()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.FortModifier.Builder {
          return try ResponseEnvelop.FortModifier.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.FortModifier {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.FortModifier {
          let returnMe:ResponseEnvelop.FortModifier = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.FortModifier) throws -> ResponseEnvelop.FortModifier.Builder {
          if other == ResponseEnvelop.FortModifier() {
           return self
          }
          if other.hasItemId {
               itemId = other.itemId
          }
          if other.hasExpirationTimestampMs {
               expirationTimestampMs = other.expirationTimestampMs
          }
          if other.hasDeployerPlayerCodename {
               deployerPlayerCodename = other.deployerPlayerCodename
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.FortModifier.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.FortModifier.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntitemId = try input.readEnum()
              if let enumsitemId = ResponseEnvelop.ItemId(rawValue:valueIntitemId){
                   itemId = enumsitemId
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntitemId))
              }

            case 16 :
              expirationTimestampMs = try input.readInt64()

            case 26 :
              deployerPlayerCodename = try input.readString()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class RecycleInventoryItemResponse : GeneratedMessage, GeneratedMessageProtocol {


        //Enum type declaration start 

        public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case Unset = 0
          case Success = 1
          case ErrorNotEnoughCopies = 2
          case ErrorCannotRecycleIncubators = 3

          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          private func getDescription() -> String { 
              switch self {
                  case .Unset: return ".Unset"
                  case .Success: return ".Success"
                  case .ErrorNotEnoughCopies: return ".ErrorNotEnoughCopies"
                  case .ErrorCannotRecycleIncubators: return ".ErrorCannotRecycleIncubators"
              }
          }
        }

        //Enum type declaration end 

      public private(set) var result:ResponseEnvelop.RecycleInventoryItemResponse.Result = ResponseEnvelop.RecycleInventoryItemResponse.Result.Unset
      public private(set) var hasResult:Bool = false
      public private(set) var newCount:Int32 = Int32(0)

      public private(set) var hasNewCount:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasResult {
          try output.writeEnum(1, value:result.rawValue)
        }
        if hasNewCount {
          try output.writeInt32(2, value:newCount)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasResult) {
          serialize_size += result.rawValue.computeEnumSize(1)
        }
        if hasNewCount {
          serialize_size += newCount.computeInt32Size(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.RecycleInventoryItemResponse> {
        var mergedArray = Array<ResponseEnvelop.RecycleInventoryItemResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.RecycleInventoryItemResponse? {
        return try ResponseEnvelop.RecycleInventoryItemResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.RecycleInventoryItemResponse {
        return try ResponseEnvelop.RecycleInventoryItemResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.RecycleInventoryItemResponse {
        return try ResponseEnvelop.RecycleInventoryItemResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.RecycleInventoryItemResponse {
        return try ResponseEnvelop.RecycleInventoryItemResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.RecycleInventoryItemResponse {
        return try ResponseEnvelop.RecycleInventoryItemResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.RecycleInventoryItemResponse {
        return try ResponseEnvelop.RecycleInventoryItemResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.RecycleInventoryItemResponse {
        return try ResponseEnvelop.RecycleInventoryItemResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
        return ResponseEnvelop.RecycleInventoryItemResponse.classBuilder() as! ResponseEnvelop.RecycleInventoryItemResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
        return classBuilder() as! ResponseEnvelop.RecycleInventoryItemResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.RecycleInventoryItemResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.RecycleInventoryItemResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
        return try ResponseEnvelop.RecycleInventoryItemResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.RecycleInventoryItemResponse) throws -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
        return try ResponseEnvelop.RecycleInventoryItemResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasResult) {
          output += "\(indent) result: \(result.description)\n"
        }
        if hasNewCount {
          output += "\(indent) newCount: \(newCount) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasResult {
                 hashCode = (hashCode &* 31) &+ Int(result.rawValue)
              }
              if hasNewCount {
                 hashCode = (hashCode &* 31) &+ newCount.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.RecycleInventoryItemResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.RecycleInventoryItemResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.RecycleInventoryItemResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.RecycleInventoryItemResponse = ResponseEnvelop.RecycleInventoryItemResponse()
        public func getMessage() -> ResponseEnvelop.RecycleInventoryItemResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasResult:Bool{
              get {
                  return builderResult.hasResult
              }
          }
          public var result:ResponseEnvelop.RecycleInventoryItemResponse.Result {
              get {
                  return builderResult.result
              }
              set (value) {
                  builderResult.hasResult = true
                  builderResult.result = value
              }
          }
          public func setResult(value:ResponseEnvelop.RecycleInventoryItemResponse.Result) -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
            self.result = value
            return self
          }
          public func clearResult() -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
             builderResult.hasResult = false
             builderResult.result = .Unset
             return self
          }
        public var hasNewCount:Bool {
             get {
                  return builderResult.hasNewCount
             }
        }
        public var newCount:Int32 {
             get {
                  return builderResult.newCount
             }
             set (value) {
                 builderResult.hasNewCount = true
                 builderResult.newCount = value
             }
        }
        public func setNewCount(value:Int32) -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
          self.newCount = value
          return self
        }
        public func clearNewCount() -> ResponseEnvelop.RecycleInventoryItemResponse.Builder{
             builderResult.hasNewCount = false
             builderResult.newCount = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
          builderResult = ResponseEnvelop.RecycleInventoryItemResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
          return try ResponseEnvelop.RecycleInventoryItemResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.RecycleInventoryItemResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.RecycleInventoryItemResponse {
          let returnMe:ResponseEnvelop.RecycleInventoryItemResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.RecycleInventoryItemResponse) throws -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
          if other == ResponseEnvelop.RecycleInventoryItemResponse() {
           return self
          }
          if other.hasResult {
               result = other.result
          }
          if other.hasNewCount {
               newCount = other.newCount
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.RecycleInventoryItemResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntresult = try input.readEnum()
              if let enumsresult = ResponseEnvelop.RecycleInventoryItemResponse.Result(rawValue:valueIntresult){
                   result = enumsresult
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
              }

            case 16 :
              newCount = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class ItemAward : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var itemId:ResponseEnvelop.ItemId = ResponseEnvelop.ItemId.ItemUnknown
      public private(set) var hasItemId:Bool = false
      public private(set) var itemCount:Int32 = Int32(0)

      public private(set) var hasItemCount:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasItemId {
          try output.writeEnum(1, value:itemId.rawValue)
        }
        if hasItemCount {
          try output.writeInt32(2, value:itemCount)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasItemId) {
          serialize_size += itemId.rawValue.computeEnumSize(1)
        }
        if hasItemCount {
          serialize_size += itemCount.computeInt32Size(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.ItemAward> {
        var mergedArray = Array<ResponseEnvelop.ItemAward>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ItemAward? {
        return try ResponseEnvelop.ItemAward.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.ItemAward {
        return try ResponseEnvelop.ItemAward.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ItemAward {
        return try ResponseEnvelop.ItemAward.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ItemAward {
        return try ResponseEnvelop.ItemAward.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ItemAward {
        return try ResponseEnvelop.ItemAward.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ItemAward {
        return try ResponseEnvelop.ItemAward.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ItemAward {
        return try ResponseEnvelop.ItemAward.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.ItemAward.Builder {
        return ResponseEnvelop.ItemAward.classBuilder() as! ResponseEnvelop.ItemAward.Builder
      }
      public func getBuilder() -> ResponseEnvelop.ItemAward.Builder {
        return classBuilder() as! ResponseEnvelop.ItemAward.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ItemAward.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ItemAward.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.ItemAward.Builder {
        return try ResponseEnvelop.ItemAward.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.ItemAward) throws -> ResponseEnvelop.ItemAward.Builder {
        return try ResponseEnvelop.ItemAward.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasItemId) {
          output += "\(indent) itemId: \(itemId.description)\n"
        }
        if hasItemCount {
          output += "\(indent) itemCount: \(itemCount) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasItemId {
                 hashCode = (hashCode &* 31) &+ Int(itemId.rawValue)
              }
              if hasItemCount {
                 hashCode = (hashCode &* 31) &+ itemCount.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.ItemAward"
      }
      override public func className() -> String {
          return "ResponseEnvelop.ItemAward"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.ItemAward.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.ItemAward = ResponseEnvelop.ItemAward()
        public func getMessage() -> ResponseEnvelop.ItemAward {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasItemId:Bool{
              get {
                  return builderResult.hasItemId
              }
          }
          public var itemId:ResponseEnvelop.ItemId {
              get {
                  return builderResult.itemId
              }
              set (value) {
                  builderResult.hasItemId = true
                  builderResult.itemId = value
              }
          }
          public func setItemId(value:ResponseEnvelop.ItemId) -> ResponseEnvelop.ItemAward.Builder {
            self.itemId = value
            return self
          }
          public func clearItemId() -> ResponseEnvelop.ItemAward.Builder {
             builderResult.hasItemId = false
             builderResult.itemId = .ItemUnknown
             return self
          }
        public var hasItemCount:Bool {
             get {
                  return builderResult.hasItemCount
             }
        }
        public var itemCount:Int32 {
             get {
                  return builderResult.itemCount
             }
             set (value) {
                 builderResult.hasItemCount = true
                 builderResult.itemCount = value
             }
        }
        public func setItemCount(value:Int32) -> ResponseEnvelop.ItemAward.Builder {
          self.itemCount = value
          return self
        }
        public func clearItemCount() -> ResponseEnvelop.ItemAward.Builder{
             builderResult.hasItemCount = false
             builderResult.itemCount = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.ItemAward.Builder {
          builderResult = ResponseEnvelop.ItemAward()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.ItemAward.Builder {
          return try ResponseEnvelop.ItemAward.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.ItemAward {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.ItemAward {
          let returnMe:ResponseEnvelop.ItemAward = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.ItemAward) throws -> ResponseEnvelop.ItemAward.Builder {
          if other == ResponseEnvelop.ItemAward() {
           return self
          }
          if other.hasItemId {
               itemId = other.itemId
          }
          if other.hasItemCount {
               itemCount = other.itemCount
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ItemAward.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ItemAward.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntitemId = try input.readEnum()
              if let enumsitemId = ResponseEnvelop.ItemId(rawValue:valueIntitemId){
                   itemId = enumsitemId
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntitemId))
              }

            case 16 :
              itemCount = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class ReleasePokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


        //Enum type declaration start 

        public enum ReleaseStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case Unset = 0
          case Success = 1
          case PokemonDeployed = 2
          case Failed = 3
          case ErrorPokemonIsEgg = 4

          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          private func getDescription() -> String { 
              switch self {
                  case .Unset: return ".Unset"
                  case .Success: return ".Success"
                  case .PokemonDeployed: return ".PokemonDeployed"
                  case .Failed: return ".Failed"
                  case .ErrorPokemonIsEgg: return ".ErrorPokemonIsEgg"
              }
          }
        }

        //Enum type declaration end 

      public private(set) var status:ResponseEnvelop.ReleasePokemonResponse.ReleaseStatus = ResponseEnvelop.ReleasePokemonResponse.ReleaseStatus.Unset
      public private(set) var hasStatus:Bool = false
      public private(set) var candyAwarded:Int32 = Int32(0)

      public private(set) var hasCandyAwarded:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
        if !hasStatus {
          return false
        }
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasStatus {
          try output.writeEnum(1, value:status.rawValue)
        }
        if hasCandyAwarded {
          try output.writeInt32(2, value:candyAwarded)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasStatus) {
          serialize_size += status.rawValue.computeEnumSize(1)
        }
        if hasCandyAwarded {
          serialize_size += candyAwarded.computeInt32Size(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.ReleasePokemonResponse> {
        var mergedArray = Array<ResponseEnvelop.ReleasePokemonResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ReleasePokemonResponse? {
        return try ResponseEnvelop.ReleasePokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.ReleasePokemonResponse {
        return try ResponseEnvelop.ReleasePokemonResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ReleasePokemonResponse {
        return try ResponseEnvelop.ReleasePokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.ReleasePokemonResponse {
        return try ResponseEnvelop.ReleasePokemonResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ReleasePokemonResponse {
        return try ResponseEnvelop.ReleasePokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ReleasePokemonResponse {
        return try ResponseEnvelop.ReleasePokemonResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ReleasePokemonResponse {
        return try ResponseEnvelop.ReleasePokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.ReleasePokemonResponse.Builder {
        return ResponseEnvelop.ReleasePokemonResponse.classBuilder() as! ResponseEnvelop.ReleasePokemonResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.ReleasePokemonResponse.Builder {
        return classBuilder() as! ResponseEnvelop.ReleasePokemonResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ReleasePokemonResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.ReleasePokemonResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.ReleasePokemonResponse.Builder {
        return try ResponseEnvelop.ReleasePokemonResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.ReleasePokemonResponse) throws -> ResponseEnvelop.ReleasePokemonResponse.Builder {
        return try ResponseEnvelop.ReleasePokemonResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasStatus) {
          output += "\(indent) status: \(status.description)\n"
        }
        if hasCandyAwarded {
          output += "\(indent) candyAwarded: \(candyAwarded) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasStatus {
                 hashCode = (hashCode &* 31) &+ Int(status.rawValue)
              }
              if hasCandyAwarded {
                 hashCode = (hashCode &* 31) &+ candyAwarded.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.ReleasePokemonResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.ReleasePokemonResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.ReleasePokemonResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.ReleasePokemonResponse = ResponseEnvelop.ReleasePokemonResponse()
        public func getMessage() -> ResponseEnvelop.ReleasePokemonResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasStatus:Bool{
              get {
                  return builderResult.hasStatus
              }
          }
          public var status:ResponseEnvelop.ReleasePokemonResponse.ReleaseStatus {
              get {
                  return builderResult.status
              }
              set (value) {
                  builderResult.hasStatus = true
                  builderResult.status = value
              }
          }
          public func setStatus(value:ResponseEnvelop.ReleasePokemonResponse.ReleaseStatus) -> ResponseEnvelop.ReleasePokemonResponse.Builder {
            self.status = value
            return self
          }
          public func clearStatus() -> ResponseEnvelop.ReleasePokemonResponse.Builder {
             builderResult.hasStatus = false
             builderResult.status = .Unset
             return self
          }
        public var hasCandyAwarded:Bool {
             get {
                  return builderResult.hasCandyAwarded
             }
        }
        public var candyAwarded:Int32 {
             get {
                  return builderResult.candyAwarded
             }
             set (value) {
                 builderResult.hasCandyAwarded = true
                 builderResult.candyAwarded = value
             }
        }
        public func setCandyAwarded(value:Int32) -> ResponseEnvelop.ReleasePokemonResponse.Builder {
          self.candyAwarded = value
          return self
        }
        public func clearCandyAwarded() -> ResponseEnvelop.ReleasePokemonResponse.Builder{
             builderResult.hasCandyAwarded = false
             builderResult.candyAwarded = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.ReleasePokemonResponse.Builder {
          builderResult = ResponseEnvelop.ReleasePokemonResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.ReleasePokemonResponse.Builder {
          return try ResponseEnvelop.ReleasePokemonResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.ReleasePokemonResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.ReleasePokemonResponse {
          let returnMe:ResponseEnvelop.ReleasePokemonResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.ReleasePokemonResponse) throws -> ResponseEnvelop.ReleasePokemonResponse.Builder {
          if other == ResponseEnvelop.ReleasePokemonResponse() {
           return self
          }
          if other.hasStatus {
               status = other.status
          }
          if other.hasCandyAwarded {
               candyAwarded = other.candyAwarded
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.ReleasePokemonResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.ReleasePokemonResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntstatus = try input.readEnum()
              if let enumsstatus = ResponseEnvelop.ReleasePokemonResponse.ReleaseStatus(rawValue:valueIntstatus){
                   status = enumsstatus
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntstatus))
              }

            case 16 :
              candyAwarded = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class EvolvePokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


        //Enum type declaration start 

        public enum EvolvePokemonStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
          case PokemonEvolvedUnset = 0
          case PokemonEvolvedSuccess = 1
          case FailedPokemonMissing = 2
          case FailedInsufficientResources = 3
          case FailedPokemonCannotEvolve = 4
          case FailedPokemonIsDeployed = 5

          public var debugDescription:String { return getDescription() }
          public var description:String { return getDescription() }
          private func getDescription() -> String { 
              switch self {
                  case .PokemonEvolvedUnset: return ".PokemonEvolvedUnset"
                  case .PokemonEvolvedSuccess: return ".PokemonEvolvedSuccess"
                  case .FailedPokemonMissing: return ".FailedPokemonMissing"
                  case .FailedInsufficientResources: return ".FailedInsufficientResources"
                  case .FailedPokemonCannotEvolve: return ".FailedPokemonCannotEvolve"
                  case .FailedPokemonIsDeployed: return ".FailedPokemonIsDeployed"
              }
          }
        }

        //Enum type declaration end 

      public private(set) var result:ResponseEnvelop.EvolvePokemonResponse.EvolvePokemonStatus = ResponseEnvelop.EvolvePokemonResponse.EvolvePokemonStatus.PokemonEvolvedUnset
      public private(set) var hasResult:Bool = false
      public private(set) var evolvedPokemon:ResponseEnvelop.Pokemon!
      public private(set) var hasEvolvedPokemon:Bool = false
      public private(set) var expAwarded:Int32 = Int32(0)

      public private(set) var hasExpAwarded:Bool = false
      public private(set) var candyAwarded:Int32 = Int32(0)

      public private(set) var hasCandyAwarded:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasResult {
          try output.writeEnum(1, value:result.rawValue)
        }
        if hasEvolvedPokemon {
          try output.writeMessage(2, value:evolvedPokemon)
        }
        if hasExpAwarded {
          try output.writeInt32(3, value:expAwarded)
        }
        if hasCandyAwarded {
          try output.writeInt32(4, value:candyAwarded)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasResult) {
          serialize_size += result.rawValue.computeEnumSize(1)
        }
        if hasEvolvedPokemon {
            if let varSizeevolvedPokemon = evolvedPokemon?.computeMessageSize(2) {
                serialize_size += varSizeevolvedPokemon
            }
        }
        if hasExpAwarded {
          serialize_size += expAwarded.computeInt32Size(3)
        }
        if hasCandyAwarded {
          serialize_size += candyAwarded.computeInt32Size(4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.EvolvePokemonResponse> {
        var mergedArray = Array<ResponseEnvelop.EvolvePokemonResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.EvolvePokemonResponse? {
        return try ResponseEnvelop.EvolvePokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.EvolvePokemonResponse {
        return try ResponseEnvelop.EvolvePokemonResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EvolvePokemonResponse {
        return try ResponseEnvelop.EvolvePokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.EvolvePokemonResponse {
        return try ResponseEnvelop.EvolvePokemonResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EvolvePokemonResponse {
        return try ResponseEnvelop.EvolvePokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.EvolvePokemonResponse {
        return try ResponseEnvelop.EvolvePokemonResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EvolvePokemonResponse {
        return try ResponseEnvelop.EvolvePokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.EvolvePokemonResponse.Builder {
        return ResponseEnvelop.EvolvePokemonResponse.classBuilder() as! ResponseEnvelop.EvolvePokemonResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.EvolvePokemonResponse.Builder {
        return classBuilder() as! ResponseEnvelop.EvolvePokemonResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.EvolvePokemonResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.EvolvePokemonResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.EvolvePokemonResponse.Builder {
        return try ResponseEnvelop.EvolvePokemonResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.EvolvePokemonResponse) throws -> ResponseEnvelop.EvolvePokemonResponse.Builder {
        return try ResponseEnvelop.EvolvePokemonResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if (hasResult) {
          output += "\(indent) result: \(result.description)\n"
        }
        if hasEvolvedPokemon {
          output += "\(indent) evolvedPokemon {\n"
          if let outDescEvolvedPokemon = evolvedPokemon {
            output += try outDescEvolvedPokemon.getDescription("\(indent)  ")
          }
          output += "\(indent) }\n"
        }
        if hasExpAwarded {
          output += "\(indent) expAwarded: \(expAwarded) \n"
        }
        if hasCandyAwarded {
          output += "\(indent) candyAwarded: \(candyAwarded) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasResult {
                 hashCode = (hashCode &* 31) &+ Int(result.rawValue)
              }
              if hasEvolvedPokemon {
                  if let hashValueevolvedPokemon = evolvedPokemon?.hashValue {
                      hashCode = (hashCode &* 31) &+ hashValueevolvedPokemon
                  }
              }
              if hasExpAwarded {
                 hashCode = (hashCode &* 31) &+ expAwarded.hashValue
              }
              if hasCandyAwarded {
                 hashCode = (hashCode &* 31) &+ candyAwarded.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.EvolvePokemonResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.EvolvePokemonResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.EvolvePokemonResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.EvolvePokemonResponse = ResponseEnvelop.EvolvePokemonResponse()
        public func getMessage() -> ResponseEnvelop.EvolvePokemonResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
          public var hasResult:Bool{
              get {
                  return builderResult.hasResult
              }
          }
          public var result:ResponseEnvelop.EvolvePokemonResponse.EvolvePokemonStatus {
              get {
                  return builderResult.result
              }
              set (value) {
                  builderResult.hasResult = true
                  builderResult.result = value
              }
          }
          public func setResult(value:ResponseEnvelop.EvolvePokemonResponse.EvolvePokemonStatus) -> ResponseEnvelop.EvolvePokemonResponse.Builder {
            self.result = value
            return self
          }
          public func clearResult() -> ResponseEnvelop.EvolvePokemonResponse.Builder {
             builderResult.hasResult = false
             builderResult.result = .PokemonEvolvedUnset
             return self
          }
        public var hasEvolvedPokemon:Bool {
             get {
                 return builderResult.hasEvolvedPokemon
             }
        }
        public var evolvedPokemon:ResponseEnvelop.Pokemon! {
             get {
                 if evolvedPokemonBuilder_ != nil {
                    builderResult.evolvedPokemon = evolvedPokemonBuilder_.getMessage()
                 }
                 return builderResult.evolvedPokemon
             }
             set (value) {
                 builderResult.hasEvolvedPokemon = true
                 builderResult.evolvedPokemon = value
             }
        }
        private var evolvedPokemonBuilder_:ResponseEnvelop.Pokemon.Builder! {
             didSet {
                builderResult.hasEvolvedPokemon = true
             }
        }
        public func getEvolvedPokemonBuilder() -> ResponseEnvelop.Pokemon.Builder {
          if evolvedPokemonBuilder_ == nil {
             evolvedPokemonBuilder_ = ResponseEnvelop.Pokemon.Builder()
             builderResult.evolvedPokemon = evolvedPokemonBuilder_.getMessage()
             if evolvedPokemon != nil {
                try! evolvedPokemonBuilder_.mergeFrom(evolvedPokemon)
             }
          }
          return evolvedPokemonBuilder_
        }
        public func setEvolvedPokemon(value:ResponseEnvelop.Pokemon!) -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          self.evolvedPokemon = value
          return self
        }
        public func mergeEvolvedPokemon(value:ResponseEnvelop.Pokemon) throws -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          if builderResult.hasEvolvedPokemon {
            builderResult.evolvedPokemon = try ResponseEnvelop.Pokemon.builderWithPrototype(builderResult.evolvedPokemon).mergeFrom(value).buildPartial()
          } else {
            builderResult.evolvedPokemon = value
          }
          builderResult.hasEvolvedPokemon = true
          return self
        }
        public func clearEvolvedPokemon() -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          evolvedPokemonBuilder_ = nil
          builderResult.hasEvolvedPokemon = false
          builderResult.evolvedPokemon = nil
          return self
        }
        public var hasExpAwarded:Bool {
             get {
                  return builderResult.hasExpAwarded
             }
        }
        public var expAwarded:Int32 {
             get {
                  return builderResult.expAwarded
             }
             set (value) {
                 builderResult.hasExpAwarded = true
                 builderResult.expAwarded = value
             }
        }
        public func setExpAwarded(value:Int32) -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          self.expAwarded = value
          return self
        }
        public func clearExpAwarded() -> ResponseEnvelop.EvolvePokemonResponse.Builder{
             builderResult.hasExpAwarded = false
             builderResult.expAwarded = Int32(0)
             return self
        }
        public var hasCandyAwarded:Bool {
             get {
                  return builderResult.hasCandyAwarded
             }
        }
        public var candyAwarded:Int32 {
             get {
                  return builderResult.candyAwarded
             }
             set (value) {
                 builderResult.hasCandyAwarded = true
                 builderResult.candyAwarded = value
             }
        }
        public func setCandyAwarded(value:Int32) -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          self.candyAwarded = value
          return self
        }
        public func clearCandyAwarded() -> ResponseEnvelop.EvolvePokemonResponse.Builder{
             builderResult.hasCandyAwarded = false
             builderResult.candyAwarded = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          builderResult = ResponseEnvelop.EvolvePokemonResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          return try ResponseEnvelop.EvolvePokemonResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.EvolvePokemonResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.EvolvePokemonResponse {
          let returnMe:ResponseEnvelop.EvolvePokemonResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.EvolvePokemonResponse) throws -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          if other == ResponseEnvelop.EvolvePokemonResponse() {
           return self
          }
          if other.hasResult {
               result = other.result
          }
          if (other.hasEvolvedPokemon) {
              try mergeEvolvedPokemon(other.evolvedPokemon)
          }
          if other.hasExpAwarded {
               expAwarded = other.expAwarded
          }
          if other.hasCandyAwarded {
               candyAwarded = other.candyAwarded
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.EvolvePokemonResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.EvolvePokemonResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              let valueIntresult = try input.readEnum()
              if let enumsresult = ResponseEnvelop.EvolvePokemonResponse.EvolvePokemonStatus(rawValue:valueIntresult){
                   result = enumsresult
              } else {
                   try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
              }

            case 18 :
              let subBuilder:ResponseEnvelop.Pokemon.Builder = ResponseEnvelop.Pokemon.Builder()
              if hasEvolvedPokemon {
                try subBuilder.mergeFrom(evolvedPokemon)
              }
              try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
              evolvedPokemon = subBuilder.buildPartial()

            case 24 :
              expAwarded = try input.readInt32()

            case 32 :
              candyAwarded = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



  //Nested type declaration start

    final public class TransferPokemonResponse : GeneratedMessage, GeneratedMessageProtocol {
      public private(set) var status:Int32 = Int32(0)

      public private(set) var hasStatus:Bool = false
      public private(set) var candyAwarded:Int32 = Int32(0)

      public private(set) var hasCandyAwarded:Bool = false
      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
        if hasStatus {
          try output.writeInt32(1, value:status)
        }
        if hasCandyAwarded {
          try output.writeInt32(2, value:candyAwarded)
        }
        try unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasStatus {
          serialize_size += status.computeInt32Size(1)
        }
        if hasCandyAwarded {
          serialize_size += candyAwarded.computeInt32Size(2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop.TransferPokemonResponse> {
        var mergedArray = Array<ResponseEnvelop.TransferPokemonResponse>()
        while let value = try parseFromDelimitedFromInputStream(input) {
          mergedArray += [value]
        }
        return mergedArray
      }
      public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.TransferPokemonResponse? {
        return try ResponseEnvelop.TransferPokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
      }
      public class func parseFromData(data:NSData) throws -> ResponseEnvelop.TransferPokemonResponse {
        return try ResponseEnvelop.TransferPokemonResponse.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
      }
      public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.TransferPokemonResponse {
        return try ResponseEnvelop.TransferPokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop.TransferPokemonResponse {
        return try ResponseEnvelop.TransferPokemonResponse.Builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.TransferPokemonResponse {
        return try ResponseEnvelop.TransferPokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.TransferPokemonResponse {
        return try ResponseEnvelop.TransferPokemonResponse.Builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.TransferPokemonResponse {
        return try ResponseEnvelop.TransferPokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func getBuilder() -> ResponseEnvelop.TransferPokemonResponse.Builder {
        return ResponseEnvelop.TransferPokemonResponse.classBuilder() as! ResponseEnvelop.TransferPokemonResponse.Builder
      }
      public func getBuilder() -> ResponseEnvelop.TransferPokemonResponse.Builder {
        return classBuilder() as! ResponseEnvelop.TransferPokemonResponse.Builder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.TransferPokemonResponse.Builder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ResponseEnvelop.TransferPokemonResponse.Builder()
      }
      public func toBuilder() throws -> ResponseEnvelop.TransferPokemonResponse.Builder {
        return try ResponseEnvelop.TransferPokemonResponse.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ResponseEnvelop.TransferPokemonResponse) throws -> ResponseEnvelop.TransferPokemonResponse.Builder {
        return try ResponseEnvelop.TransferPokemonResponse.Builder().mergeFrom(prototype)
      }
      override public func getDescription(indent:String) throws -> String {
        var output:String = ""
        if hasStatus {
          output += "\(indent) status: \(status) \n"
        }
        if hasCandyAwarded {
          output += "\(indent) candyAwarded: \(candyAwarded) \n"
        }
        output += unknownFields.getDescription(indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasStatus {
                 hashCode = (hashCode &* 31) &+ status.hashValue
              }
              if hasCandyAwarded {
                 hashCode = (hashCode &* 31) &+ candyAwarded.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ResponseEnvelop.TransferPokemonResponse"
      }
      override public func className() -> String {
          return "ResponseEnvelop.TransferPokemonResponse"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ResponseEnvelop.TransferPokemonResponse.self
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        private var builderResult:ResponseEnvelop.TransferPokemonResponse = ResponseEnvelop.TransferPokemonResponse()
        public func getMessage() -> ResponseEnvelop.TransferPokemonResponse {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var hasStatus:Bool {
             get {
                  return builderResult.hasStatus
             }
        }
        public var status:Int32 {
             get {
                  return builderResult.status
             }
             set (value) {
                 builderResult.hasStatus = true
                 builderResult.status = value
             }
        }
        public func setStatus(value:Int32) -> ResponseEnvelop.TransferPokemonResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> ResponseEnvelop.TransferPokemonResponse.Builder{
             builderResult.hasStatus = false
             builderResult.status = Int32(0)
             return self
        }
        public var hasCandyAwarded:Bool {
             get {
                  return builderResult.hasCandyAwarded
             }
        }
        public var candyAwarded:Int32 {
             get {
                  return builderResult.candyAwarded
             }
             set (value) {
                 builderResult.hasCandyAwarded = true
                 builderResult.candyAwarded = value
             }
        }
        public func setCandyAwarded(value:Int32) -> ResponseEnvelop.TransferPokemonResponse.Builder {
          self.candyAwarded = value
          return self
        }
        public func clearCandyAwarded() -> ResponseEnvelop.TransferPokemonResponse.Builder{
             builderResult.hasCandyAwarded = false
             builderResult.candyAwarded = Int32(0)
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> ResponseEnvelop.TransferPokemonResponse.Builder {
          builderResult = ResponseEnvelop.TransferPokemonResponse()
          return self
        }
        public override func clone() throws -> ResponseEnvelop.TransferPokemonResponse.Builder {
          return try ResponseEnvelop.TransferPokemonResponse.builderWithPrototype(builderResult)
        }
        public override func build() throws -> ResponseEnvelop.TransferPokemonResponse {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> ResponseEnvelop.TransferPokemonResponse {
          let returnMe:ResponseEnvelop.TransferPokemonResponse = builderResult
          return returnMe
        }
        public func mergeFrom(other:ResponseEnvelop.TransferPokemonResponse) throws -> ResponseEnvelop.TransferPokemonResponse.Builder {
          if other == ResponseEnvelop.TransferPokemonResponse() {
           return self
          }
          if other.hasStatus {
               status = other.status
          }
          if other.hasCandyAwarded {
               candyAwarded = other.candyAwarded
          }
          try mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.TransferPokemonResponse.Builder {
             return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.TransferPokemonResponse.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            let protobufTag = try input.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 8 :
              status = try input.readInt32()

            case 16 :
              candyAwarded = try input.readInt32()

            default:
              if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    }

  //Nested type declaration end



    //Enum type declaration start 

    public enum TeamColor:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case Neutral = 0
      case Blue = 1
      case Red = 2
      case Yellow = 3

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .Neutral: return ".Neutral"
              case .Blue: return ".Blue"
              case .Red: return ".Red"
              case .Yellow: return ".Yellow"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum PokemonMove:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case MoveUnset = 0
      case ThunderShock = 1
      case QuickAttack = 2
      case Scratch = 3
      case Ember = 4
      case VineWhip = 5
      case Tackle = 6
      case RazorLeaf = 7
      case TakeDown = 8
      case WaterGun = 9
      case Bite = 10
      case Pound = 11
      case DoubleSlap = 12
      case Wrap = 13
      case HyperBeam = 14
      case Lick = 15
      case DarkPulse = 16
      case Smog = 17
      case Sludge = 18
      case MetalClaw = 19
      case ViceGrip = 20
      case FlameWheel = 21
      case Megahorn = 22
      case WingAttack = 23
      case Flamethrower = 24
      case SuckerPunch = 25
      case Dig = 26
      case LowKick = 27
      case CrossChop = 28
      case PsychoCut = 29
      case Psybeam = 30
      case Earthquake = 31
      case StoneEdge = 32
      case IcePunch = 33
      case HeartStamp = 34
      case Discharge = 35
      case FlashCannon = 36
      case Peck = 37
      case DrillPeck = 38
      case IceBeam = 39
      case Blizzard = 40
      case AirSlash = 41
      case HeatWave = 42
      case Twineedle = 43
      case PoisonJab = 44
      case AerialAce = 45
      case DrillRun = 46
      case PetalBlizzard = 47
      case MegaDrain = 48
      case BugBuzz = 49
      case PoisonFang = 50
      case NightSlash = 51
      case Slash = 52
      case BubbleBeam = 53
      case Submission = 54
      case KarateChop = 55
      case LowSweep = 56
      case AquaJet = 57
      case AquaTail = 58
      case SeedBomb = 59
      case Psyshock = 60
      case RockThrow = 61
      case AncientPower = 62
      case RockTomb = 63
      case RockSlide = 64
      case PowerGem = 65
      case ShadowSneak = 66
      case ShadowPunch = 67
      case ShadowClaw = 68
      case OminousWind = 69
      case ShadowBall = 70
      case BulletPunch = 71
      case MagnetBomb = 72
      case SteelWing = 73
      case IronHead = 74
      case ParabolicCharge = 75
      case Spark = 76
      case ThunderPunch = 77
      case Thunder = 78
      case Thunderbolt = 79
      case Twister = 80
      case DragonBreath = 81
      case DragonPulse = 82
      case DragonClaw = 83
      case DisarmingVoice = 84
      case DrainingKiss = 85
      case DazzlingGleam = 86
      case Moonblast = 87
      case PlayRough = 88
      case CrossPoison = 89
      case SludgeBomb = 90
      case SludgeWave = 91
      case GunkShot = 92
      case MudShot = 93
      case BoneClub = 94
      case Bulldoze = 95
      case MudBomb = 96
      case FuryCutter = 97
      case BugBite = 98
      case SignalBeam = 99
      case XScissor = 100
      case FlameCharge = 101
      case FlameBurst = 102
      case FireBlast = 103
      case Brine = 104
      case WaterPulse = 105
      case Scald = 106
      case HydroPump = 107
      case Psychic = 108
      case Psystrike = 109
      case IceShard = 110
      case IcyWind = 111
      case FrostBreath = 112
      case Absorb = 113
      case GigaDrain = 114
      case FirePunch = 115
      case SolarBeam = 116
      case LeafBlade = 117
      case PowerWhip = 118
      case Splash = 119
      case Acid = 120
      case AirCutter = 121
      case Hurricane = 122
      case BrickBreak = 123
      case Cut = 124
      case Swift = 125
      case HornAttack = 126
      case Stomp = 127
      case Headbutt = 128
      case HyperFang = 129
      case Slam = 130
      case BodySlam = 131
      case Rest = 132
      case Struggle = 133
      case ScaldBlastoise = 134
      case HydroPumpBlastoise = 135
      case WrapGreen = 136
      case WrapPink = 137
      case FuryCutterFast = 200
      case BugBiteFast = 201
      case BiteFast = 202
      case SuckerPunchFast = 203
      case DragonBreathFast = 204
      case ThunderShockFast = 205
      case SparkFast = 206
      case LowKickFast = 207
      case KarateChopFast = 208
      case EmberFast = 209
      case WingAttackFast = 210
      case PeckFast = 211
      case LickFast = 212
      case ShadowClawFast = 213
      case VineWhipFast = 214
      case RazorLeafFast = 215
      case MudShotFast = 216
      case IceShardFast = 217
      case FrostBreathFast = 218
      case QuickAttackFast = 219
      case ScratchFast = 220
      case TackleFast = 221
      case PoundFast = 222
      case CutFast = 223
      case PoisonJabFast = 224
      case AcidFast = 225
      case PsychoCutFast = 226
      case RockThrowFast = 227
      case MetalClawFast = 228
      case BulletPunchFast = 229
      case WaterGunFast = 230
      case SplashFast = 231
      case WaterGunFastBlastoise = 232
      case MudSlapFast = 233
      case ZenHeadbuttFast = 234
      case ConfusionFast = 235
      case PoisonStingFast = 236
      case BubbleFast = 237
      case FeintAttackFast = 238
      case SteelWingFast = 239
      case FireFangFast = 240
      case RockSmashFast = 241

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .MoveUnset: return ".MoveUnset"
              case .ThunderShock: return ".ThunderShock"
              case .QuickAttack: return ".QuickAttack"
              case .Scratch: return ".Scratch"
              case .Ember: return ".Ember"
              case .VineWhip: return ".VineWhip"
              case .Tackle: return ".Tackle"
              case .RazorLeaf: return ".RazorLeaf"
              case .TakeDown: return ".TakeDown"
              case .WaterGun: return ".WaterGun"
              case .Bite: return ".Bite"
              case .Pound: return ".Pound"
              case .DoubleSlap: return ".DoubleSlap"
              case .Wrap: return ".Wrap"
              case .HyperBeam: return ".HyperBeam"
              case .Lick: return ".Lick"
              case .DarkPulse: return ".DarkPulse"
              case .Smog: return ".Smog"
              case .Sludge: return ".Sludge"
              case .MetalClaw: return ".MetalClaw"
              case .ViceGrip: return ".ViceGrip"
              case .FlameWheel: return ".FlameWheel"
              case .Megahorn: return ".Megahorn"
              case .WingAttack: return ".WingAttack"
              case .Flamethrower: return ".Flamethrower"
              case .SuckerPunch: return ".SuckerPunch"
              case .Dig: return ".Dig"
              case .LowKick: return ".LowKick"
              case .CrossChop: return ".CrossChop"
              case .PsychoCut: return ".PsychoCut"
              case .Psybeam: return ".Psybeam"
              case .Earthquake: return ".Earthquake"
              case .StoneEdge: return ".StoneEdge"
              case .IcePunch: return ".IcePunch"
              case .HeartStamp: return ".HeartStamp"
              case .Discharge: return ".Discharge"
              case .FlashCannon: return ".FlashCannon"
              case .Peck: return ".Peck"
              case .DrillPeck: return ".DrillPeck"
              case .IceBeam: return ".IceBeam"
              case .Blizzard: return ".Blizzard"
              case .AirSlash: return ".AirSlash"
              case .HeatWave: return ".HeatWave"
              case .Twineedle: return ".Twineedle"
              case .PoisonJab: return ".PoisonJab"
              case .AerialAce: return ".AerialAce"
              case .DrillRun: return ".DrillRun"
              case .PetalBlizzard: return ".PetalBlizzard"
              case .MegaDrain: return ".MegaDrain"
              case .BugBuzz: return ".BugBuzz"
              case .PoisonFang: return ".PoisonFang"
              case .NightSlash: return ".NightSlash"
              case .Slash: return ".Slash"
              case .BubbleBeam: return ".BubbleBeam"
              case .Submission: return ".Submission"
              case .KarateChop: return ".KarateChop"
              case .LowSweep: return ".LowSweep"
              case .AquaJet: return ".AquaJet"
              case .AquaTail: return ".AquaTail"
              case .SeedBomb: return ".SeedBomb"
              case .Psyshock: return ".Psyshock"
              case .RockThrow: return ".RockThrow"
              case .AncientPower: return ".AncientPower"
              case .RockTomb: return ".RockTomb"
              case .RockSlide: return ".RockSlide"
              case .PowerGem: return ".PowerGem"
              case .ShadowSneak: return ".ShadowSneak"
              case .ShadowPunch: return ".ShadowPunch"
              case .ShadowClaw: return ".ShadowClaw"
              case .OminousWind: return ".OminousWind"
              case .ShadowBall: return ".ShadowBall"
              case .BulletPunch: return ".BulletPunch"
              case .MagnetBomb: return ".MagnetBomb"
              case .SteelWing: return ".SteelWing"
              case .IronHead: return ".IronHead"
              case .ParabolicCharge: return ".ParabolicCharge"
              case .Spark: return ".Spark"
              case .ThunderPunch: return ".ThunderPunch"
              case .Thunder: return ".Thunder"
              case .Thunderbolt: return ".Thunderbolt"
              case .Twister: return ".Twister"
              case .DragonBreath: return ".DragonBreath"
              case .DragonPulse: return ".DragonPulse"
              case .DragonClaw: return ".DragonClaw"
              case .DisarmingVoice: return ".DisarmingVoice"
              case .DrainingKiss: return ".DrainingKiss"
              case .DazzlingGleam: return ".DazzlingGleam"
              case .Moonblast: return ".Moonblast"
              case .PlayRough: return ".PlayRough"
              case .CrossPoison: return ".CrossPoison"
              case .SludgeBomb: return ".SludgeBomb"
              case .SludgeWave: return ".SludgeWave"
              case .GunkShot: return ".GunkShot"
              case .MudShot: return ".MudShot"
              case .BoneClub: return ".BoneClub"
              case .Bulldoze: return ".Bulldoze"
              case .MudBomb: return ".MudBomb"
              case .FuryCutter: return ".FuryCutter"
              case .BugBite: return ".BugBite"
              case .SignalBeam: return ".SignalBeam"
              case .XScissor: return ".XScissor"
              case .FlameCharge: return ".FlameCharge"
              case .FlameBurst: return ".FlameBurst"
              case .FireBlast: return ".FireBlast"
              case .Brine: return ".Brine"
              case .WaterPulse: return ".WaterPulse"
              case .Scald: return ".Scald"
              case .HydroPump: return ".HydroPump"
              case .Psychic: return ".Psychic"
              case .Psystrike: return ".Psystrike"
              case .IceShard: return ".IceShard"
              case .IcyWind: return ".IcyWind"
              case .FrostBreath: return ".FrostBreath"
              case .Absorb: return ".Absorb"
              case .GigaDrain: return ".GigaDrain"
              case .FirePunch: return ".FirePunch"
              case .SolarBeam: return ".SolarBeam"
              case .LeafBlade: return ".LeafBlade"
              case .PowerWhip: return ".PowerWhip"
              case .Splash: return ".Splash"
              case .Acid: return ".Acid"
              case .AirCutter: return ".AirCutter"
              case .Hurricane: return ".Hurricane"
              case .BrickBreak: return ".BrickBreak"
              case .Cut: return ".Cut"
              case .Swift: return ".Swift"
              case .HornAttack: return ".HornAttack"
              case .Stomp: return ".Stomp"
              case .Headbutt: return ".Headbutt"
              case .HyperFang: return ".HyperFang"
              case .Slam: return ".Slam"
              case .BodySlam: return ".BodySlam"
              case .Rest: return ".Rest"
              case .Struggle: return ".Struggle"
              case .ScaldBlastoise: return ".ScaldBlastoise"
              case .HydroPumpBlastoise: return ".HydroPumpBlastoise"
              case .WrapGreen: return ".WrapGreen"
              case .WrapPink: return ".WrapPink"
              case .FuryCutterFast: return ".FuryCutterFast"
              case .BugBiteFast: return ".BugBiteFast"
              case .BiteFast: return ".BiteFast"
              case .SuckerPunchFast: return ".SuckerPunchFast"
              case .DragonBreathFast: return ".DragonBreathFast"
              case .ThunderShockFast: return ".ThunderShockFast"
              case .SparkFast: return ".SparkFast"
              case .LowKickFast: return ".LowKickFast"
              case .KarateChopFast: return ".KarateChopFast"
              case .EmberFast: return ".EmberFast"
              case .WingAttackFast: return ".WingAttackFast"
              case .PeckFast: return ".PeckFast"
              case .LickFast: return ".LickFast"
              case .ShadowClawFast: return ".ShadowClawFast"
              case .VineWhipFast: return ".VineWhipFast"
              case .RazorLeafFast: return ".RazorLeafFast"
              case .MudShotFast: return ".MudShotFast"
              case .IceShardFast: return ".IceShardFast"
              case .FrostBreathFast: return ".FrostBreathFast"
              case .QuickAttackFast: return ".QuickAttackFast"
              case .ScratchFast: return ".ScratchFast"
              case .TackleFast: return ".TackleFast"
              case .PoundFast: return ".PoundFast"
              case .CutFast: return ".CutFast"
              case .PoisonJabFast: return ".PoisonJabFast"
              case .AcidFast: return ".AcidFast"
              case .PsychoCutFast: return ".PsychoCutFast"
              case .RockThrowFast: return ".RockThrowFast"
              case .MetalClawFast: return ".MetalClawFast"
              case .BulletPunchFast: return ".BulletPunchFast"
              case .WaterGunFast: return ".WaterGunFast"
              case .SplashFast: return ".SplashFast"
              case .WaterGunFastBlastoise: return ".WaterGunFastBlastoise"
              case .MudSlapFast: return ".MudSlapFast"
              case .ZenHeadbuttFast: return ".ZenHeadbuttFast"
              case .ConfusionFast: return ".ConfusionFast"
              case .PoisonStingFast: return ".PoisonStingFast"
              case .BubbleFast: return ".BubbleFast"
              case .FeintAttackFast: return ".FeintAttackFast"
              case .SteelWingFast: return ".SteelWingFast"
              case .FireFangFast: return ".FireFangFast"
              case .RockSmashFast: return ".RockSmashFast"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum PokemonId:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case Missingno = 0
      case Bulbasaur = 1
      case Ivysaur = 2
      case Venusaur = 3
      case Charmender = 4
      case Charmeleon = 5
      case Charizard = 6
      case Squirtle = 7
      case Wartortle = 8
      case Blastoise = 9
      case Caterpie = 10
      case Metapod = 11
      case Butterfree = 12
      case Weedle = 13
      case Kakuna = 14
      case Beedrill = 15
      case Pidgey = 16
      case Pidgeotto = 17
      case Pidgeot = 18
      case Rattata = 19
      case Raticate = 20
      case Spearow = 21
      case Fearow = 22
      case Ekans = 23
      case Arbok = 24
      case Pikachu = 25
      case Raichu = 26
      case Sandshrew = 27
      case Sandlash = 28
      case NidoranFemale = 29
      case Nidorina = 30
      case Nidoqueen = 31
      case NidoranMale = 32
      case Nidorino = 33
      case Nidoking = 34
      case Clefary = 35
      case Clefable = 36
      case Vulpix = 37
      case Ninetales = 38
      case Jigglypuff = 39
      case Wigglytuff = 40
      case Zubat = 41
      case Golbat = 42
      case Oddish = 43
      case Gloom = 44
      case Vileplume = 45
      case Paras = 46
      case Parasect = 47
      case Venonat = 48
      case Venomoth = 49
      case Diglett = 50
      case Dugtrio = 51
      case Meowth = 52
      case Persian = 53
      case Psyduck = 54
      case Golduck = 55
      case Mankey = 56
      case Primeape = 57
      case Growlithe = 58
      case Arcanine = 59
      case Poliwag = 60
      case Poliwhirl = 61
      case Poliwrath = 62
      case Abra = 63
      case Kadabra = 64
      case Alakhazam = 65
      case Machop = 66
      case Machoke = 67
      case Machamp = 68
      case Bellsprout = 69
      case Weepinbell = 70
      case Victreebell = 71
      case Tentacool = 72
      case Tentacruel = 73
      case Geoduge = 74
      case Graveler = 75
      case Golem = 76
      case Ponyta = 77
      case Rapidash = 78
      case Slowpoke = 79
      case Slowbro = 80
      case Magnemite = 81
      case Magneton = 82
      case Farfetchd = 83
      case Doduo = 84
      case Dodrio = 85
      case Seel = 86
      case Dewgong = 87
      case Grimer = 88
      case Muk = 89
      case Shellder = 90
      case Cloyster = 91
      case Gastly = 92
      case Haunter = 93
      case Gengar = 94
      case Onix = 95
      case Drowzee = 96
      case Hypno = 97
      case Krabby = 98
      case Kingler = 99
      case Voltorb = 100
      case Electrode = 101
      case Exeggcute = 102
      case Exeggutor = 103
      case Cubone = 104
      case Marowak = 105
      case Hitmonlee = 106
      case Hitmonchan = 107
      case Lickitung = 108
      case Koffing = 109
      case Weezing = 110
      case Rhyhorn = 111
      case Rhydon = 112
      case Chansey = 113
      case Tangela = 114
      case Kangaskhan = 115
      case Horsea = 116
      case Seadra = 117
      case Goldeen = 118
      case Seaking = 119
      case Staryu = 120
      case Starmie = 121
      case MrMime = 122
      case Scyther = 123
      case Jynx = 124
      case Electabuzz = 125
      case Magmar = 126
      case Pinsir = 127
      case Tauros = 128
      case Magikarp = 129
      case Gyarados = 130
      case Lapras = 131
      case Ditto = 132
      case Eevee = 133
      case Vaporeon = 134
      case Jolteon = 135
      case Flareon = 136
      case Porygon = 137
      case Omanyte = 138
      case Omastar = 139
      case Kabuto = 140
      case Kabutops = 141
      case Aerodactyl = 142
      case Snorlax = 143
      case Articuno = 144
      case Zapdos = 145
      case Moltres = 146
      case Dratini = 147
      case Dragonair = 148
      case Dragonite = 149
      case Mewtwo = 150
      case Mew = 151

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .Missingno: return ".Missingno"
              case .Bulbasaur: return ".Bulbasaur"
              case .Ivysaur: return ".Ivysaur"
              case .Venusaur: return ".Venusaur"
              case .Charmender: return ".Charmender"
              case .Charmeleon: return ".Charmeleon"
              case .Charizard: return ".Charizard"
              case .Squirtle: return ".Squirtle"
              case .Wartortle: return ".Wartortle"
              case .Blastoise: return ".Blastoise"
              case .Caterpie: return ".Caterpie"
              case .Metapod: return ".Metapod"
              case .Butterfree: return ".Butterfree"
              case .Weedle: return ".Weedle"
              case .Kakuna: return ".Kakuna"
              case .Beedrill: return ".Beedrill"
              case .Pidgey: return ".Pidgey"
              case .Pidgeotto: return ".Pidgeotto"
              case .Pidgeot: return ".Pidgeot"
              case .Rattata: return ".Rattata"
              case .Raticate: return ".Raticate"
              case .Spearow: return ".Spearow"
              case .Fearow: return ".Fearow"
              case .Ekans: return ".Ekans"
              case .Arbok: return ".Arbok"
              case .Pikachu: return ".Pikachu"
              case .Raichu: return ".Raichu"
              case .Sandshrew: return ".Sandshrew"
              case .Sandlash: return ".Sandlash"
              case .NidoranFemale: return ".NidoranFemale"
              case .Nidorina: return ".Nidorina"
              case .Nidoqueen: return ".Nidoqueen"
              case .NidoranMale: return ".NidoranMale"
              case .Nidorino: return ".Nidorino"
              case .Nidoking: return ".Nidoking"
              case .Clefary: return ".Clefary"
              case .Clefable: return ".Clefable"
              case .Vulpix: return ".Vulpix"
              case .Ninetales: return ".Ninetales"
              case .Jigglypuff: return ".Jigglypuff"
              case .Wigglytuff: return ".Wigglytuff"
              case .Zubat: return ".Zubat"
              case .Golbat: return ".Golbat"
              case .Oddish: return ".Oddish"
              case .Gloom: return ".Gloom"
              case .Vileplume: return ".Vileplume"
              case .Paras: return ".Paras"
              case .Parasect: return ".Parasect"
              case .Venonat: return ".Venonat"
              case .Venomoth: return ".Venomoth"
              case .Diglett: return ".Diglett"
              case .Dugtrio: return ".Dugtrio"
              case .Meowth: return ".Meowth"
              case .Persian: return ".Persian"
              case .Psyduck: return ".Psyduck"
              case .Golduck: return ".Golduck"
              case .Mankey: return ".Mankey"
              case .Primeape: return ".Primeape"
              case .Growlithe: return ".Growlithe"
              case .Arcanine: return ".Arcanine"
              case .Poliwag: return ".Poliwag"
              case .Poliwhirl: return ".Poliwhirl"
              case .Poliwrath: return ".Poliwrath"
              case .Abra: return ".Abra"
              case .Kadabra: return ".Kadabra"
              case .Alakhazam: return ".Alakhazam"
              case .Machop: return ".Machop"
              case .Machoke: return ".Machoke"
              case .Machamp: return ".Machamp"
              case .Bellsprout: return ".Bellsprout"
              case .Weepinbell: return ".Weepinbell"
              case .Victreebell: return ".Victreebell"
              case .Tentacool: return ".Tentacool"
              case .Tentacruel: return ".Tentacruel"
              case .Geoduge: return ".Geoduge"
              case .Graveler: return ".Graveler"
              case .Golem: return ".Golem"
              case .Ponyta: return ".Ponyta"
              case .Rapidash: return ".Rapidash"
              case .Slowpoke: return ".Slowpoke"
              case .Slowbro: return ".Slowbro"
              case .Magnemite: return ".Magnemite"
              case .Magneton: return ".Magneton"
              case .Farfetchd: return ".Farfetchd"
              case .Doduo: return ".Doduo"
              case .Dodrio: return ".Dodrio"
              case .Seel: return ".Seel"
              case .Dewgong: return ".Dewgong"
              case .Grimer: return ".Grimer"
              case .Muk: return ".Muk"
              case .Shellder: return ".Shellder"
              case .Cloyster: return ".Cloyster"
              case .Gastly: return ".Gastly"
              case .Haunter: return ".Haunter"
              case .Gengar: return ".Gengar"
              case .Onix: return ".Onix"
              case .Drowzee: return ".Drowzee"
              case .Hypno: return ".Hypno"
              case .Krabby: return ".Krabby"
              case .Kingler: return ".Kingler"
              case .Voltorb: return ".Voltorb"
              case .Electrode: return ".Electrode"
              case .Exeggcute: return ".Exeggcute"
              case .Exeggutor: return ".Exeggutor"
              case .Cubone: return ".Cubone"
              case .Marowak: return ".Marowak"
              case .Hitmonlee: return ".Hitmonlee"
              case .Hitmonchan: return ".Hitmonchan"
              case .Lickitung: return ".Lickitung"
              case .Koffing: return ".Koffing"
              case .Weezing: return ".Weezing"
              case .Rhyhorn: return ".Rhyhorn"
              case .Rhydon: return ".Rhydon"
              case .Chansey: return ".Chansey"
              case .Tangela: return ".Tangela"
              case .Kangaskhan: return ".Kangaskhan"
              case .Horsea: return ".Horsea"
              case .Seadra: return ".Seadra"
              case .Goldeen: return ".Goldeen"
              case .Seaking: return ".Seaking"
              case .Staryu: return ".Staryu"
              case .Starmie: return ".Starmie"
              case .MrMime: return ".MrMime"
              case .Scyther: return ".Scyther"
              case .Jynx: return ".Jynx"
              case .Electabuzz: return ".Electabuzz"
              case .Magmar: return ".Magmar"
              case .Pinsir: return ".Pinsir"
              case .Tauros: return ".Tauros"
              case .Magikarp: return ".Magikarp"
              case .Gyarados: return ".Gyarados"
              case .Lapras: return ".Lapras"
              case .Ditto: return ".Ditto"
              case .Eevee: return ".Eevee"
              case .Vaporeon: return ".Vaporeon"
              case .Jolteon: return ".Jolteon"
              case .Flareon: return ".Flareon"
              case .Porygon: return ".Porygon"
              case .Omanyte: return ".Omanyte"
              case .Omastar: return ".Omastar"
              case .Kabuto: return ".Kabuto"
              case .Kabutops: return ".Kabutops"
              case .Aerodactyl: return ".Aerodactyl"
              case .Snorlax: return ".Snorlax"
              case .Articuno: return ".Articuno"
              case .Zapdos: return ".Zapdos"
              case .Moltres: return ".Moltres"
              case .Dratini: return ".Dratini"
              case .Dragonair: return ".Dragonair"
              case .Dragonite: return ".Dragonite"
              case .Mewtwo: return ".Mewtwo"
              case .Mew: return ".Mew"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum ItemType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case ItemTypeNone = 0
      case ItemTypePokeball = 1
      case ItemTypePotion = 2
      case ItemTypeRevive = 3
      case ItemTypeMap = 4
      case ItemTypeBattle = 5
      case ItemTypeFood = 6
      case ItemTypeCamera = 7
      case ItemTypeDisk = 8
      case ItemTypeIncubator = 9
      case ItemTypeIncense = 10
      case ItemTypeXpBoost = 11
      case ItemTypeInventoryUpgrade = 12

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .ItemTypeNone: return ".ItemTypeNone"
              case .ItemTypePokeball: return ".ItemTypePokeball"
              case .ItemTypePotion: return ".ItemTypePotion"
              case .ItemTypeRevive: return ".ItemTypeRevive"
              case .ItemTypeMap: return ".ItemTypeMap"
              case .ItemTypeBattle: return ".ItemTypeBattle"
              case .ItemTypeFood: return ".ItemTypeFood"
              case .ItemTypeCamera: return ".ItemTypeCamera"
              case .ItemTypeDisk: return ".ItemTypeDisk"
              case .ItemTypeIncubator: return ".ItemTypeIncubator"
              case .ItemTypeIncense: return ".ItemTypeIncense"
              case .ItemTypeXpBoost: return ".ItemTypeXpBoost"
              case .ItemTypeInventoryUpgrade: return ".ItemTypeInventoryUpgrade"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum InventoryUpgradeType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case UpgradeUnset = 0
      case IncreaseItemStorage = 1
      case IncreasePokemonStorage = 2

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .UpgradeUnset: return ".UpgradeUnset"
              case .IncreaseItemStorage: return ".IncreaseItemStorage"
              case .IncreasePokemonStorage: return ".IncreasePokemonStorage"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum ItemId:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case ItemUnknown = 0
      case ItemPokeBall = 1
      case ItemGreatBall = 2
      case ItemUltraBall = 3
      case ItemMasterBall = 4
      case ItemPotion = 101
      case ItemSuperPotion = 102
      case ItemHyperPotion = 103
      case ItemMaxPotion = 104
      case ItemRevive = 201
      case ItemMaxRevive = 202
      case ItemLuckyEgg = 301
      case ItemIncenseOrdinary = 401
      case ItemIncenseSpicy = 402
      case ItemIncenseCool = 403
      case ItemIncenseFloral = 404
      case ItemTroyDisk = 501
      case ItemXAttack = 602
      case ItemXDefense = 603
      case ItemXMiracle = 604
      case ItemRazzBerry = 701
      case ItemBlukBerry = 702
      case ItemNanabBerry = 703
      case ItemWeparBerry = 704
      case ItemPinapBerry = 705
      case ItemSpecialCamera = 801
      case ItemIncubatorBasicUnlimited = 901
      case ItemIncubatorBasic = 902
      case ItemPokemonStorageUpgrade = 1001
      case ItemItemStorageUpgrade = 1002

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .ItemUnknown: return ".ItemUnknown"
              case .ItemPokeBall: return ".ItemPokeBall"
              case .ItemGreatBall: return ".ItemGreatBall"
              case .ItemUltraBall: return ".ItemUltraBall"
              case .ItemMasterBall: return ".ItemMasterBall"
              case .ItemPotion: return ".ItemPotion"
              case .ItemSuperPotion: return ".ItemSuperPotion"
              case .ItemHyperPotion: return ".ItemHyperPotion"
              case .ItemMaxPotion: return ".ItemMaxPotion"
              case .ItemRevive: return ".ItemRevive"
              case .ItemMaxRevive: return ".ItemMaxRevive"
              case .ItemLuckyEgg: return ".ItemLuckyEgg"
              case .ItemIncenseOrdinary: return ".ItemIncenseOrdinary"
              case .ItemIncenseSpicy: return ".ItemIncenseSpicy"
              case .ItemIncenseCool: return ".ItemIncenseCool"
              case .ItemIncenseFloral: return ".ItemIncenseFloral"
              case .ItemTroyDisk: return ".ItemTroyDisk"
              case .ItemXAttack: return ".ItemXAttack"
              case .ItemXDefense: return ".ItemXDefense"
              case .ItemXMiracle: return ".ItemXMiracle"
              case .ItemRazzBerry: return ".ItemRazzBerry"
              case .ItemBlukBerry: return ".ItemBlukBerry"
              case .ItemNanabBerry: return ".ItemNanabBerry"
              case .ItemWeparBerry: return ".ItemWeparBerry"
              case .ItemPinapBerry: return ".ItemPinapBerry"
              case .ItemSpecialCamera: return ".ItemSpecialCamera"
              case .ItemIncubatorBasicUnlimited: return ".ItemIncubatorBasicUnlimited"
              case .ItemIncubatorBasic: return ".ItemIncubatorBasic"
              case .ItemPokemonStorageUpgrade: return ".ItemPokemonStorageUpgrade"
              case .ItemItemStorageUpgrade: return ".ItemItemStorageUpgrade"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum EggIncubatorType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case IncubatorUnset = 0
      case IncubatorDistance = 1

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .IncubatorUnset: return ".IncubatorUnset"
              case .IncubatorDistance: return ".IncubatorDistance"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum PokemonFamilyId:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case FamilyUnset = 0
      case FamilyBulbasaur = 1
      case FamilyCharmander = 4
      case FamilySquirtle = 7
      case FamilyCaterpie = 10
      case FamilyWeedle = 13
      case FamilyPidgey = 16
      case FamilyRattata = 19
      case FamilySpearow = 21
      case FamilyEkans = 23
      case FamilyPikachu = 25
      case FamilySandshrew = 27
      case FamilyNidoran = 29
      case FamilyNidoran2 = 32
      case FamilyClefairy = 35
      case FamilyVulpix = 37
      case FamilyJigglypuff = 39
      case FamilyZubat = 41
      case FamilyOddish = 43
      case FamilyParas = 46
      case FamilyVenonat = 48
      case FamilyDiglett = 50
      case FamilyMeowth = 52
      case FamilyPsyduck = 54
      case FamilyMankey = 56
      case FamilyGrowlithe = 58
      case FamilyPoliwag = 60
      case FamilyAbra = 63
      case FamilyMachop = 66
      case FamilyBellsprout = 69
      case FamilyTentacool = 72
      case FamilyGeodude = 74
      case FamilyPonyta = 77
      case FamilySlowpoke = 79
      case FamilyMagnemite = 81
      case FamilyFarfetchd = 83
      case FamilyDoduo = 84
      case FamilySeel = 86
      case FamilyGrimer = 88
      case FamilyShellder = 90
      case FamilyGastly = 92
      case FamilyOnix = 95
      case FamilyDrowzee = 96
      case FamilyKrabby = 98
      case FamilyVoltorb = 100
      case FamilyExeggcute = 102
      case FamilyCubone = 104
      case FamilyHitmonlee = 106
      case FamilyHitmonchan = 107
      case FamilyLickitung = 108
      case FamilyKoffing = 109
      case FamilyRhyhorn = 111
      case FamilyChansey = 113
      case FamilyTangela = 114
      case FamilyKangaskhan = 115
      case FamilyHorsea = 116
      case FamilyGoldeen = 118
      case FamilyStaryu = 120
      case FamilyMrMime = 122
      case FamilyScyther = 123
      case FamilyJynx = 124
      case FamilyElectabuzz = 125
      case FamilyMagmar = 126
      case FamilyPinsir = 127
      case FamilyTauros = 128
      case FamilyMagikarp = 129
      case FamilyLapras = 131
      case FamilyDitto = 132
      case FamilyEevee = 133
      case FamilyPorygon = 137
      case FamilyOmanyte = 138
      case FamilyKabuto = 140
      case FamilyAerodactyl = 142
      case FamilySnorlax = 143
      case FamilyArticuno = 144
      case FamilyZapdos = 145
      case FamilyMoltres = 146
      case FamilyDratini = 147
      case FamilyMewtwo = 150
      case FamilyMew = 151

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .FamilyUnset: return ".FamilyUnset"
              case .FamilyBulbasaur: return ".FamilyBulbasaur"
              case .FamilyCharmander: return ".FamilyCharmander"
              case .FamilySquirtle: return ".FamilySquirtle"
              case .FamilyCaterpie: return ".FamilyCaterpie"
              case .FamilyWeedle: return ".FamilyWeedle"
              case .FamilyPidgey: return ".FamilyPidgey"
              case .FamilyRattata: return ".FamilyRattata"
              case .FamilySpearow: return ".FamilySpearow"
              case .FamilyEkans: return ".FamilyEkans"
              case .FamilyPikachu: return ".FamilyPikachu"
              case .FamilySandshrew: return ".FamilySandshrew"
              case .FamilyNidoran: return ".FamilyNidoran"
              case .FamilyNidoran2: return ".FamilyNidoran2"
              case .FamilyClefairy: return ".FamilyClefairy"
              case .FamilyVulpix: return ".FamilyVulpix"
              case .FamilyJigglypuff: return ".FamilyJigglypuff"
              case .FamilyZubat: return ".FamilyZubat"
              case .FamilyOddish: return ".FamilyOddish"
              case .FamilyParas: return ".FamilyParas"
              case .FamilyVenonat: return ".FamilyVenonat"
              case .FamilyDiglett: return ".FamilyDiglett"
              case .FamilyMeowth: return ".FamilyMeowth"
              case .FamilyPsyduck: return ".FamilyPsyduck"
              case .FamilyMankey: return ".FamilyMankey"
              case .FamilyGrowlithe: return ".FamilyGrowlithe"
              case .FamilyPoliwag: return ".FamilyPoliwag"
              case .FamilyAbra: return ".FamilyAbra"
              case .FamilyMachop: return ".FamilyMachop"
              case .FamilyBellsprout: return ".FamilyBellsprout"
              case .FamilyTentacool: return ".FamilyTentacool"
              case .FamilyGeodude: return ".FamilyGeodude"
              case .FamilyPonyta: return ".FamilyPonyta"
              case .FamilySlowpoke: return ".FamilySlowpoke"
              case .FamilyMagnemite: return ".FamilyMagnemite"
              case .FamilyFarfetchd: return ".FamilyFarfetchd"
              case .FamilyDoduo: return ".FamilyDoduo"
              case .FamilySeel: return ".FamilySeel"
              case .FamilyGrimer: return ".FamilyGrimer"
              case .FamilyShellder: return ".FamilyShellder"
              case .FamilyGastly: return ".FamilyGastly"
              case .FamilyOnix: return ".FamilyOnix"
              case .FamilyDrowzee: return ".FamilyDrowzee"
              case .FamilyKrabby: return ".FamilyKrabby"
              case .FamilyVoltorb: return ".FamilyVoltorb"
              case .FamilyExeggcute: return ".FamilyExeggcute"
              case .FamilyCubone: return ".FamilyCubone"
              case .FamilyHitmonlee: return ".FamilyHitmonlee"
              case .FamilyHitmonchan: return ".FamilyHitmonchan"
              case .FamilyLickitung: return ".FamilyLickitung"
              case .FamilyKoffing: return ".FamilyKoffing"
              case .FamilyRhyhorn: return ".FamilyRhyhorn"
              case .FamilyChansey: return ".FamilyChansey"
              case .FamilyTangela: return ".FamilyTangela"
              case .FamilyKangaskhan: return ".FamilyKangaskhan"
              case .FamilyHorsea: return ".FamilyHorsea"
              case .FamilyGoldeen: return ".FamilyGoldeen"
              case .FamilyStaryu: return ".FamilyStaryu"
              case .FamilyMrMime: return ".FamilyMrMime"
              case .FamilyScyther: return ".FamilyScyther"
              case .FamilyJynx: return ".FamilyJynx"
              case .FamilyElectabuzz: return ".FamilyElectabuzz"
              case .FamilyMagmar: return ".FamilyMagmar"
              case .FamilyPinsir: return ".FamilyPinsir"
              case .FamilyTauros: return ".FamilyTauros"
              case .FamilyMagikarp: return ".FamilyMagikarp"
              case .FamilyLapras: return ".FamilyLapras"
              case .FamilyDitto: return ".FamilyDitto"
              case .FamilyEevee: return ".FamilyEevee"
              case .FamilyPorygon: return ".FamilyPorygon"
              case .FamilyOmanyte: return ".FamilyOmanyte"
              case .FamilyKabuto: return ".FamilyKabuto"
              case .FamilyAerodactyl: return ".FamilyAerodactyl"
              case .FamilySnorlax: return ".FamilySnorlax"
              case .FamilyArticuno: return ".FamilyArticuno"
              case .FamilyZapdos: return ".FamilyZapdos"
              case .FamilyMoltres: return ".FamilyMoltres"
              case .FamilyDratini: return ".FamilyDratini"
              case .FamilyMewtwo: return ".FamilyMewtwo"
              case .FamilyMew: return ".FamilyMew"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum FortType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case Gym = 0
      case Checkpoint = 1

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .Gym: return ".Gym"
              case .Checkpoint: return ".Checkpoint"
          }
      }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum ActivityType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
      case ActivityUnknown = 0
      case ActivityCatchPokemon = 1
      case ActivityCatchLegendPokemon = 2
      case ActivityFleePokemon = 3
      case ActivityDefeatFort = 4
      case ActivityEvolvePokemon = 5
      case ActivityHatchEgg = 6
      case ActivityWalkKm = 7
      case ActivityPokedexEntryNew = 8
      case ActivityCatchFirstThrow = 9
      case ActivityCatchNiceThrow = 10
      case ActivityCatchGreatThrow = 11
      case ActivityCatchExcellentThrow = 12
      case ActivityCatchCurveball = 13
      case ActivityCatchFirstCatchOfDay = 14
      case ActivityCatchMilestone = 15
      case ActivityTrainPokemon = 16
      case ActivitySearchFort = 17
      case ActivityReleasePokemon = 18
      case ActivityHatchEggSmallBonus = 19
      case ActivityHatchEggMediumBonus = 20
      case ActivityHatchEggLargeBonus = 21
      case ActivityDefeatGymDefender = 22
      case ActivityDefeatGymLeader = 23

      public var debugDescription:String { return getDescription() }
      public var description:String { return getDescription() }
      private func getDescription() -> String { 
          switch self {
              case .ActivityUnknown: return ".ActivityUnknown"
              case .ActivityCatchPokemon: return ".ActivityCatchPokemon"
              case .ActivityCatchLegendPokemon: return ".ActivityCatchLegendPokemon"
              case .ActivityFleePokemon: return ".ActivityFleePokemon"
              case .ActivityDefeatFort: return ".ActivityDefeatFort"
              case .ActivityEvolvePokemon: return ".ActivityEvolvePokemon"
              case .ActivityHatchEgg: return ".ActivityHatchEgg"
              case .ActivityWalkKm: return ".ActivityWalkKm"
              case .ActivityPokedexEntryNew: return ".ActivityPokedexEntryNew"
              case .ActivityCatchFirstThrow: return ".ActivityCatchFirstThrow"
              case .ActivityCatchNiceThrow: return ".ActivityCatchNiceThrow"
              case .ActivityCatchGreatThrow: return ".ActivityCatchGreatThrow"
              case .ActivityCatchExcellentThrow: return ".ActivityCatchExcellentThrow"
              case .ActivityCatchCurveball: return ".ActivityCatchCurveball"
              case .ActivityCatchFirstCatchOfDay: return ".ActivityCatchFirstCatchOfDay"
              case .ActivityCatchMilestone: return ".ActivityCatchMilestone"
              case .ActivityTrainPokemon: return ".ActivityTrainPokemon"
              case .ActivitySearchFort: return ".ActivitySearchFort"
              case .ActivityReleasePokemon: return ".ActivityReleasePokemon"
              case .ActivityHatchEggSmallBonus: return ".ActivityHatchEggSmallBonus"
              case .ActivityHatchEggMediumBonus: return ".ActivityHatchEggMediumBonus"
              case .ActivityHatchEggLargeBonus: return ".ActivityHatchEggLargeBonus"
              case .ActivityDefeatGymDefender: return ".ActivityDefeatGymDefender"
              case .ActivityDefeatGymLeader: return ".ActivityDefeatGymLeader"
          }
      }
    }

    //Enum type declaration end 

  public private(set) var unknown1:Int32 = Int32(0)

  public private(set) var hasUnknown1:Bool = false
  public private(set) var unknown2:Int64 = Int64(0)

  public private(set) var hasUnknown2:Bool = false
  public private(set) var apiUrl:String = ""

  public private(set) var hasApiUrl:Bool = false
  public private(set) var unknown6:ResponseEnvelop.Unknown6!
  public private(set) var hasUnknown6:Bool = false
  public private(set) var authTicket:ResponseEnvelop.AuthTicket!
  public private(set) var hasAuthTicket:Bool = false
  public private(set) var payload:Array<NSData> = Array<NSData>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if hasUnknown6 {
     if !unknown6.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasUnknown1 {
      try output.writeInt32(1, value:unknown1)
    }
    if hasUnknown2 {
      try output.writeInt64(2, value:unknown2)
    }
    if hasApiUrl {
      try output.writeString(3, value:apiUrl)
    }
    if hasUnknown6 {
      try output.writeMessage(6, value:unknown6)
    }
    if hasAuthTicket {
      try output.writeMessage(7, value:authTicket)
    }
    if !payload.isEmpty {
      for oneValuepayload in payload {
        try output.writeData(100, value:oneValuepayload)
      }
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasUnknown1 {
      serialize_size += unknown1.computeInt32Size(1)
    }
    if hasUnknown2 {
      serialize_size += unknown2.computeInt64Size(2)
    }
    if hasApiUrl {
      serialize_size += apiUrl.computeStringSize(3)
    }
    if hasUnknown6 {
        if let varSizeunknown6 = unknown6?.computeMessageSize(6) {
            serialize_size += varSizeunknown6
        }
    }
    if hasAuthTicket {
        if let varSizeauthTicket = authTicket?.computeMessageSize(7) {
            serialize_size += varSizeauthTicket
        }
    }
    var dataSizePayload:Int32 = 0
    for oneValuepayload in payload {
        dataSizePayload += oneValuepayload.computeDataSizeNoTag()
    }
    serialize_size += dataSizePayload
    serialize_size += 2 * Int32(payload.count)
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResponseEnvelop> {
    var mergedArray = Array<ResponseEnvelop>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResponseEnvelop? {
    return try ResponseEnvelop.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> ResponseEnvelop {
    return try ResponseEnvelop.Builder().mergeFromData(data, extensionRegistry:PokemonRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop {
    return try ResponseEnvelop.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> ResponseEnvelop {
    return try ResponseEnvelop.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop {
    return try ResponseEnvelop.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop {
    return try ResponseEnvelop.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop {
    return try ResponseEnvelop.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ResponseEnvelop.Builder {
    return ResponseEnvelop.classBuilder() as! ResponseEnvelop.Builder
  }
  public func getBuilder() -> ResponseEnvelop.Builder {
    return classBuilder() as! ResponseEnvelop.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ResponseEnvelop.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ResponseEnvelop.Builder()
  }
  public func toBuilder() throws -> ResponseEnvelop.Builder {
    return try ResponseEnvelop.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ResponseEnvelop) throws -> ResponseEnvelop.Builder {
    return try ResponseEnvelop.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasUnknown1 {
      output += "\(indent) unknown1: \(unknown1) \n"
    }
    if hasUnknown2 {
      output += "\(indent) unknown2: \(unknown2) \n"
    }
    if hasApiUrl {
      output += "\(indent) apiUrl: \(apiUrl) \n"
    }
    if hasUnknown6 {
      output += "\(indent) unknown6 {\n"
      if let outDescUnknown6 = unknown6 {
        output += try outDescUnknown6.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasAuthTicket {
      output += "\(indent) authTicket {\n"
      if let outDescAuthTicket = authTicket {
        output += try outDescAuthTicket.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var payloadElementIndex:Int = 0
    for oneValuepayload in payload  {
        output += "\(indent) payload[\(payloadElementIndex)]: \(oneValuepayload)\n"
        payloadElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasUnknown1 {
             hashCode = (hashCode &* 31) &+ unknown1.hashValue
          }
          if hasUnknown2 {
             hashCode = (hashCode &* 31) &+ unknown2.hashValue
          }
          if hasApiUrl {
             hashCode = (hashCode &* 31) &+ apiUrl.hashValue
          }
          if hasUnknown6 {
              if let hashValueunknown6 = unknown6?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueunknown6
              }
          }
          if hasAuthTicket {
              if let hashValueauthTicket = authTicket?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueauthTicket
              }
          }
          for oneValuepayload in payload {
              hashCode = (hashCode &* 31) &+ oneValuepayload.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ResponseEnvelop"
  }
  override public func className() -> String {
      return "ResponseEnvelop"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ResponseEnvelop.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ResponseEnvelop = ResponseEnvelop()
    public func getMessage() -> ResponseEnvelop {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasUnknown1:Bool {
         get {
              return builderResult.hasUnknown1
         }
    }
    public var unknown1:Int32 {
         get {
              return builderResult.unknown1
         }
         set (value) {
             builderResult.hasUnknown1 = true
             builderResult.unknown1 = value
         }
    }
    public func setUnknown1(value:Int32) -> ResponseEnvelop.Builder {
      self.unknown1 = value
      return self
    }
    public func clearUnknown1() -> ResponseEnvelop.Builder{
         builderResult.hasUnknown1 = false
         builderResult.unknown1 = Int32(0)
         return self
    }
    public var hasUnknown2:Bool {
         get {
              return builderResult.hasUnknown2
         }
    }
    public var unknown2:Int64 {
         get {
              return builderResult.unknown2
         }
         set (value) {
             builderResult.hasUnknown2 = true
             builderResult.unknown2 = value
         }
    }
    public func setUnknown2(value:Int64) -> ResponseEnvelop.Builder {
      self.unknown2 = value
      return self
    }
    public func clearUnknown2() -> ResponseEnvelop.Builder{
         builderResult.hasUnknown2 = false
         builderResult.unknown2 = Int64(0)
         return self
    }
    public var hasApiUrl:Bool {
         get {
              return builderResult.hasApiUrl
         }
    }
    public var apiUrl:String {
         get {
              return builderResult.apiUrl
         }
         set (value) {
             builderResult.hasApiUrl = true
             builderResult.apiUrl = value
         }
    }
    public func setApiUrl(value:String) -> ResponseEnvelop.Builder {
      self.apiUrl = value
      return self
    }
    public func clearApiUrl() -> ResponseEnvelop.Builder{
         builderResult.hasApiUrl = false
         builderResult.apiUrl = ""
         return self
    }
    public var hasUnknown6:Bool {
         get {
             return builderResult.hasUnknown6
         }
    }
    public var unknown6:ResponseEnvelop.Unknown6! {
         get {
             if unknown6Builder_ != nil {
                builderResult.unknown6 = unknown6Builder_.getMessage()
             }
             return builderResult.unknown6
         }
         set (value) {
             builderResult.hasUnknown6 = true
             builderResult.unknown6 = value
         }
    }
    private var unknown6Builder_:ResponseEnvelop.Unknown6.Builder! {
         didSet {
            builderResult.hasUnknown6 = true
         }
    }
    public func getUnknown6Builder() -> ResponseEnvelop.Unknown6.Builder {
      if unknown6Builder_ == nil {
         unknown6Builder_ = ResponseEnvelop.Unknown6.Builder()
         builderResult.unknown6 = unknown6Builder_.getMessage()
         if unknown6 != nil {
            try! unknown6Builder_.mergeFrom(unknown6)
         }
      }
      return unknown6Builder_
    }
    public func setUnknown6(value:ResponseEnvelop.Unknown6!) -> ResponseEnvelop.Builder {
      self.unknown6 = value
      return self
    }
    public func mergeUnknown6(value:ResponseEnvelop.Unknown6) throws -> ResponseEnvelop.Builder {
      if builderResult.hasUnknown6 {
        builderResult.unknown6 = try ResponseEnvelop.Unknown6.builderWithPrototype(builderResult.unknown6).mergeFrom(value).buildPartial()
      } else {
        builderResult.unknown6 = value
      }
      builderResult.hasUnknown6 = true
      return self
    }
    public func clearUnknown6() -> ResponseEnvelop.Builder {
      unknown6Builder_ = nil
      builderResult.hasUnknown6 = false
      builderResult.unknown6 = nil
      return self
    }
    public var hasAuthTicket:Bool {
         get {
             return builderResult.hasAuthTicket
         }
    }
    public var authTicket:ResponseEnvelop.AuthTicket! {
         get {
             if authTicketBuilder_ != nil {
                builderResult.authTicket = authTicketBuilder_.getMessage()
             }
             return builderResult.authTicket
         }
         set (value) {
             builderResult.hasAuthTicket = true
             builderResult.authTicket = value
         }
    }
    private var authTicketBuilder_:ResponseEnvelop.AuthTicket.Builder! {
         didSet {
            builderResult.hasAuthTicket = true
         }
    }
    public func getAuthTicketBuilder() -> ResponseEnvelop.AuthTicket.Builder {
      if authTicketBuilder_ == nil {
         authTicketBuilder_ = ResponseEnvelop.AuthTicket.Builder()
         builderResult.authTicket = authTicketBuilder_.getMessage()
         if authTicket != nil {
            try! authTicketBuilder_.mergeFrom(authTicket)
         }
      }
      return authTicketBuilder_
    }
    public func setAuthTicket(value:ResponseEnvelop.AuthTicket!) -> ResponseEnvelop.Builder {
      self.authTicket = value
      return self
    }
    public func mergeAuthTicket(value:ResponseEnvelop.AuthTicket) throws -> ResponseEnvelop.Builder {
      if builderResult.hasAuthTicket {
        builderResult.authTicket = try ResponseEnvelop.AuthTicket.builderWithPrototype(builderResult.authTicket).mergeFrom(value).buildPartial()
      } else {
        builderResult.authTicket = value
      }
      builderResult.hasAuthTicket = true
      return self
    }
    public func clearAuthTicket() -> ResponseEnvelop.Builder {
      authTicketBuilder_ = nil
      builderResult.hasAuthTicket = false
      builderResult.authTicket = nil
      return self
    }
    public var payload:Array<NSData> {
         get {
             return builderResult.payload
         }
         set (array) {
             builderResult.payload = array
         }
    }
    public func setPayload(value:Array<NSData>) -> ResponseEnvelop.Builder {
      self.payload = value
      return self
    }
    public func clearPayload() -> ResponseEnvelop.Builder {
       builderResult.payload.removeAll(keepCapacity: false)
       return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ResponseEnvelop.Builder {
      builderResult = ResponseEnvelop()
      return self
    }
    public override func clone() throws -> ResponseEnvelop.Builder {
      return try ResponseEnvelop.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ResponseEnvelop {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ResponseEnvelop {
      let returnMe:ResponseEnvelop = builderResult
      return returnMe
    }
    public func mergeFrom(other:ResponseEnvelop) throws -> ResponseEnvelop.Builder {
      if other == ResponseEnvelop() {
       return self
      }
      if other.hasUnknown1 {
           unknown1 = other.unknown1
      }
      if other.hasUnknown2 {
           unknown2 = other.unknown2
      }
      if other.hasApiUrl {
           apiUrl = other.apiUrl
      }
      if (other.hasUnknown6) {
          try mergeUnknown6(other.unknown6)
      }
      if (other.hasAuthTicket) {
          try mergeAuthTicket(other.authTicket)
      }
      if !other.payload.isEmpty {
          builderResult.payload += other.payload
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResponseEnvelop.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseEnvelop.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          unknown1 = try input.readInt32()

        case 16 :
          unknown2 = try input.readInt64()

        case 26 :
          apiUrl = try input.readString()

        case 50 :
          let subBuilder:ResponseEnvelop.Unknown6.Builder = ResponseEnvelop.Unknown6.Builder()
          if hasUnknown6 {
            try subBuilder.mergeFrom(unknown6)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          unknown6 = subBuilder.buildPartial()

        case 58 :
          let subBuilder:ResponseEnvelop.AuthTicket.Builder = ResponseEnvelop.AuthTicket.Builder()
          if hasAuthTicket {
            try subBuilder.mergeFrom(authTicket)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          authTicket = subBuilder.buildPartial()

        case 802 :
          payload += [try input.readData()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}


// @@protoc_insertion_point(global_scope)
